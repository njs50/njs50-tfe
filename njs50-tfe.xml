<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>parse prompt</name>
			<script>-- only used to estimate when blocks of text end now

raiseEvent(common.events.PARSED_PROMPT)

</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^&lt;</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>logged in...</name>
			<script>if (murder.exploring) then
  cecho('\nCancelling explore!')
	murder.exploring = false
end

if (gmcp.Char) then
  gmcp.Char.Score = {}
  gmcp.Char.Status = {}
  gmcp.Char.Vitals = {}
end

if (njs50.gmcp) then
  njs50.gmcp.charReady = false
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^\d+ players on\.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>You recite a scroll of recall.</name>
			<script>expandAlias('farm stop')
-- send('cstat I just recalled. feel free to laugh at my ineptitude')

if (group.leader == player.name) then
  murder.groupDo('recite recall')
end

send('stand &amp; east &amp; drink cauld')
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>You recite a scroll of recall.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>You have been KILLED!!</name>
			<script>send('gtel I died in room #' .. tostring(tfe.previousRoomInfo.num))
send('stand &amp; |remove gold.ball.light,ball.mage-light')
if (group.leader == player.name) then
  murder.groupDo('recite recall')
end

tempTimer(5, function()
  send('|stand &amp; |remove golden.ball.light,ball.mage-light &amp; |put golden.ball.light,ball.mage-light ' .. player.pack)
end, 'post death delay')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>You have been KILLED!!</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>necklace of shielding. bleh</name>
			<script>local item = common.dotCase(matches[4])
local action = matches[2]

common.timedTempTrigger(10, 1, [[^The shimmering energy shield you were wearing gently fades out of existence\.]], function ()
	send(action .. ' ' .. item)
end)


</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You must remove a shimmering energy shield before you can (remove|equip) (an?|the) (.*)\.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>autoreconnect</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>select character</name>
				<script>-- relog last logged in char
if (autoconnect.enabled and player and player.name) then
  njs50.timedTempTrigger(5, 1, [[^]] .. player.name,  function()
    send(player.name)
  end)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Or, type the name of a character to enter the game. </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Thank you for visiting The Forest's Edge.</name>
				<script>if (autoconnect.enabled) then
  cecho('\n&lt;orange&gt;AUTOCONNECT: &lt;white&gt;disabling due to quit\n')
  autoconnect.enabled = false
  tempTimer(5, function()
    cecho('\n&lt;green&gt;AUTOCONNECT: &lt;white&gt;enabling for next login\n')
    autoconnect.enabled = true
  end, 're-enable autoconnect after quit')
end
   </script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Thank you for visiting The Forest's Edge.</string>
					<string>+++ Link closed by new login +++</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>common</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Your throat feels dry.</name>
				<script>send('dw')

timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
	send('stand &amp; dw &amp; ef')
	tempTimer(1, function () send('sleep') end)
end)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Your throat feels dry.</string>
					<string>^You are thirsty.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>^You are mildly hungry.</name>
				<script>local isMounted = table.contains(gmcp.Char.Status.flags,"mounted")

if isMounted then
  send('dismount')
end

send('ef')


if isMounted then
  send('mount')
end


timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
	send('stand &amp; dw &amp; ef')
	tempTimer(1, function () send('sleep') end)
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You are mildly hungry.</string>
					<string>Your stomach rumbles with pangs of unnatural hunger.</string>
					<string>You are hungry.</string>
					<string>You are no longer afflicted by the hunger of the undead.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>out of food</name>
				<script>disableTrigger('out of food')
display(player.hasFoodBasket)


tempTimer(3, function()
  enableTrigger('out of food')
end)

if (player.hasFoodBasket) then

  send('get basket ' .. player.pack .. ' &amp; |search basket &amp; eat food &amp; put basket ' .. player.pack)

  -- You reach your hand into the basket and root around, but come up empty-handed.

elseif (player.caster) then



   if (common and common.getManaAndCast) then

    common.getManaAndCast(15, 'create food', '', false, function ()
    		send('eat food')
    	end)

  else

    timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  		send('stand &amp; cast create food &amp; eat food')
    end)

    send('cast create food &amp; eat food')

  end




else
	send('gt out of food')
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Nothing found matching "food".</string>
					<string>You aren't carrying any items matching "food".</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>empty juice</name>
				<script>
disableTrigger('empty juice')

tempTimer(3, function()
  enableTrigger('empty juice')
end)


local vessel = common.dotCase(matches[2])

if player.hasBarrel then
  
  send('get ' .. player.vessel .. ' ' .. player.pack)

  send('gl')
    send('|get ' .. player.barrelBag .. ' loot')
  send('pl') 
  send('|get barrel.' .. player.barrelContains .. ' ' .. player.barrelBag)
  
  send('fill empty.' .. player.vessel .. ' ' .. player.barrelContains .. '.barrel')
  send('put ' .. player.barrelContains .. '.barrel ' .. player.barrelBag)
  send('gl') 
    send('put ' .. player.barrelBag .. ' loot')
  send('pl') 
  send('dw') 
  send('put ' .. player.vessel .. ' ' .. player.pack)

elseif player.hasSoupBarrel then

  send('gl &amp; get barr.soup loot &amp; fill empty.' .. player.vessel .. ' soup.barrel')
  send('put soup.barr loot &amp; pl &amp; dw') 
  
elseif player.hasWaterBarrel then

  send('gl &amp; get barr.water loot &amp; fill empty.' .. player.vessel .. ' water.barrel')
  send('put water.barr loot &amp; pl &amp; dw') 
      
elseif (player.caster and gmcp.Char.Score.class == 'druid') then
  
  local cmd = 'cast dowse &amp; cast dowse &amp; ' ..
    'queue fill empty.' .. vessel .. ' puddle.clear &amp; drink puddle.clear'
    
    send(cmd)
    
    timedTempTrigger(3, 1, 'You cannot do that while sleeping\.$', function ()
  		  send('stand &amp; ' .. cmd .. ' &amp; queue sleep')
    end)
    
    timedTempTrigger(3, 1, 'Perhaps you should stand first\.$', function ()
  		  send('stand &amp; ' .. cmd)
    end)    


elseif (player.caster) then

  send('stand &amp; remove blanket')
  caster.createWater(vessel, function()
    send('drink ' .. vessel .. '.water')
  end, function()
    send('gstat help! i fucked up making water in ' .. vessel)
  end)

else

	send('gt out of juice')
  send('give empty.' .. vessel .. ' to Mohoonay')

end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^An? (.*) you are carrying is already empty.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>intro back</name>
				<script>-- A muscular ogre with scarred knuckles greets you and introduces himself as 'Brazden'.

local vic = matches[3]

local convert = {
  hal = 'the',
  elf = 'elv',
  liz = 'sli',
}

local lang = string.sub(gmcp.Char.Score.race, 1, 3)

if convert[lang] then lang = convert[lang] end

send('|lang vya &amp; |intro ' .. vic)
send('|lang human &amp; |intro ' .. vic)
send('|lang ' .. lang .. ' &amp; |intro ' .. vic)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>introduces (him|her)self as '(.+)'\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>created bad water</name>
				<script>local vessel = common.dotCase(matches[2])

if player.caster and matches[3] ~= 'water' then

  timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
		send('stand &amp; remove blanket &amp; empty ' .. vessel .. ' &amp; cast create water .. ' .. vessel .. ' &amp; wear blanket &amp; sleep')
  end)

	send('empty ' .. vessel)
  send('remove blanket &amp; cast create water ' .. vessel)

else

  timedTempTrigger(2, 1, '^You cannot do that while sleeping\.$', function ()
  	send('stand &amp; drink ' .. vessel .. '.water &amp; sleep')
  end)

	send('drink ' .. vessel .. '.water')

end


 -- Nothing found matching "dark crystal goblet".</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^An? (.*) fills to overflowing with (.*).</string>
					<string>^An? (.*) fills partially up with (.*).</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>awakened by pain</name>
				<script>send('sl')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You are suddenly awakened by the feeling of pain.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>dying of thirst etc</name>
				<script>
common.getAffects(function (affects) 

  if (affects["You feel the hunger of the undead."] == "temporary") then
    cecho('\n\n&lt;red&gt;HUNGRY: &lt;white&gt;suffering from hunger of the undead!!!\n\n')
    send('eat corpse &amp; ef')
  else
    send('ct poor management has led me to quit due to hunger or thirst.')
    expandAlias('quit')
  end

end)


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You are dying</string>
					<string>^You are starving to death!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>add commas everywhere</name>
				<script>
selectString(matches[3],1)
replace(common.commaCase(matches[3]))
-- cecho(' &lt;- &lt;green&gt;replaced some numbers\n')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*? )(\d{5,})(.*?)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>+++ You cast create food +++</name>
				<script>send('eat food')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+++ You cast create food +++</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>magic sleep wears off</name>
				<script>-- You feel the cloak of silence enveloping you lift.

send('stand &amp; group')
murder.scan('woke up')
player.equippingSet = nil
if (healer and healer.clearQueued) then
  healer.clearQueued()
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You no longer feel sleepy.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sprawling</name>
				<script>disableTrigger('sprawling')
send('|stand &amp; |ord all stand')
tempTimer(1, function () enableTrigger('sprawling') end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>sends you sprawling (on|in) the \w+!$</string>
					<string>^A(n)? .* delivers a quick kick, knocking you down to the ground!</string>
					<string>^Perhaps you should stand first.</string>
					<string>^The fall .* you!</string>
					<string>^.* knocks you head over heels!$</string>
					<string>^You fall</string>
					<string>sending you sprawling!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>trip over fins</name>
				<script>send('remove diving.fins &amp; stand')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You trip on your diving fins and fall over.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>teamwork</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>meet at x</name>
				<script>local rnum = matches[3]
send('look')

tempTimer(2, function ()

  tfe.gotoRoom(rnum, function ()
    	tempTimer(1, function ()
    		send('gstat ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.num))
    	end)
  end)

end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "meet at (\d+)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>set next assist mob</name>
				<script>local vic = matches[3]
player.nextTarget = vic
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) reports? group status[^:]*: "next is (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>set next room deets</name>
				<script>-- local vic = matches[3]
-- player.nextTarget = vic

-- You report group status: "next room has 7 targets, aoe-safe, destroy: gelatinous.cube"
-- You report group status: "next room has 2 targets, no-aoe, attack: wolf.flam, cc-order: 1.monstrou.glassy.ooze,1.wolf.flam"

local tank = matches[2]

if (tank == 'You') then 
  tank = player.name
end

local nextRoom = {
  targetCount = tonumber(matches[3]),
  aoe = matches[4] == 'aoe-safe',
  nasty = matches[5] == 'destroy',
  target = matches[6],
  ccMobs = matches[7],
}

if (group.leader == tank) then
  
  -- delayed setting of nextRoom in case we haven't finished processing the current room
  tempTimer(0, function()
    player.nextRoom = nextRoom
    player.nextTarget = nextRoom.target
  end)
  
else
  cecho('\n\n&lt;red&gt;TEAMWORK:&lt;white&gt; next room command came from non tank\n\n')
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) reports? group status[^:]*: "next room has (\d+\.?\d*) targets?, (aoe-safe|no-aoe), (attack|destroy): (.*?), cc-order: (.*)"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>go to x</name>
				<script>local pname = matches[3]
local rnum = matches[4]

if (pname == player.name) then
	send('gt omw')

  tempTimer(2, function ()

    tfe.gotoRoom(rnum, function ()
      	tempTimer(1, function ()
      		send('gstat ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.num))
      	end)
    end)

  end)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w+) go to (\d+)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>druid go to x</name>
				<script>local pname = matches[3]
local rnum = matches[4]

if (pname == player.name) then

	send('gstat omw')

  if (tfe.locations[rnum]) then
    rnum = tfe.locations[rnum]
  end

  druid.landwalk(function ()
    tfe.gotoRoom(rnum, function ()
      	tempTimer(1, function ()
      		send('gstat ' .. player.name .. ' is now at ' .. tostring(tfe.roomInfo.num))
      	end)
    end)
  end)
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w+) landwalk to (.+)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>where are you</name>
				<script>local pname = matches[3]

if (pname == "" or pname == player.name) then
   send('gstat ' .. player.name .. ' is at ' .. tostring(tfe.roomInfo.num))
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w*) ?where are you\?"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>time for x</name>
				<script>expandAlias(matches[4])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "time (for|to) (.*)"</string>
					<string>^(You) tell your group[^:]*: "time (for|to) (.*)"</string>
					<string>^(An? .+?|The .+?|\w+) reports? group status: "time (for|to) (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>x time for y</name>
				<script>
if (matches[3] == player.name) then
	expandAlias(matches[4])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w+) can you (.*)"</string>
					<string>^(An? .+?|The .+?|\w+) reports group status[^:]*: "(\w+) can you (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>someone joins a group</name>
				<script>send('group')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You join (.*)'s group.</string>
					<string>^(.*) joins (.*)'?s? group.</string>
					<string>^You remove (.*) from your group.</string>
					<string>^You leave (.*)'s group.</string>
					<string>^(.*) stops following you.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>pause/resume murder mode</name>
				<script>if (matches[2] == 'paused') then

	murder.sleepMode = 'paused'

	common.setParryState(true, 'murder mode paused', function ()
		send('gstat holding off on the murdering')
	end, true)

else
	common.setParryState(false, 'murder mode resumed', function ()
		send('gstat resuming the murdering')
	end, false)

	murder.sleepMode = 'next'
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\S+ reports group status[^:]*: "murder time (paused|resumed)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>command by leader or authority figure</name>
				<script>
local from = matches[2]
local cmd = matches[3]

local hideSpam = njs50.ui.supressCommandSpam or false

if(from == group.leader or clan.acceptableMasters[from]) then

  if (not hideSpam) then
    cecho('\n&lt;green&gt;TEAMWORK: &lt;white&gt;command issued by ' .. from .. ': ' .. cmd)
  end
  
  if (rex.find(cmd, [[^(t|te|tel|tell|jun|junk|ti|tit|titl|title) ]]) and not rex.find(cmd, [[^tell ]] .. from .. ' ')) then
    send('tell ' .. from .. ' 403 Forbidden')
  elseif (rex.find(cmd, [[;]])) then
    send('tell ' .. from .. ' 403 Forbidden')    
  else 
    send('tell ' .. from .. ' running command: ' .. matches[3], false)
    expandAlias(matches[3], hidespam) 
  end

else
	cecho('&lt;red&gt;TEAMWORK: &lt;white&gt;command issued by non leader')
  send('tell ' .. from .. ' 401 Not Authorized')
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) tells you:\s*"do (.+)"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>condition report</name>
				<script>if (#gmcp.Char.Status.conditions == 1 and gmcp.Char.Status.conditions[1]) then
	send('gstatus healthy - ' .. player.name )
else
  for idx, state in pairs(gmcp.Char.Status.conditions) do
  	if (state ~= 'sober') then
  		send('gstatus ' .. state .. ' - ' .. player.name )
      if (state == 'hungry') then
        send('ef &amp; ef')
      end
  	end
  end
end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* reports? group status: "condition report"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>conditional prep</name>
				<script>-- display(matches)

local mana = matches[2]
local heals = matches[3]
local storms = matches[4]

if (mana == '') then mana = nil end
if (heals == '') then heals = nil end
if (storms == '') then storms = nil end

-- display(mana, 'x', heals, 'y', storms, 'z')


local healers = {
  cleric = true
}

local casters = {
  druid = true,
  paladin = true,
  mage = true,
  reaver = true,
}

local stormers = {
  druid = true,
}

local class = gmcp.Char.Score.class

local needPrep = false

if (healers[class] and heals) then
  if (healer.avg_heal * healer.getPrepped() &lt; tonumber(heals)) then
    send('gstat need prep')
    needPrep = true
  end
end

-- paladins only need a couple of backup heals ready to go. vs 1000hp for healer &gt; 450hp = 3xrally
if (class == 'paladin' and heals) then
  if (healer.avg_heal * healer.getPrepped() &lt; (tonumber(heals) * 0.45)) then
    send('gstat need prep')
    needPrep = true
  end
end

if (casters[class] and mana) then
  if (gmcp.Char.Vitals.en / gmcp.Char.Vitals.maxen &lt; tonumber(mana)/100) then
    send('gstat need prep')
    needPrep = true
  end
end

if (player.stormEnabled and stormers[class] and storms) then
  if (not player.stormSpell or not player.prepped[player.stormSpell] or player.prepped[player.stormSpell] &lt; tonumber(storms)) then
    send('gstat need prep')
    needPrep = true
  end
end

if not needPrep then
  send('gstat prepared enough')
end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^[^"]* reports? group status: "report if(?: mana &lt; (\d+)%)?,?(?: heals &lt; (\d+)hp)?,?(?: storms &lt; (\d+))?"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>refill vessel</name>
				<script>
send('empty ' .. player.vessel)

if (matches[2] ~= '') then
  send('fill ' .. player.vessel .. ' ' .. matches[2])
else

  send('fill ' .. player.vessel .. ' soup')
  send('fill ' .. player.vessel .. ' water')
  send('fill ' .. player.vessel .. ' clear.liquid')
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* tells? (?:the|your) group[^:]*:\s+"refill ?(.*)"$</string>
					<string>^.* reports? group status: "refill ?(.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>log messages</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>practice point / imp</name>
				<script>-- ** You improve at escape. **
-- ** You gain a practice point from escape. **
if (common.chatConsole) then
  common.chatConsole:cecho('Other', '&lt;yellow&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. matches[1] .. "\n")
end

if (matches[2] == 'improve at') then
	send('save')
end

tempTimer(40, function()
  cecho('\n\n&lt;yellow&gt;PRAC:&lt;white&gt; prac/imp cd probably finished\n\n')
end, 'prac/imp ICD')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\*\* You (gain a practice point from|improve at) (.*)\. \*\*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>parsing stuff</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse score (position and condition)</name>
				<script>player.position = matches[2]
player.condition = string.split(matches[3], ' ')

if (common.tableHasValue(player.condition, 'delirious')) then
	cecho('\n&lt;green&gt;SCORE: &lt;white&gt;tripping with the fishes\n')
	player.tripping = true
else
	player.tripping = false
end

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
	raiseEvent(common.events.PARSED_SCORE)
end)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+Position:\s+\[\s+(\w+)\s+]\s+Condition: \[\s+(\w+)\s+\]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse inventory</name>
				<script>
-- display(matches)

-- a stick of blue chalk           1  .10   a simple mug of water           1  .27
-- a fragment of burning red stone                                          1  .50

if (matches[2] == 'Coins') then

	-- start of inventory
	player.coins = tonumber(matches[3])
	player.coinWeight = tonumber(matches[4])
	player.parsingInventory = true
	player.inventory = {}


else

	if (matches[2] == 'Number') then
		-- this is the end of the inventory

		raiseEvent(common.events.PARSED_INVENTORY)
		player.parsingInventory = false

	else

		-- inventory line
		player.inventory[matches[2]] = tonumber(matches[3])

		if(matches[5]) then
			player.inventory[matches[5]] = tonumber(matches[6])
		end

	end

end


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Coins): (\d+) = \[ .* \] \s+ Weight: (\d+\.\d+) lbs</string>
					<string>^\s+(Number):\s+(\d+)\s+\( Max =\s+(\d+) \)</string>
					<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)\s+(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
					<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse affects</name>
				<script>echo('^^ --- looking at affects...\n')
player.affects = {}

local affectWatcher = tempRegexTrigger([[^((?:A|Your?|Divinely) .+?)\s{3,}(\S.*)$]], function ()
	player.affects[matches[2]] = matches[3]
end)

common.onNextEvent(common.events.PARSED_PROMPT, function()

	killTrigger(affectWatcher)
	raiseEvent(common.events.PARSED_AFFECTS, player.affects)

end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Affect\s+Source\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse prepped</name>
				<script>player.prepped = {}

local prepTrig = tempRegexTrigger([[^\s*(\d+)\s*(.+?)\s*\d+\s*$]], function ()
	player.prepped[matches[3]] = tonumber(matches[2])
end)

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
  cecho('\n&lt;green&gt;PREP:&lt;white&gt; finished parsing prepped spells\n\n')
	killTrigger(prepTrig)
	raiseEvent(common.events.PARSED_PREPARED, player.prepped)
end)	</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You have no spells prepared.</string>
					<string>^Num\s+Spell\s+Mana\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse equipment</name>
				<script>player = player or {}
player.gear = player.gear or {}
player.itemSlot = player.itemSlot or {}

if (matches[2] == 'Equipment') then
	-- start of parsing

  player.gear = {}
  player.itemSlot = {}
  
  player.gear.parsing = true
	-- cecho(' &lt;--- parsing start')
  
  -- end on next prompt
  tempPromptTrigger(function()
    	-- end of parsing
    	player.gear.parsing = nil
    	player.gearCurrentSlot = nil
    
    	raiseEvent(common.events.PARSED_EQUIPMENT)
    	-- cecho(' &lt; --- parsing end')  
  end, 1)

elseif player.gear.parsing then

 	-- if this line has a slot, get rid of the redundant part and set it to be the current slot
	if (matches[2] ~= '') then
		player.gearCurrentSlot = rex.gsub(matches[2], [[^(floating|worn on|worn around|worn about) ]], "", 1)
	end

	local item = common.itemSanitize(matches[4])

	player.gear[player.gearCurrentSlot] = player.gear[player.gearCurrentSlot] or {}
	player.gear[player.gearCurrentSlot][matches[3]] = {item = item, condition = matches[5] }

	player.itemSlot[item] = {slot=player.gearCurrentSlot, layer=matches[3]}
	-- cecho(' &lt;--- its some gear ')

end



           </script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+ \+\+\+ (Equipment) \+\+\+</string>
					<string>^(.*?)\s+(bottom|under|base|over|top)\s+(.*?)\s+(worthless|damaged|very worn|worn|very scratch|scratched|reasonable|good|very good|excellent|perfect)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse skills</name>
				<script>-- replicate             unk        1920    8    minor enchantment [7] &amp; continual light [7]
-- riding                 10
-- ryoushi               unk          16    5

-- cecho('&lt;green&gt; &lt;--- incoming skills')

player.skills = player.skills or {}
local skillParser = tempRegexTrigger([[^(.+?)\s{2,}(\d+|unk)]], function()

  local skill = matches[2]
  local level
  if (matches[3] == 'unk') then
    level = 0
  else
    level = tonumber(matches[3])
  end
  player.skills[skill] = level
end)

common.onNextEvent(common.events.PARSED_PROMPT, function ()
  -- cecho('&lt;green&gt; &lt;--- incoming skills done')
  killTrigger(skillParser)
  -- display(player.skills)
  raiseEvent(common.events.PARSED_ABILITIES, player.skills)
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Skill\s+Level\s+Cost\s+Pracs\s+Prerequisites\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>improve</name>
				<script>-- ** You improve at escape. **

local skill = matches[2]

if (player.skills and player.skills[skill]) then

  player.skills[skill] = player.skills[skill] + 1
  
  send('gtell ' .. skill .. ' has improved to ' .. tostring(player.skills[skill]))

else

  send('abil all')

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\*\* You improve at (.*)\. \*\*</string>
					<string>^.+ teaches you (.+?)[,.]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse who</name>
				<script>
-- cecho(' &lt;green&gt;&lt;- who starts\n')

local who = {
  Befriended = {},
  Known = {},
  Unknown = {},
  clan = {}
}

local playerType = multimatches[2][2]

local ptTrig = tempRegexTrigger([[^\s+(Befriended|Known|Unknown)\s*$]], function()
  playerType = matches[2]
  -- cecho(' &lt;green&gt;&lt;- pt: ' .. playerType .. '\n')
end)


local pTrig = tempRegexTrigger([[\[\s+(\d+)? (\w+|\?\?)\s+(\w\w\w)\s+(\w\w)?\s+\] (\w+)[,. ](.*?)\s+ (\w\w\w\w| -- )]], function()
  -- display(matches)
  -- cecho(' &lt;green&gt;&lt;- captured\n')
  local playa = {
    level = matches[2],
    class = matches[3],
    race = matches[4],
    flags = matches[5],
    name = matches[6],
    title = matches[7],
    clan = matches[8],
  }
  
  if (playa.level == '') then
    playa.level = 0
  else
    playa.level = tonumber(playa.level)
  end

  if (playa.clan ~= ' -- ') then
    who.clan[playa.clan] = who.clan[playa.clan] or {}
    who.clan[playa.clan][playa.name] = playa
  end
  
  who[playerType][playa.name] = playa
  
end)


tempRegexTrigger([[^\s+\[\s+\d+ players \|\s+\d+ high \|\s+\d+ record \]\s*$]], function()
  -- cecho(' &lt;green&gt;&lt;- who ends\n')
  killTrigger(ptTrig)
  killTrigger(pTrig)
  raiseEvent(common.events.PARSED_WHO, who)
end, 1)


-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                                   -- Befriended
                                   -- ----------
-- [   ??   Vyn CL ] Chundrick is in Medienne for Shields                   BoTS
-- [ 88 Dru Ogr    ] Mojune is lost                                         BoTS
-- [   ??   Hum    ] Shopiere tell me report to find my location             -- 
-- 
                                     -- Known
                                     -- -----
-- [ 88 Mag Ogr    ] Bede is in Wastes                                      BoTS
-- [   ??   Ogr    ] Bimgore the ogre                                        -- 
-- [ 87 Thi Gob    ] Brazden is an Australian sex symbol. Rawr.             BoTS
-- [ 51 Brd Orc    ] Kathaar Werewolf bar mitzvah, spooky scary.            BoTS
-- [ 85 Mon Trl    ] Milthian following                                     BoTS
-- [ 87 Mon Liz    ] Shazzul Slens                                          BoTS
-- [ 90 Thi Vyn    ] Taldoran.                                              BoTS
-- [   ??   Ogr    ] Umarra follow-mode                                      -- 
-- [ 90 Dru Gob    ] Uni nil                                                 -- 
-- 
                                    -- Unknown
                                    -- -------
-- [   ??   Ogr    ] Affenaut incomprehensible at worst. afk at best.        -- 
-- [   ??   Hum    ] Anri is running Theatre in the Hills                    -- 
-- [ 30 Dru Ent    ] Ashera is running Rabbits                               -- 
-- [ 90 Thi Gob    ] Avlis is running: Castle Lag                            -- 
-- [   ??   Dwf    ] Calimar is running MBEARS                               -- 
-- [ 90 Cle Ogr    ] Corim the ogre cleric                                   -- 
-- [ 83 Pal Hum    ] Cyhi Fin.                                              SAGE
-- [ 40 Mon Hum    ] Drakondor the human                                     -- 
-- [ 49 War Hum    ] Euphe Jergaaaaaaaaaault!                                -- 
-- [ 49 Pal Ogr CL ] Gnoggh Citadull                                        BoTS
-- [   ??   Vyn    ] Katria is rather self-destructive.                      -- 
-- [ 90 Pal Vyn    ] Lafiel Celestine, has lost HOPE.                        -- 
-- [ 90 Mag Vyn    ] Mazren was inspiration for the vyan wizard doll         -- 
-- [   ??   Ogr    ] Nitia.                                                  -- 
-- [  5 Thi Gob    ] Paulus the goblin                                       -- 
-- [   ??   Hum    ] Seras now with major enchant                            -- 
-- [ 90 Mon Gob    ] Shingo the goblin                                       -- 
-- [ 90 Mon Liz    ] Straus the lizardman                                    -- 
-- [ 90 Brd Orc    ] Thalos the sonic blender                                -- 
-- [   ??   Hum    ] Thullkor I don't know where.                            -- 
-- [ 30 Thi Gob    ] Trea is in Stonies                                     BoTS
-- [ 72 Cle Ogr    ] Wahooka, PST if you need to smile.                      -- 
-- [ 21 Ran Elf    ] Xamdam the elf                                          -- 
-- [ 16 Mag Gob CL ] Yurvin Sphinxes                                        SAGE
-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                      -- [ 36 players | 36 high | 46 record ]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</string>
					<string>^\s+(Befriended|Known|Unknown)\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>xp calc</name>
				<script>xp_record = xp_record or {}

table.insert(xp_record, {dt = getEpoch(), val = tonumber(matches[2])})</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive (\d+) experience points\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>player status</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>not tripping anymore</name>
				<script>player.tripping = false</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The world returns to normal color.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tripping</name>
				<script>player.tripping = true</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You see colors.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>standing status</name>
				<script>player.position = 'standing'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You wake and stand up.</string>
					<string>^You stand up.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sleep status</name>
				<script>player.position = 'sleeping'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You lie down and go to sleep</string>
					<string>^You go to sleep .*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>resting status</name>
				<script>player.position =  'resting'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You wake and sit up.</string>
					<string>^You sit down.*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Parry set to x.</name>
				<script>if (matches[2] == 'true') then
	player.parry = true
else
	player.parry = false
end

player.parryQueue = (player.parryQueue or 1) - 1
cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

if player.parryQueue &lt; 0 then
  player.parryQueue = 0
  cecho('\n&lt;red&gt;PARRY: &lt;white&gt;attempted to reduce queue below zero\n')
end

raiseEvent(common.events.PARRY_STATE_CHANGE)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Parry set to (true|false)\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>silenced - self</name>
				<script>display(gmcp.Char.Status)
send('gstat I have been silenced')

-- You wrap yourself in the warm embrace of your game hunter's fur blanket, letting your worries slip away. 

-- You remove a game hunter's fur blanket.</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You feel a cloak of silence envelop you.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>un-silenced - self</name>
				<script>send('gstat silence has gone')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You feel the cloak of silence enveloping you lift.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>removed game hunters blanky</name>
				<script>disableTrigger('un-silenced - self')

tempTimer(0.5, function()
  enableTrigger('un-silenced - self')
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You remove a game hunter's fur blanket.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>wore game hunters blanky</name>
				<script>disableTrigger('silenced - self')

tempTimer(0.5, function()
  enableTrigger('silenced - self')
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You wrap yourself in the warm embrace of your\s+(something|game hunter's fur blanket)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Combat</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>inc mobs fighting</name>
				<script>combat.add(matches[3])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An?|The) (.*) leaps to attack you!$</string>
					<string>^(An?|The) (.*) counterattacks you!</string>
					<string>^(An?|The) (.*) says (in primal): "Have at you, then!"</string>
					<string>^(An?|The) (.*) says (in primal): "Please....please...h-help me..."</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>dec mobs fighting</name>
				<script>combat.remove(matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive \d+ experience points\.</string>
					<string>^An? (.*) blindly flees (north|east|south|west|up|down).</string>
					<string>^An? (.*) vanishes in the blink of an eye!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>blocked|arrival|slept - extend room check</name>
				<script>combat.extendRoomCheck()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#0900ff</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(A|An|The) (.*) is blocking the exit to the (north|east|south|west|up|down)\.$</string>
					<string>^(A|An|The) (.*) arrives from the (north|east|south|west|up|down)\.$</string>
					<string>^(A|An|The) (.*) drops .* asleep\.</string>
					<string>You begin casting sleep.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>disarmed</name>
				<script>echo('disarmed!!!')
send('wear ' .. common.dotCase(matches[3]))
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\+\+\+ .+ disarms your (enchanted )?([^!]+)!  \+\+\+</string>
					<string>thrusts (his|her|their) shield against your ([^,]*),</string>
					<string>parries your attack and quickly moves to disarm you, sending your ?(enchanted )?(.*) flying!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>counterattack</name>
				<script>combat.counterattack(matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You counterattack an? (.*)!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>slept a mob</name>
				<script>combat.sleeping(matches[3])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(A|An|The) (.*) drops .* asleep\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Damage Meter?</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Caster assignment</name>
				<script>
-- `echo Mojune casts conflagration.
-- `echo A raging inferno *** DISINTEGRATES *** [437] a blue-skinned demon!  [ bleeding freely ]

-- Gnoggh unleashes a dissonant assault at a gigantic spider!
-- The head-splitting dissonance * THUNDERS * [196] a gigantic spider!  [ badly wounded ]

local caster = matches[2]
local spell = matches[3]

if (caster == 'You') then
  caster = player.name
end

-- track DoT spells
if rex.find(spell, [[^(tornado|tempest)]]) then
  combat.dots = combat.dots or {}
  combat.dots[spell] = caster
end


if not rex.find(spell, [[^(cure|heal|restoration|group|mists|purify|neutralize|fear|paralyze|group|slow|web|probe|silence)]]) then

  combat.dealer = caster
  combat.type = 'spell'
  combat.spell = spell
  combat.target = ''

else

  cecho('&lt;orange&gt; &lt;- non damage spell\n')
  combat.dealer = caster
  combat.type = ''
  combat.spell = ''
  combat.target = ''

end




</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#dee930</mFgColor>
				<mBgColor>#110092</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) casts (.*)\.</string>
					<string>^\+\+\+ (You) cast (.*) \+\+\+</string>
					<string>^(\w+) unleashes a (dissonant assault)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Melee assignmnet</name>
				<script>
-- You deflect a blue-skinned demon's obsidian claw rake and smash your shield into him!
-- Your shield strike SAVAGES [41] a blue-skinned demon!  [ covered in blood ] &lt;- proc Darion : 41

                                                                                        -- .
-- Darion deflects a blue-skinned demon's obsidian claw rake and smashes him with his shield!
-- Darion's shield strike SAVAGES [41] a blue-skinned demon!  [ covered in blood ]

local caster = matches[2]
local spell = matches[3]

if (caster == 'You') then
  caster = player.name
end

combat.dealer = caster
combat.type = 'melee'
combat.spell = ''
combat.target = ''

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(You|[A-Z][a-z]+)'?s? [^[]+[!.]$   </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>unassigned damage</name>
				<script>
-- removing things with 's in em due to tyrant's wife

-- ^((\S+).*?) (\** ?\w+ ?\**) \[(\d+)\]\s*((\S+).*)'s.*[!.]\s+\[\s+(.*?)\s+\]$


-- these should be legit:

-- The sword's thrust devastates [25] a beautiful witch!  [ slightly scratched ]
-- A raging inferno *** DISINTEGRATES *** [437] a blue-skinned demon!  [ bleeding freely ]
-- Your fire shield singes [1] a flying snake.  [ several wounds ]

-- A raging inferno ** INCINERATES ** [278] a tyrant's wife!



-- this is a problem after someone has cast a non damage spell:
-- A darkling's oily, musty secretion hits [3] a grasshopper mouse's small brown body.  [ several wounds ]

-- shoulld not match any of these:

-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- The brilliant bolt of lightning ELECTRIFIES [78] Mojune!  [ few bruises ]

-- An orcish monk of the hidden order's spider kick DISEMBOWELS [81] your head!
-- A monk of the hidden order's serpent strike CRIPPLES [52] you!
-- The brilliant bolt of lightning ELECTRIFIES [78] Mojune!  [ few bruises ]

-- damage before mob
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order's muscular arm!  [ some cuts ]

-- damage after mob
-- Your strike hits a red efreet's billowing flames [3].  [ slightly scratched ]
-- Your strike hits a red efreet [3].  [ slightly scratched ]


-- local caster = player.name
local spell = matches[2]
local spellFirstWord = matches[3]
local damageString = matches[4]
local damage = tonumber(matches[5])
local target = matches[6]
local targetFirstWord = matches[7]
local targetState = matches[8]



-- spell first word could be a group member!
if (spellFirstWord == 'You' or spellFirstWord == 'Your') then
  spellFirstWord = player.name
end
-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
spellFirstWord = spellFirstWord:gsub("'?s?[.!]?$", "")

-- targetFirstWord could be a group member
if (targetFirstWord == 'you' or targetFirstWord == 'your') then
  targetFirstWord = player.name
end
-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
targetFirstWord = targetFirstWord:gsub("'?s?[.!]?$", "")


if (group.members[spellFirstWord]) then
  -- cecho('\nGroup mmember attack, not unassigned...\n')
  combat.dealer = spellFirstWord
  combat.type = 'melee'
  combat.spell = ''
  combat.target = target

  if rex.match(damageString, [[^(scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*)$]]) then
     -- this was melee damage and will be picked up elsewhere
     return
  else

    -- setting combat type to proc for any non melee damage done directly by a player.
    -- this should allow us to ignore ion/ice shield etc type damage when determining who a player is hitting
    combat.type = 'proc'

  end

end

if (group.members[targetFirstWord]) then
  -- cecho('\nmob attacking group member, not unassigned...\n')
  combat.type = ''
  return
end


if (combat.type and combat.type ~= '') then

  local attackData = {
    subject = combat.dealer,
    damageType = combat.type,
    move = spell,
    mob = target,
    damage = damage,
    mobState = targetState,
  }

  if (combat.type == 'spell') then
    attackData.move = combat.spell
    combat.type = ''
  else
    attackData.damageType = 'proc'
    
    -- tempest damage:
    if rex.find(spell, [[^(A crash of thunder|Twisting winds|A bolt of lightning)]]) then
      cecho('&lt;orange&gt; &lt;- tempest damage\n')
      attackData.subject = combat.dots.tempest
    end    
    
  end

  if (group.members[attackData.subject]) then
    raiseEvent(common.events.COMBAT_ATTACK, attackData)
  else
    cecho('&lt;orange&gt; &lt;- non party member fighting\n')
  end

else
  cecho('&lt;- &lt;red&gt;COMBAT: &lt;white&gt;unsure who to allocate this damage to\n')
end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>4</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#dee930</mFgColor>
				<mBgColor>#10341f</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^((\S+).*?) (\** ?\w+ ?\**) \[(\d+)\]\s*((\S+).*)[!.]\s+\[\s+(.*?)\s+\]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>hit - non attack</name>
				<script>-- Your charge *** ANNIHILATES *** [500] a bulette's tough legs!
-- You charge at a bulette, but she moves out of the way.

-- Mohoonay's attack misses an ogre miner.
-- Shazzul hits an imposing fire giant witch-doctor with a power strike!

-- ^(You|Your|[A-Z][a-z]+?) hits (.*) with a (great cleave|cleave|power strike|critical hit)[!.]$
-- Shazzul parries a large shaggy wolf's attack, leaving her vulnerable to a counterattack!

-- You attempt to charge a minotaur guardian, but miss and fall down.
-- Uduvrin attempts to charge an elven city guard, but he misses and falls down.

-- Taldoran smashes the stone, but reveals nothing.
-- Taldoran smashes the stone with all his might, revealing a small opening below it.

-- Moira kicks an ethereal blue stag, knocking him down to the ground.
-- With a well timed kick you knock an elvish field worker down to the ground!

-- Taldoran places his hand on the plaque and a bright light engulfs him!
-- ^(You|[A-Z][a-z]+) places his hand on the plaque and a bright (light engulfs) (.*)!


-- Mojune malevolently swings again at a mountain bear!
--    You malevolently swing  again at your jinxed opponent!

-- Mojune swings both his  weapons forward at once!
--    You swing  both your weapons forward at once!

-- As Mojune uncrosses his arms, Mojune swings again!
-- As you    uncross your arms, you swing again!

-- Mojune channels Ulthi's chaotic destruction!
--    You channel  Ulthi's chaotic destruction!

--    You jab forward with both weapons!
-- Mojune jabs forward with both weapons!

-- You lash out again at your jinxed opponent!

-- Your wroth grows stronger with entropic lust!
-- Your wroth grows stronger with entropic portent!

-- You feint left - then right - then charge right at a large mound of earth!
-- Your charge distracts a large mound of earth and you siphon energy from your victim!
-- Your charge distracts a reflection of you and you launch a double attack!
-- Your charge distracts a large mound of earth and you launch a sweep kick!

local subject = matches[2]
local move = matches[3]
local mob = matches[4]

local attacks = {
  ['great cleave'] = true,
  ['cleave'] = true,
  ['power strike'] = true,
  ['critical hit'] = true,
  ['counterattack'] = true,
  ['fall down'] = true,
  ['falls down'] = true,
  ['revealing'] = true,
  ['reveals nothing'] = true,
  ['knocking'] = true,
  ['out of the way'] = true,
  ['miss your mark'] = true,
}

local swapMove = {
  ['knocking'] = 'trip',
  ['knock'] = 'trip',
  ['out of the way'] = 'charge_miss',
  ['miss your mark'] = 'charge_miss',
  ['weapons forward'] = 'doublecross',
}
			
-- swap mob and move if required
if (attacks[mob]) then
  local temp = mob
  mob = move
  move = temp
end

if (swapMove[move]) then
  move = swapMove[move]
end


if (subject == 'you' or subject == 'You' or subject == 'Your' or subject == 'With') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")


-- You charge at someone, but he moves out of the way.

local attackData = {
  subject = subject,
  move = move,
  mob = mob or '',
  damage = 0,
  damageType = 'no-damage',
}

-- display(attackData)

if (attackData.mob == 'someone' and move == 'charge_miss') then
  cecho('&lt;orange&gt; &lt;- probably a bugged charge\n')
elseif (group.members[attackData.subject]) then
  combat.lastPlayer = subject
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#d6ab00</mFgColor>
				<mBgColor>#1c1873</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(You|[A-Z][a-z]+) leaps? to (attack) (.*)[!.]$</string>
					<string>^(You|[A-Z][a-z]+) (miss)e?s? (.*)[!.]$</string>
					<string>^(You|[A-Z][a-z]+) (counterattack|critically hit|)s? (.*)[!.]$</string>
					<string>^(You|Your|[A-Z][a-z]+?)'?s? (great cleave|cleave|power strike) hits (.*)[!.]$</string>
					<string>^(Your|[A-Z][a-z]+)'s attack (miss)e?s? (.*)[!.]$</string>
					<string>^(You|Your|[A-Z][a-z]+?) hits (.*) with a (great cleave|cleave|power strike|critical hit)[!.]$</string>
					<string>^(You|[A-Z][a-z]+) (gouges) (.*) in the eye[!.]$</string>
					<string>^(You|[A-Z][a-z]+) calls upon the (shadows to deestroy) (.*)[!.]$</string>
					<string>^(You|[A-Z][a-z]+) parries (.+?)'?s? attack, leaving .* vulnerable to a (counterattack)[!.]$</string>
					<string>^(You|[A-Z][a-z]+) attempts? to charge (.*), but s?h?e? ?misse?s? and (falls? down)[!.]$</string>
					<string>^(You|[A-Z][a-z]+) (smash)e?s? the stone, but (reveals nothing).</string>
					<string>^(You|[A-Z][a-z]+) (smash)e?s? the stone with all his might, (revealing)</string>
					<string>^(You|[A-Z][a-z]+) kicks? (.*), (knocking) \w+ down</string>
					<string>^(With) a well timed kick you (knock) (.*) down</string>
					<string>^(You|[A-Z][a-z]+) charge at (.*), but (?:she|he|it|they) moves? (out of the way)\.$</string>
					<string>^(You|[A-Z][a-z]+) attempts? to charge (.*), but (miss your mark)\.$</string>
					<string>^(You|[A-Z][a-z]+) attacks? with (frenzy)!$</string>
					<string>^(You|[A-Z][a-z]+) (malevolently) swings? again at</string>
					<string>^(You|[A-Z][a-z]+) swings? both (?:his|her|your|their) (weapons forward) at once</string>
					<string>^As (you|[A-Z][a-z]+) (uncross)e?s? (?:his|her|your|their) arms, </string>
					<string>^(You|[A-Z][a-z]+) channels? Ulthi's (chaotic destruction)!</string>
					<string>^(You|[A-Z][a-z]+) jabs? forward with (both weapons)!</string>
					<string>^(You|[A-Z][a-z]+) (lashe?s? out) again at your jinxed opponent!</string>
					<string>^(Your|[A-Z][a-z]+?)'?s? wroth grows stronger with (entropic lust|entropic portent)!</string>
					<string>^(You|[A-Z][a-z]+) (feint)s? left - then right - then charges? right at</string>
					<string>^(You|[A-Z][a-z]+) charge distracts (?:.+) and you (siphon energy) from your victim!</string>
					<string>^(You|[A-Z][a-z]+) charge distracts (?:.+) and you launch a (double attack|sweep kick)!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>hit - damage first</name>
				<script>-- damage before mob

-- Darion's blow MUTILATES [56] an orcish monk of the hidden order!  [ some cuts ]
-- Darion's blow MUTILATES [56] an orcish monk of the hidden order's muscular arm!  [ some cuts ]


local subject = matches[2]

local damageType = 'melee'

if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")

combat.dealer = subject
combat.type = 'melee'
combat.spell = ''
combat.target = ''

if (subject == 'Ulthi') then
  subject = combat.lastPlayer
  damageType = 'proc'
end


local attackData = {
  subject = subject,
  move = matches[3],
  mob = matches[6],
  damage = tonumber(matches[5]),
  damageType = damageType,
  mobState = matches[7],
}

if (group.members[attackData.subject]) then
  combat.lastPlayer = subject
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#e13b95</mFgColor>
				<mBgColor>#1c1873</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) \[(\d+)\] (.*)'s .*[!.]\s+\[\s*(.+?)\s*\]$</string>
					<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) \[(\d+)\] (.+?)[!.]\s+\[\s*(.+?)\s*\]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>hit - damage last</name>
				<script>
-- damage after mob
-- Your strike hits a red efreet's billowing flames [3].  [ slightly scratched ]
-- Your strike hits a red efreet [3].  [ slightly scratched ]



local subject = matches[2]

local damageType = 'melee'


if (subject == 'You' or subject == 'Your') then
  subject = player.name
end

-- replace any 's i.e (Darion's) crushing blow -&gt; Darion
subject = subject:gsub("'s$", "")

combat.dealer = subject
combat.type = 'melee'
combat.spell = ''
combat.target = ''


if (subject == 'Ulthi') then
  subject = combat.lastPlayer
  damageType = 'proc'
end


local attackData = {
  subject = subject,
  move = matches[3],
  mob = matches[5],
  damage = tonumber(matches[6]),
  damageType = damageType,
  mobState = matches[7],
}

if (group.members[attackData.subject]) then
  combat.lastPlayer = subject
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#e13b95</mFgColor>
				<mBgColor>#1c1873</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.+)'s .* \[(\d+)\][!.]\s+\[\s*(.+?)\s*\]$</string>
					<string>^(Your|[A-Z][a-z]+'s) (.+) (scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|SAVAGES|CRIPPLES|MUTILATES|DISEMBOWELS|\* DISMEMBERS \*|\* EVISCERATES \*|\* MASSACRES \*|\* PULVERIZES \*|\*\* DEMOLISHES \*\*|\*\* EXTIRPATES \*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* ERADICATES \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.+) \[(\d+)\][!.]\s+\[\s*(.+?)\s*\]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>player avoided damage</name>
				<script>
-- You    quick step  away from a cloud of insects's attack.
-- Mojune quick steps away from a cloud of insects's attack.

-- You parry a cloud of insects's attack with your kopis of bloodletting.
-- Mojune parries a cloud of insects's attack with his kopis of bloodletting.

local subject = matches[2]
local move = matches[3]
local aggressor = matches[4]
local damageType = 'avoidance'

if (aggressor == 'counterattack') then
  move = 'riposte'
  aggressor = matches[3]
end 

-- need to flip subject and agressor for misses
if (move == 'misses') then
  move = 'avoided'
  subject = aggressor
  aggressor = matches[2]
end

if (string.lower(subject) == 'you' or string.lower(subject) == 'your') then
  subject = player.name
end

if (string.lower(aggressor) == 'you' or string.lower(aggressor) == 'your') then
  aggressor = player.name
end

if (move == 'parry' or move == 'parries') and matches[5] and subject == player.name then
  move = 'parry - ' .. matches[5] 
end

if group.members[aggressor] then
  local temp = aggressor
  aggressor = subject
  subject = temp
  damageType = 'no-damage'
end


-- A statue of an ogre parries Darion's attack with his barbed dagger.

-- A statue of a goblin mounted on a mule dodges your attack.
-- A statue of an ogre guards from Darion's attack.
-- A statue of an ogre dodges Darion's attack.
-- A statue of an ogre dodges your attack.
-- A temple guardian guards from your attack.

-- A dark forest nymph tumbles away, avoiding your attack.

local attackData = {
  subject = subject,
  move = move,
  mob = aggressor,
  damage = 0,
  damageType = damageType
}

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting?\n')
end



-- A desert ogre bodyguard guards from Darion's attack.



-- avoided:
-- A cloud of insects's attack misses you.
-- You dodge a cloud of insects's attack.
-- You parry a cloud of insects's attack with your flowing silver shortspear 'Hand of the Just'.
-- You parry a yeti's attack, leaving it vulnerable to a counterattack.
-- You guard yourself from a cloud of insects's attack.
-- You block a cloud of insects's stinging bite with your shimmering energy shield.


-- absorbed:
-- The air crackles as a cloud of insects's stinging bite is mysteriously blocked.
-- Your foot armor absorbs a cloud of insects's stinging bite.
-- A cloud of insects's stinging bite seems to hit you, but does no damage.
-- Your body armor absorbs a cloud of insects's stinging bite.
-- Your head armor absorbs a cloud of insects's stinging bite.

-- hit:
-- A bridge troll's slash injures [5] your body.
-- A dark pikeman's thrust maims [30] your head!
-- A dark pikeman's pike slash devastates [26] your body!
-- A dark pikeman's thrust devastates [26] your foot!
-- A dark pikeman's pike slash devastates [24] your body.
-- A dark pikeman's thrust devastates [25] your leg!
-- A dark pikeman's charged thrust devastates [25] your arm!
-- The dark pikeman ducks a heavy shoulder and charges!
-- A dark pikeman's shoulder ram MUTILATES [61] your head!

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00e21b</mFgColor>
				<mBgColor>#1c1873</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.+)'s attack (misses) (\w+)[.!]$</string>
					<string>^(.+) (dodge|dodges) (.+?)'?s? attack[.!]$</string>
					<string>^(.+) (parry|parries) (.+?)'?s? attack with (?:your|his|her|their) (.*)\.$</string>
					<string>^(.+) (guards?) (?:yourself )?from (.+?)'?s? attack[.!]$</string>
					<string>^([A-Z].+) (blocks?) (.+?)'?s? </string>
					<string>^(.+) (?:parry|parries) (.+?)'?s? attack, leaving (?:it|him|her|them|you) vulnerable to a (counterattack)[.!]$</string>
					<string>^(.+) (parry|parries) (.+?)'?s? attack[.!]$</string>
					<string>^(.+) (tumbles) away, avoiding (.+?)'?s? attack\.$</string>
					<string>^(.+) (quick step)s? away from (.+?)'?s? attack\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>player was hit</name>
				<script>local subject = matches[4]
local damage = tonumber(matches[3]) or 0
local aggressor = matches[2]
local damageType = 'avoidance'
local move = 'hit'

-- A temple guardian's slashing arc MUTILATES [70] Myrth's head!  [ few bruises ]

-- The air crackles as a lizard's punch is mysteriously blocked.

-- Your head armor absorbs a cloud of insects's stinging bite.
if (matches[3] == 'absorbs') then
  subject = matches[2]
  aggressor = matches[3]
  damage = 0
  -- display({
    -- subject = subject,
    -- move = move,
    -- mob = aggressor,
    -- damage = damage,
    -- damageType = damageType,
  -- })
end

if (matches[4] == 'no damage') then
  subject = matches[3]
  damage = 0
end

if (matches[3] == 'mysteriously') then
  subject = player.name
  damage = 0
end


if (string.lower(subject) == 'you' or string.lower(subject) == 'your') then
  subject = player.name
end

if (string.lower(aggressor) == 'you' or string.lower(aggressor) == 'your') then
  aggressor = player.name
end

local shield = rex.match(matches[1], [[(?:fire|thorn|ion|ice) shield]])

if shield then 
  move = shield
  damageType = 'reflect'
end

local attackData = {
  subject = subject,
  move = move,
  mob = aggressor,
  damage = damage,
  damageType = damageType,
}

-- display(attackData)

if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end

-- The icy blast * HARDENS * [166] Darion!  [ some cuts ]
-- A bridge troll's slash injures [5] your body.
-- A great snow worm's attempt to devour * EVISCERATES * [115] you!
-- A great snow worm's eerie roar SHAKES [73] you!
-- A yeti's foot stomp maims [29] your leg!

-- The yeti's painful bellow jangles [11] you.

-- display(attackData)

-- absorbed:
-- The air crackles as a cloud of insects's stinging bite is mysteriously blocked.
-- A cloud of insects's stinging bite seems to hit you, but does no damage.
-- Your body armor absorbs a cloud of insects's stinging bite.
-- Your head armor absorbs a cloud of insects's stinging bite.
-- Your foot armor absorbs a cloud of insects's stinging bite.

-- hit:
-- A bridge troll's slash injures [5] your body.
-- A dark pikeman's thrust maims [30] your head!
-- A dark pikeman's pike slash devastates [26] your body!
-- A dark pikeman's thrust devastates [26] your foot!
-- A dark pikeman's pike slash devastates [24] your body.
-- A dark pikeman's thrust devastates [25] your leg!
-- A dark pikeman's charged thrust devastates [25] your arm!
-- The dark pikeman ducks a heavy shoulder and charges!
-- A dark pikeman's shoulder ram MUTILATES [61] your head!


-- 
-- 
-- local subject = matches[2]
-- 
-- if (subject == 'You' or subject == 'Your') then
  -- subject = player.name
-- end
-- 
-- -- replace any 's i.e (Darion's) crushing blow -&gt; Darion
-- subject = subject:gsub("'s$", "")
-- 
-- combat.dealer = subject
-- combat.type = 'melee'
-- combat.spell = ''
-- combat.target = ''
-- 
-- 
-- local attackData = {
  -- subject = subject,
  -- move = matches[3],
  -- mob = matches[5],
  -- damage = tonumber(matches[6]),
  -- damageType = 'melee',
  -- mobState = matches[7],
-- }
-- 
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#25ded3</mFgColor>
				<mBgColor>#1c1873</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The air crackles as (.*)'s .+ is (mysteriously) blocked[.!]$</string>
					<string>^(.*)'s .+ seems to hit (\w+), but does (no damage)[.!]$</string>
					<string>^(\w+)'?s? (?:finger|neck|body|head|leg|foot|hand|arm|waist|wrist) armor (absorbs) (.+?)'s</string>
					<string>^(.*)'s .* \[(\d+)\] (\w+) (?:finger|neck|body|head|leg|foot|hand|arm|waist|wrist)[.!]$</string>
					<string>^(.*)'s .* \[(\d+)\] (\w+)[.!]$</string>
					<string>^(.*)'s .* \[(\d+)\] (\w+) (?:finger|neck|body|head|leg|foot|hand|arm|waist|wrist)[.!]\s+\[ .* \]$</string>
					<string>^(.*)'s .* \[(\d+)\] (\w+)[.!]\s+\[ .* \]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sleep tracking</name>
				<script>-- Mohoonay casts sleep.
-- An ogre miner looks drowsy but quickly shrugs it off.

-- An ogre miner drops to the ground asleep.

-- A gnomish captain slips deeper into slumber.

-- Mohoonay casts sleep.
-- An ogre miner looks incredibly tired!
-- An ogre miner drops to the ground asleep.

if (combat.type and combat.type == 'spell' and combat.spell == 'sleep' and group.members[combat.dealer]) then

  local attackData = {
    subject = combat.dealer,
    damageType = combat.type,
    move = 'sleep - ' .. matches[3],
    mob = matches[2],
    damage = 0
  }

  combat.type = ''
    
  raiseEvent(common.events.COMBAT_ATTACK, attackData)

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) looks drowsy but quickly (shrugs) it off\.$</string>
					<string>^(.*) drops .* (asleep)\.$</string>
					<string>^(.*) slips (deeper) into slumber\.$</string>
					<string>^()(Nothing) happens\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>transfer to combat tab</name>
				<script>if (njs50.ui.useCombatTab) then
  common.chatConsole:append('Combat', true)
  deleteLine()
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#f928f2</mFgColor>
				<mBgColor>#210cff</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.+) screams at (.+)\.$</string>
					<string>^\w+ smashe?s? .+ into .+, setting \w+ up for a powerful jab!$</string>
					<string>^.+ counterattacks \w+[!.]$</string>
					<string>^\w+ screams? a cry of war, and attacks? with renewed fury!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>weapon procs</name>
				<script>-- The cleaver seems to come to life as it arcs around again!
-- Mojune's cleaver seems to come to life as it arcs around again!

-- With an attack from [weap], Myrth attempts to strike terror into a temple guardian!
-- With an attack from [weap], you attempt  to strike terror into a warrior woman!

-- You notice an opening and swing a runed mithril hand axe 'Vengeance' +3 you are wielding!

-- You swing the axe into a powerful back-swing, aiming your axe's hook right at an acolyte. 

-- Your     axe streaks through the air, moving in for another strike!
-- Mojune's axe streaks through the air, moving in for another strike!

-- A force wave from your shield slams into a desert ogre sentry!
-- A force wave from Mojune's shield slams into a desert ogre sentry!

local subject = matches[2]
local move = matches[3]
local mob = matches[4]

local switchSubjectMove = {
  ['force wave'] = true
}

if (switchSubjectMove[subject]) then
  move = subject
  subject = matches[3]
end


if (string.lower(subject) == 'you' or string.lower(subject) == 'your' or string.lower(subject) == 'the') then
  subject = player.name
end




local attackData = {
  subject = subject,
  move = move,
  mob = mob or '',
  damage = 0,
  damageType = 'weapon-proc',
}


if (group.members[attackData.subject]) then
  raiseEvent(common.events.COMBAT_ATTACK, attackData)
else
  cecho('&lt;orange&gt; &lt;- non party member fighting\n')
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.+?)'?s? cleaver seems to come to life as it (arcs) around again!$</string>
					<string>^With an attack from .+?, (\w+) attempts? to (strike terror) into (.+)!$</string>
					<string>^(.+?)'?s? battle axe crackles with (blue-green sparks) of energy!$</string>
					<string>^(.+?)'?s? notice an (opening) and swing .+? you are wielding!$</string>
					<string>^(You) swing the axe into a powerful (back-swing), aiming your axe's hook right at .*\.$</string>
					<string>^(.+?)'?s? axe streaks through the air, moving in for (another strike)!</string>
					<string>^A (force wave) from (your|\w+)'?s? shield slams into (.*)!</string>
					<string>^(The|[A-Z][a-z]+'s) battle axe crackles with (silver sparks) of energy!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>puzzles</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>solve hanoi</name>
				<script>local json = common.json

cecho('&lt;green&gt; &lt;---&lt;white&gt; hello plates!!\n')

local plates = {
  {}, {}, {}
}

moveCursor(0, getLineNumber())

for  i=1, 5 do
  moveCursorUp(1)
  selectCurrentLine()
  local text = getSelection()
  -- table.insert(lines, text)
  
  for m in rex.gmatch(text, [[\s\*+\s]]) do
  
    local start, finish = text:find(m, nil, true)
    
    start = start + 1;
    finish = finish;
    length = finish - start
    center = start + ( (length - 1) / 2)
    
    if (center == 40) then
      table.insert(plates[3], length)
    elseif (center == 24) then
      table.insert(plates[2], length)
    elseif (center == 8) then
      table.insert(plates[1], length)
    end
    
  end 
  
end

if (#plates[3] == 5) then
  
  send('gstat puzzle solved')
  player.hanoi = nil
  
else

  local swap = function (x,y)
    -- tempTimer(0.1, function()
      if (#plates[x] == 0) then
        send('move ' .. y .. ' ' .. x)
        player.hanoi_lastmoved = x
      elseif (#plates[y] == 0) then
        send('move ' .. x .. ' ' .. y)
        player.hanoi_lastmoved = y
      elseif plates[x][#plates[x]] &lt; plates[y][#plates[y]] then
        send('move ' .. x .. ' ' .. y) 
        player.hanoi_lastmoved = y       
      elseif plates[x][#plates[x]] &gt; plates[y][#plates[y]] then
        send('move ' .. y .. ' ' .. x)
        player.hanoi_lastmoved = x
      else
        cecho('\n\nsomething is fucked\n\n')
      end
      -- display(common.json.encode(plates), 'swapping ' .. tostring(x) .. ' and ' .. tostring(y))
    -- end)
  end

-- make the legal move between pegs A and C (in either direction),
-- make the legal move between pegs A and B (in either direction),
-- make the legal move between pegs B and C (in either direction),
-- repeat until complete.


  -- player.hanoi = player.hanoi or -1
  -- player.hanoi = (player.hanoi + 1) % 3

  -- if (player.hanoi == 0) then
   -- swap(1, 3)
  -- elseif (player.hanoi == 1) then
    -- swap(1, 2)
  -- elseif (player.hanoi == 2) then
    -- swap(2,3)
  -- else
    -- cecho('fail time!')
  -- end
  
  -- if all are on plate 1, move first bit to plate 3
  player.hanoi_lastmoved = player.hanoi_lastmoved or -1
  
  local isEven = function (x)
    if (((x+1)/2) % 2 == 0) then
      return true
    end
    return false
  end
 
   
  local getVal = function(x) 
    if #plates[x] == 0 then return 0 end
    return plates[x][#plates[x]]
  end
  
  
  local swapValue = function(x, y)
    
    if (x == player.hanoi_lastmoved) then return -1 end
    
    if (x == y) then return -1 end
    
    local valx = getVal(x)
    local valy = getVal(y)
    
    if valx == 0 then return -1 end
    
    if valy == 0 then return 0 end

    if valx &gt; valy then return -1 end
    
    if isEven(valx) and isEven(valy) then return -1 end
    
    if (not isEven(valx)) and (not isEven(valy)) then return -1 end
    
    return valy
  
  end

  
  if (#plates[1] == 5) then
    
    send('move 1 3')
    player.hanoi_lastmoved = 3
  
  elseif (#plates[2] == 5) then
    
    send('move 2 3')
    player.hanoi_lastmoved = 3
    
  else
    
    
    local bestVal = -1
    local bestX, bestY
    
    for i=1,3 do 
      for j=1,3 do
        local thisSwapVal = swapValue(i,j)
        if (thisSwapVal &gt; bestVal) then
          bestVal = thisSwapVal
          bestX = i
          bestY = j
          -- display(bestVal,getVal(bestX),getVal(bestY))
        end
      end
    end
    -- 
    -- display(common.json.encode(plates), 'swapping bestval:' .. tostring(bestVal) .. ' -&gt; ' .. tostring(bestX) .. ' and ' .. tostring(bestY))
    -- display(swapValue(bestX, bestY))
    
    if (bestVal ~= -1) then
      send('move ' .. tostring(bestX) .. ' ' .. tostring(bestY))
      player.hanoi_lastmoved = bestY
    else
      cecho('\nNo valid moves!!! - moving at random\n\n')
      for i=1,3 do 
        for j=1,3 do
          if (i ~= j and i ~= player.hanoi_lastmoved and getVal(i) &lt; getVal(j)) then
            send('move ' .. tostring(i) .. ' ' .. tostring(j))
            player.hanoi_lastmoved = j
            return
          end
        end
      end
    end
  end

end






-- "   *********          ***              *       "</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>\_____________/ \_____________/ \_____________/</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>solve sliding tile puzzle - js</name>
				<script>tp = tp or {}

tp.nodes = tp.nodes or { {}, {}, {}, {} }


tp.y = tp.y or 0
tp.y = tp.y + 1


if (tp.y == 1) then
  
  cecho('&lt;green&gt; &lt;-- start tile puzzle\n')
  
  -- setup trig to parse lines
  tp.parseLines = tempRegexTrigger([[\|\s+(\d*)\s+\|\s+(\d*)\s+\|\s+(\d*)\s+\|\s+(\d*)\s+\|]], function()
  
    for idx=1, 4 do
      
      -- display(idx)
      local thisVal = matches[idx+1]
      
      
      if (thisVal ~= '') then
        thisVal = tonumber(thisVal)
      end

      
      table.insert(tp.nodes[tp.y], thisVal);
      
      
      
      
    end

    
  end)  
end



if (tp.y == 5) then


  cecho('&lt;green&gt; &lt;-- end tile puzzle\n')
  
  killTrigger(tp.parseLines)
  
  display(tp)
  
  local url = catalog.serverUrl .. "/puzzle/tile"
  -- local url = 'http://localhost:3000' .. "/puzzle/tile"


  -- first we create something to handle the success, and tell us what we got
  registerAnonymousEventHandler('sysPostHttpDone', function(event, rurl, response)
    
    if rurl == url then 

      local solution = common.json.decode(response)
      
      if (#solution == 0) then
      
        send('shake puzzle &amp; look puzzle')
        
      else
        
        disableTrigger('solve sliding tile puzzle - js')
        
        tempBeginOfLineTrigger('Success!', function()
          enableTrigger('solve sliding tile puzzle - js')
        end, 1)
        
        for idx, piece in ipairs(solution) do
          send('shift ' .. tostring(piece))
        end
     
      end
      
      
    else 
      return true 
    end -- this will show us the response body, or if it's not the right url, then do not delete the handler
    
  end, true) -- this sets it to delete itself after it fires 
    
  postHTTP(common.json.encode(tp.nodes), url, {["Content-type"] = "application/json"})

    
  tp = nil
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>=====================</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>mapping-ex-tfe-mapper (should be converted to special exits)</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>climb up fail</name>
				<script>send('climb up')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You grab the thick tree bark and begin upwards, but come sliding back down.</string>
					<string>You slip on some slime and fall back into the water.</string>
					<string>You will have to climb your way out of here it looks like.</string>
					<string>Unable to get a good handhold, you slip and fall.</string>
					<string>You grab ahold of the face of the cliff, but lose your grip.</string>
					<string>You can't fly!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>up failed</name>
				<script>send('up')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You struggle up the steep slope, only to come sliding back down.</string>
					<string>You try to tackle the large hill, but come sliding back down its grassy side.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>special doors/exits</name>
				<script>
local exitDir = matches[2]

cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to exit... ' .. tfe.roomInfo.num .. '\n' )

local exits = {
	[27500] = 'knock three',
	[2522]  = 'jump pit',
}


if exits[tfe.roomInfo.num] then

  send(exits[tfe.roomInfo.num])

end


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The oak door to the east is closed.</string>
					<string>I dunno, it looks kinda like a long drop...</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that while mounted.</name>
				<script>common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
	send('mount')
end)
send('dismount')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that while mounted.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>need to climb up</name>
				<script>send('climb up')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>There's no way to reach the top of the cliff unless you have the ability to climb it.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>need to climb down</name>
				<script>send('climb down')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You step toward the edge of the cliff and decide not to walk off the edge.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>blind</name>
				<script>send('typo')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't see a thing!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>disbelieve illusion</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A face emerges from the living wall of sand</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>special exits</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>woodworms</name>
					<script>send('enter gap')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The gap is too small for you to just walk in.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>raven wood - dive</name>
					<script>send('dive water')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You will have to dive into the water.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>mapping</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>x pushes through the tangled vegetation.</name>
				<script>send('enter veget')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\w+ pushes through the tangled vegetation\.</string>
					<string>^\w+ pushes through the vegetation</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You try to summon the will to leap over the waterfall, but lose your nerve.</name>
				<script>send('leap edge')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You try to summon the will to leap over the waterfall, but lose your nerve.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You go right up to the face of the root and marvel at its size.</name>
				<script>send('climb root')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You go right up to the face of the root and marvel at its size.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>The pair of crystalline doors to the (north|south) are closed.</name>
				<script>send('insert rod &amp; open ' .. matches[3])
send('queue level &amp; queue scan')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The (pair of )?crystalline doors to the (south|north) are closed\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You cannot go down, you have to enter the opening.</name>
				<script>send('enter opening')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You cannot go down, you have to enter the opening.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>area specific</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>ents - knocked from room</name>
				<script>send('stand &amp; north &amp; k ent')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You are sent tumbling out of the room!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>vpalace - guard</name>
				<script>send('to guard unfortunate')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The guard will not let you pass</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>lag -chimera</name>
				<script>send('to chimera needle')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The chimera shifts his hindquarters so that they block the west exit.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>dunkrang - push pot faile</name>
				<script>send('push pot')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You put your weight against the giant pot but can't budge it!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>western expanse</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Distracted by the pretty lights, you walk straight into the wall and fall down.</name>
					<script>send('stand')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Distracted by the pretty lights, you walk straight into the wall and fall down.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tomb of order - blade pop</name>
				<script>send('get crys.blade')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>As a hulking suit of crystalline armor shatters into a pile of crystal shards, one of itsintact blades clatters to the ground!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cairn valley</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>failed to climb</name>
					<script>send('climb up')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You begin the climb up, but slide back down defeated.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The opening is much to steep just to jump down, you would need to climb down the shaft carefully.</name>
					<script>send('climb down')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The opening is much to steep just to jump down, you would need to climb down the shaft carefully.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The only way you might get back up is by climbing, and that looks extremely difficult if not
impossible.</name>
					<script>send('climb up')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The only way you might get back up is by climbing, </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tank went down</name>
					<script>local vic = matches[2]

if vic == group.leader then
  send('climb down &amp; climb down &amp; climb down')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) hangs his legs into the shaft, then slides down on his bum into the darkness.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You try to climb up the eastern slope of the pit, but slide back down on loose pebbles.</name>
					<script>send('east &amp; kill myc')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You try to climb up the eastern slope of the pit, but slide back down on loose pebbles.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You must find a way to clear the spiderwebs first.</name>
					<script>send('cut web')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You must find a way to clear the spiderwebs first.</string>
						<string>You hack at the webbing, but it seems to have little effect.</string>
						<string>Hacking at the webbing, you manage to get yourself tangled up badly.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You try to climb up the western slope of the pit, but slide back down on loose pebbles.</name>
					<script>send('west &amp; kill mycon')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You try to climb up the western slope of the pit, but slide back down on loose pebbles.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tank went up</name>
					<script>send('climb up &amp; climb up &amp; climb up')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^In an amazing feat of skill, (\w+) manages to get himself up the smooth wall of the shaft\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>There is no way through the collapsed tunnel.</name>
					<script>local exits = getRoomExits(gmcp.Room.Info.num)

for exit, rnum in pairs(exits) do
  if (not gmcp.Room.Info.exits[exit]) then
    cecho('\n\n&lt;orange&gt;MAP:&lt;white&gt; removing collapsed exit (' .. exit .. ') from map\n')
    setExit(gmcp.Room.Info.num, -1, exit)
    setExit(rnum, -1, tfe.consts.reverse_dirs[exit])
  end
end

murder.reroute()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>There is no way through the collapsed tunnel.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You plummet down the middle of the shaft, landing roughly far below!</name>
					<script>if (gmcp.Char.Score.class == 'cleric') then
  
  local isParryEnabled = table.contains(gmcp.Char.Status.flags, 'parry')
  
  if (isParryEnabled) then
    send('opt parry')
  end
  
  send('gstat i have fallen down a hole, attempting to summon leader!')
  common.getManaAndCast(75, 'summon', group.leader, false, function ()
    	send('gstat leader summoned!')
    if (isParryEnabled) then
      send('opt parry')
    end      
  end)

else

  local cleric = ''
  for member, data in pairs(gmcp.Group.members) do
    if data.class == 'cleric' then
      cleric = member
    end  
  end
  
  if (cleric ~= '') then
    send('tell ' .. cleric .. ' summon')
  end

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You plummet down the middle of the shaft, landing roughly far below!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>cave in reroute needed</name>
					<script>disableTrigger('cave in reroute needed')

if (gmcp.Room.Info.area == "Cairn Peak Ruins") then
  send(matches[2])
end

tempTimer(5, function()
  enableTrigger('cave in reroute needed')
end, 'reenable cave in reroute trigger')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Nothing found matching "(north|east|south|west)"\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>prepped</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You have prepared x.</name>
				<script>if matches[3] then
 	player.prepped[matches[3]] = tonumber(matches[2])
else
	player.prepped[matches[2]] = 1
end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You have prepared (.+?)\.$</string>
					<string>^You now have (\d+) incantations of (.+?) prepared.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>+++ You cast x +++</name>
				<script>if (healer.spell and matches[2] == healer.spell) then
  healer.reduceQueued();
end
  
if (player.prepped and player.prepped[matches[2]]) then 
  
	player.prepped[matches[2]] = player.prepped[matches[2]] - 1
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\+\+\+ You cast (.+?) \+\+\+</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>^&gt;&gt; Your x casting is disrupted. &lt;&lt;</name>
				<script>-- treat as if we cast it, hp check should trigger a new heal

if (player.prepped[matches[2]]) then 
  
  player.prepped[matches[2]] = player.prepped[matches[2]] - 1
  
  if (healer.spell and matches[2] == healer.spell) then
    healer.reduceQueued();
  end

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^&gt;&gt; Your (.+?) casting is disrupted. &lt;&lt;</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>silenced-cast</name>
				<script>-- undo the heal added to the queue
healer.reduceQueued();
-- player.prepped[healer.spell] = player.prepped[healer.spell] + 1
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't cast spells while silenced.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You don't have x prepared.</name>
				<script>
if (player.prepped[matches[2]]) then 
  
  player.prepped[matches[2]] = 0
  
  if (healer.spell and matches[2] == healer.spell) then
    healer.clearQueued()
  end

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You don't have (.+?) prepared\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>prep clear</name>
				<script>player.prepped = {}</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>All prepared spells forgotten.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>healing</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>healer commands</name>
				<script>if (player.healer) then
  
  local from = matches[2]
  
  local chan = matches[3]
  
  local target = matches[4]
  
  local cmd = matches[5]
  
  local args = matches[6]
  
  if chan == 'tell' then
    chan = chan .. ' ' .. matches[2]
  end
  
  if chan == 'tells the group' then
    chan = 'gstat'
  end
  
  if chan == 'group status' then
    chan = 'gstat'
  end
  
  local commands = {
  
    ["help"] = function ()
      healer.help(chan)
    end,
  
    ["config"] = function ()
      healer.showConfig(chan)
    end,  
  
    ["gsummon"] = function ()
      expandAlias('gsummon')
    end,  
    
    ["summon"] = function (vic)
    
      if (not vic or vic == '') then
        vic = from
      end
      
      local vnum = gmcp.Room.Info.num
      
      if (vnum == 170 or vnum == 107 or clan.acceptableMasters[vic] or group.members[from]) then
        
        if (gmcp.Room.Info.area == "Castle Lag II") then
          send('tell ' .. vic .. ' summons not available while i amn in ' .. gmcp.Room.Info.name)
        else
                
          njs50.cast('summon', { 
            target = vic,
            failCallback = function(err)
              send('tell ' .. vic .. ' ' .. err)
            end
          })  
        end
        
      else
      
        send('tell ' .. vic .. ' insufficiently authorized for summons outside of med')
      
      end
      
    end,  
    

          
    ["mode"] = function (mode)
      healer.setMode(mode, chan)
    end,
  
    ["set"] = function (params)
      healer.set(params, chan)
    end,
 
    ["minPrepped"] = function (params)
      healer.setMinPrepped(params, chan)
    end,   
        
    ["spell"] = function (params)
      healer.setHealSpell(params, chan)
    end,
  
  
  }
  
  
  if (target ~= 'you' and #target &gt;= 2 and rex.match(player.name:lower(), target:lower())) then
    target = 'you'
  end
  
  
  if (target == 'you') then
  
    if commands[cmd] then
    
      commands[cmd](args)
   
    end
    
  end
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) (tell)s (you): "(\w+) ?(.*)"$</string>
					<string>^(.+?) reports? (group status): "(\w+) (\w+) ?(.*)"</string>
					<string>^(.+?) (tells? the group): "(\w+) (\w+) ?(.*)"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>joined group</name>
				<script>if (player.healer) then
  healer.help('gt')
 end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You join (\w+)'s group.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>silenced - clear queue</name>
				<script>healer.queued = 0</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't cast spells while silenced.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>murder bot</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>farmer commands</name>
				<script>local chan = matches[3]

if chan == 'tell' then
  chan = chan .. ' ' .. matches[2]
end

if chan == 'tells the group' then
  chan = 'gt'
end

if chan == 'clan status' then
  chan = 'cstat'
end

local commands = {

  ["cease and desist"] = function ()
    farmer.endAfterWithNotify(chan)
  end,
  
    
  ["report"] = function ()
    farmer.status(chan)
  end,
  
  ["status"] = function ()
    farmer.status(chan)
  end,

  ["bots report"] = function ()
    if (chan == 'ctell') then
      chan = 'cstat'
    end
    farmer.status(chan)
  end,

}

if commands[matches[4]] then
  commands[matches[4]]()
  
elseif (farmer.afkMode and matches[3] == 'tell') then

  if (not group.members[matches[2]]) then 
  
    if (player.lockoutReplySpam == nil) then
      player.lockoutReplySpam = true
      farmer.status(chan)
      tempTimer(5, function() 
        player.lockoutReplySpam = nil
      end)
    end
    
    common.sendSlack(matches[2] .. ' tells ' .. player.name .. ' : ```' .. matches[4] .. '```')
    
  end
  
end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) (tell)s you: "(.+)"$</string>
					<string>^([^:]*) (ctell)s: "(.+)"$</string>
					<string>^(.+?) (tells the group): "(.+)"$</string>
					<string>^(.+?) reports (clan status): "(.+)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>group member was blocked!</name>
				<script>-- lua `echo ** Stinky is blocked from following you.  **
-- lua `echo ** Darion is blocked from following you.  **
-- lua `echo You leave west.
-- ** Mojune is resting and so does not follow you.  **
-- ** Darion does not follow you.  **


-- these might be legit (sitting)
-- ^\*\* (.*) is resting and so does not follow you\.  \*\*
-- ^\*\* (.*) does not follow you\.  \*\*

local vic = matches[2]



if (group.members[vic]) then

  send('gstat EEEP! ' .. vic .. ' was blocked')

  -- only setup events for the first person blocked, the rest we just add to the rescue list
  if not player.rescueList then    
    
    player.rescueList = { vic }
    
    player.rescueWatcher = common.onNextEvent(tfe.events.ROOM_CHANGE_PENDING, function(evt, direction) 

      -- cancel anything queued and reverse the pending direction
      send('+' .. tfe.consts.reverse_dirs[direction])
      
      -- send the rescue commands
      for idx, player in ipairs(player.rescueList) do
        send('rescue ' .. player .. ' &amp; ' .. 'rescue ' .. player .. ' &amp; ' .. 'rescue ' .. player)
      end
      
      player.rescueList = nil
    end)
    
  
    -- if we are running a bot then try and resolve the mess we just made.
    if (murder.move_pending) then
      player.pendingRescue = true
      -- this will be the room we are in the process of moving into
      common.onNextEvent(common.events.SCAN_PROCESSED, function()
        -- this will be the room we do the rescuing in
        common.onNextEvent(common.events.SCAN_PROCESSED, function()
          player.pendingRescue = nil
          common.onNextEvent(common.events.ROOM_CLEAR, function()
            cecho('\n&lt;blue&gt;MURDER: &lt;white&gt;next was invoked (by room clear after rescue)!\n')
            murder.resetIdleTimer()
            murder.nextStep()        
          end)
        end)      
      end)
    end    

  else -- add aditional players blocked to the rescue list...
    table.insert(player.rescueList, vic)
  end


end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\*\* (.*) is blocked from following you.\  \*\*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>"I have been silenced"</name>
				<script>murder = murder or {}
murder.silenced = murder.silenced or {}

local vic = matches[2]

if not table.contains(murder.silenced, vic) then
  table.insert(murder.silenced, vic)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) reports group status: "I have been silenced"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>"silence has gone"</name>
				<script>murder = murder or {}
murder.silenced = murder.silenced or {}

local vic = matches[2]

if table.contains(murder.silenced, vic) then
  table.remove(murder.silenced, table.index_of(murder.silenced, vic))
  if #murder.silenced == 0 then
    murder.silenced = nil
  end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) reports group status: "silence has gone"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Combat</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>exit blocked</name>
				<script>local singleAttack = {
	['mists of sleep'] = true,
	['sleep'] = true
}

-- regular spell attack, queue up a couple of extras
if (player.attack_spell and not singleAttack[player.attack_spell]) then
	
	send('cast ' .. player.attack_spell .. ' ' .. common.dotCase(matches[2]))
	send('cast ' .. player.attack_spell)
	send('cast ' .. player.attack_spell)
	
else	
	
	-- sleep or mists, only cast one
	if (player.attack_spell) then
		
		local cmd = 'cast ' .. player.attack_spell
		
		-- if its mists, don't give a target
		if (player.attack_spell ~= 'mists of sleep') then
			cmd = cmd .. ' ' .. common.dotCase(matches[2])
		end
		
		send(cmd)
	
	-- regular attach		
	else	
		player.autoAttack(common.dotCase(matches[2]))
	end
	
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^An? (.*) is blocking the \w+ to the (north|east|south|west|up|down).</string>
					<string>^An? (.*) is blocking the \w+ (above|below) you\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>wakes</name>
				<script>-- currently not needed as we remove the extra mob on death
-- combat.wakes(matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(A|An|The) (.*) wakes and stands up.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>fall off mount</name>
				<script>send('mount')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>sending you tumbling from your mount!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>saw combat</name>
				<script>murder = murder or {}
murder.sawAction = true

if (gmcp.Char.Status.position ~= 'standing') then
  send('stand')
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive \d+ experience points\.$</string>
					<string>is DEAD!!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>reagents</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>A grain of sand lies almost invisible on the ground.</name>
				<script>send('get sand &amp; put 2.sand ' .. player.pack)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A grain of sand lies almost invisible on the ground.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>A pinch of mica glitters on the ground.</name>
				<script>send('get mica &amp; put mica ' .. player.pack)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A pinch of mica glitters on the ground.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>get sage</name>
				<script>send('get sage &amp; put sage ' .. player.pack)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A handful of sage, cedar, and cinnamon lies here in a small clump.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>snail shell</name>
				<script>send('get all.snail.shell &amp; put all.snail.shell ' .. player.pack)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A snail shell floats gently on the water.</string>
					<string>A snail shell has been dropped here.</string>
					<string>^\d+ snail shells lie on the ground here\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>improves</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>prac/imp happened</name>
				<script>
improves = improves or {}
improves.sawPrac = true


cecho('\n\n&lt;green&gt;IMPROVES: &lt;white&gt;saw a prac!\n\n')


if (improves.pracRelease) then
  killTimer(improves.pracRelease)
end

improves.pracRelease = tempTimer(40, function()
  -- send('stand &amp; |scan')
  improves.pracRelease = nil
  improves.sawPrac = nil
  improves.pracReleaseAt = nil
end, 'combat, sawPrac reset')

improves.pracReleaseAt = getEpoch() + 40</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\*\* You (gain a practice point from|improve at) (.*)\. \*\*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>saw combat</name>
				<script>
improves = improves or {}
improves.sawAction = true


cecho('\n\n&lt;green&gt;IMPROVES: &lt;white&gt;saw some action!\n\n')


if (improves.actionRelease) then
  killTimer(improves.actionRelease)
end
-- send('sleep')

improves.actionRelease = tempTimer(40, function()
  -- send('stand &amp; |scan')
  improves.actionRelease = nil
  improves.sawAction = nil
  improves.releaseAt = nil
end, 'combat, sawAction reset')

improves.releaseAt = getEpoch() + 40</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive \d+ experience points\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>team</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>get full</name>
				<script>expandAlias('pfull')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells? (?:your|the) group[^:]*: "(get full|pfull)"</string>
					<string>^.* reports? group status[^:]*: "(pfull|get full)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>stand up now!</name>
				<script>cecho('\n&lt;green&gt;TEAMWORK: &lt;white&gt;command to stand!')
expandAlias('upp')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells? (?:your|the) group[^:]*: "up"</string>
					<string>^\w+ reports? group status: "up"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>prep free</name>
				<script>expandAlias('pfree')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells? (?:your|the) group[^:]*: "(prep free|pfree)"</string>
					<string>^\w+ reports? group status: "pfree"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>get ready</name>
				<script>expandAlias('getReady')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* tells? (?:your|the) group[^:]*: "get ready"</string>
					<string>^.* reports? group status[^:]*: "get ready"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>njs50-mage</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>mage-sleep-plev</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>counterattacks - on wake</name>
					<script>
local target = common.dotCase(common.toMurderString(matches[2]))

if (not group.members[target] and murder.targets[target]) then

  probe.castBestSpell(target)
  
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) wakes and stands up\.$</string>
						<string>^(.*) jumps to (his|her|their) feet\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep adds where possible</name>
					<script>-- A stone giant arrives from the north.
-- A great snow worm arrives from the west.
-- considerably, as large clouds roll in from the north.

-- commented this out because it needs to target 3.yeti if there are alreday 2 yeti in the room

-- A minotaur guardian charges in from the south.
-- A minotaur guardian leaps to attack you!

-- no need to murder group members
if group.members[matches[2]] then
  return
end

local murderTarget = common.dotCase(common.toMurderString(matches[2]))
local target = string.lower(matches[2]):gsub(' ','.')

local mobs = gmcp.Char.Fighting

  display('something added', mobs, target )
-- 
  -- mobs = {
    -- ["2.a.yeti"] = {
      -- target = false,
      -- attacking = "",
      -- condition = "bruised",
      -- status = {
      -- }
    -- },
    -- ["1.a.yeti"] = {
      -- target = true,
      -- attacking = "Lacopa",
      -- condition = "bruised",
      -- status = {
      -- }
    -- }
  -- }
-- see if there are any mobs we are not targetting


local foundMob = false

local cc = 1
local ccMin = 0


for mob, state in pairs(mobs) do

  -- only consider the mob that just added
  local mobIdx = rex.match(mob, [[^(\d+)\.]] .. target)
  
  if (mobIdx) then
    cc = cc + 1    
  end
  
end

if (murder.targets[murderTarget] and probe.canSleep(murderTarget)) then

  -- try and sleep a couple more than are actually in the room just in case...
  for idx = cc + 2, 1, -1 do
    send('cast sleep ' .. tostring(idx) .. '.' .. target)
  end
  
end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ec00f3</mFgColor>
					<mBgColor>#f8ffb0</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Z].*) leaps to attack you[!.]$</string>
						<string>^([A-Z].*) counterattacks \w+[!.]$</string>
						<string>^([A-Z].*?) \w+ (in )?from the (north|east|south|west)\.$</string>
						<string>^([A-Z].*?) \w+ (in )?from (above|below)\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mists/sleep failed</name>
					<script>send('cast sleep')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) looks drowsy but quickly shrugs it off.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>plev - mob died</name>
					<script>
-- resting party members stand during sleep murder. ensure stand

-- A mountain bear cub is DEAD!!

local ignoreMobs = {
  ['A mountain bear cub'] = true
}


if not ignoreMobs[matches[2]] then
  murder.tapMobDied(true, matches[2])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+(.*) is DEAD!!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>plev - mob died out of room</name>
					<script>

murder.tapMobDied(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You hear something's death cry.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>falls asleep - murder mode</name>
					<script>local target = common.dotCase(common.toMurderString(matches[2]))



-- get the highest mob number from scan i.e if there are 3 yetis we should 
-- target 3.yeti

target = murder.getLastTargetInRoomMatching(target)

murder.mobSlept(target)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#42ff2d</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) drops .* asleep\.</string>
						<string>^(.*) slips deeper into slumber\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mob not here - prob already dead</name>
					<script>
murder.tapTargetMissing()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The room doesn't contain any beings matching</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>sleep failed - incapitated</name>
					<script>

local vic = common.dotCase(common.toMurderString(matches[2]))



local targetRoom = tonumber(tfe.speedwalking.path[tfe.speedwalking.pathPosition - 1])
local fleeDir = tfe.consts.reverse_dirs[ tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition - 1] ] ]

if not fleeDir then
  fleeDir = tfe.getDirectionToPreviousRoom()
end

send('+flee ' .. fleeDir .. ' &amp; |flee ' .. fleeDir .. ' &amp; wait 1 &amp; |flee ' .. fleeDir .. ' &amp; |flee ' .. fleeDir)




-- You flee south.
common.timedTempTrigger(5, 1, [[^You flee (.*)\.]], function()
  cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;fled due to incapacitate\n\n')
  murder.exitForSleepKill = true
	local fledDir = matches[2] 
  tempRegexTrigger([[^You hear something's death cry\.]], function()   
    send(tfe.consts.reverse_dirs[fledDir])    
    
    common.onNextEvent(tfe.events.ROOM_CHANGED, function()
      cecho('\n\n&lt;green&gt;MUDER: &lt;white&gt;returned after incapacitate death\n\n')
      murder.exitForSleepKill = nil
      murder.scan('returned from fleeing')
    end)
    
  end, 1)
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ffffff</mFgColor>
					<mBgColor>#ff06e7</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Z].+) is (incapacitated|mortally wounded|lying here stunned|stunned)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>status</name>
					<script>-- plev.danceThreshold = 0.35
-- 
-- plev.noAckThreshold = 0.55
-- 
-- plev.wakeCommand = 'kill'

send('gstat slowing murdering when mob is ' .. common.damStateInverse[tostring(plev.noAckThreshold)])

send('gstat leaving room when mob is ' .. common.damStateInverse[tostring(plev.danceThreshold)])


if (murder.waker) then
  send('gstat ' .. murder.waker .. ' will be waking mobs with: ' .. plev.wakeCommand)
else
  send('gstat wake command is: ' .. plev.wakeCommand)
end



-- report

local totalTime = getEpoch() - farmer.startTime
local lapTime = getEpoch() - farmer.lapStartTime



send('gstat Farm laps: ' .. tostring(farmer.lapCounter or 0))

if (lapTime ~= nil) then
	send('gstat Current lap time: ' .. common.formatElapsedTime(lapTime))
end

if (farmer.lapRepopWaitTime ~= nil) then
	send('gstat Current lap repop wait time: ' .. common.formatElapsedTime(farmer.lapRepopWaitTime))
end

if (farmer.lapInfo ~= nil) then
  for k, v in pairs(farmer.lapInfo) do
    send('gstat ' .. k .. ': ' .. tostring(v))
  end
else
  send('gstat no additional lap info')
end

if (totalTime ~= nil) then
	send('gstat Total time: ' .. common.formatElapsedTime(totalTime))
end

if (totalTime ~= nil and farmer.lapCounter &gt; 0) then
	send('gstat Average run time: ' .. common.formatElapsedTime((totalTime - lapTime) / farmer.lapCounter))
end

if (farmer.repopWaitTime ~= nil and farmer.lapCounter &gt; 0) then
	send('gstat Average repop wait time: ' .. common.formatElapsedTime(farmer.repopWaitTime / farmer.lapCounter))
end

if (farmer.killcount and farmer.killcount &gt; 0) then
  send('gstat Confirmed kills: ' .. tostring(farmer.killcount or 0))
end

if (farmer.cumulativeInfo ~= nil) then
  for k, v in pairs(farmer.cumulativeInfo) do
    local str = 'gstat ' .. k .. ': '
    for i=1, #v do
       str = str ..tostring(v[i])
       if (i ~= #v) then
        str = str .. ', '
       end
    end
    send(str)
  end
else
  send('gstat no additional lap info')
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports? group status[^:]*:\s+"status"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>probe</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>probe</name>
					<script>-- ^\s+Less\|More$
mobElements = mobElements or {}

local priority = { fire = 1, elec = 2, cold = 3, acid = 4 }

local probeMob

local resTrig

local probeResult = {
	magic = 0,
	fire = 0,
	cold = 0,
	elec = 0,
	acid = 0
}

local fullName = matches[2]:lower()


resTrig = tempRegexTrigger([[^(Magic|Fire|Cold|Elec|Acid)\s+([-]*)\|([+]*)$]], function ()
	
	if string.len(matches[3]) &gt; 0 then
		probeResult[matches[2]:lower()] = 0 - string.len(matches[3])
	elseif string.len(matches[4]) &gt; 0 then
		probeResult[matches[2]:lower()] = string.len(matches[4])
	end
	
	-- acid is the last thing probed
	if (matches[2] == 'Acid') then 
	
		killTrigger(resTrig)
		
		cecho('\n&lt;yellow&gt;PROBE: &lt;white&gt;probe has run, magic resist was: ' .. tostring(probeResult.magic) .. '\n')
		
		local dbEntry = {
		  name = fullName,
			dotName = common.dotCase(common.toMurderString(fullName)),
      magic = probeResult.magic,
    	fire = probeResult.fire,
    	cold = probeResult.cold,
    	elec = probeResult.elec,
    	acid = probeResult.acid,
			canSleep = false,
			canFear = false,
			canPara = false,
		}
		
		-- display(dbEntry)
		
		db:add(probe.db.mob, dbEntry)
		
		cecho('\n&lt;green&gt;probe db: &lt;white&gt;added ' .. dbEntry.name .. '\n')
		
		raiseEvent(probe.events.MOB_PROBED, dbEntry)

	end

end)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You take an appraising look at ([^.]*)\.+</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>set sleepable</name>
					<script>-- A yeti drops to the ground asleep.
cecho(' &lt;-- checking for sleepable')

local mobData = probe.getMobData(matches[2]:lower())

if (mobData and mobData.canSleep ~= 1) then
	mobData.canSleep = 1
	db:update(probe.db.mob, mobData)
	cecho('\n&lt;green&gt;PROBE: &lt;white&gt;mob flagged as sleepable: ' .. mobData.name ..'\n\n')
else
  if (not mobData) then
  	cecho('\n&lt;orange&gt;PROBE: &lt;white&gt;mob not in db: ' .. matches[2]:lower() ..'\n\n')
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^((An?|The) .*) drops .* asleep\.$</string>
						<string>^((A|An|The) .*) slips deeper into slumber\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>ee - what did i find?</name>
				<script>player.checkEE = true
player.eagleEye = nil

display(matches)

cecho('\n&lt;green&gt;EE:&lt;white&gt; started ee check\n')

tempPromptTrigger(function()
  player.checkEE = nil
  cecho('\n&lt;green&gt;EE:&lt;white&gt; ended ee check\n')
end, 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>3</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+++ You cast eagle eye +++</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>ee  - target</name>
				<script>-- Nothing happens.
-- 
-- +++ You cast eagle eye +++
-- 
-- Infernalist's Chamber
-- 
-- 
-- +++ You cast eagle eye +++
-- Nothing happens.
-- 
-- +++ You cast eagle eye +++
-- Your prey eludes you.
-- 
-- +++ You cast eagle eye +++
-- The spell is mysteriously blocked.


-- player.eagleEye = 

if (player.checkEE) then

  if (matches[1] == '+++ You cast eagle eye +++') then
    -- cast line, we can ignore this.
    return;
    
  elseif (matches[1] == 'Nothing happens.') then
  
    player.eagleEye = { state = "dead", location = "waiting for respawn" }
    player.checkEE = nil
  
  elseif (matches[1] == 'Your prey eludes you.') then
  
    player.eagleEye = { state = "alive", location = "eluded detection" }
    player.checkEE = nil
  
  elseif (matches[1] == 'The spell is mysteriously blocked.') then
    
    player.eagleEye = { state = "alive", location = "blocked detection" }
    player.checkEE = nil
  
  else
  
    player.eagleEye = { state = "alive", location = matches[1] }
    player.checkEE = nil

  end
  
  raiseEvent(mage.events.EAGLE_EYE, player.eagleEye)

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\S+.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>eagle eye</name>
				<script>local sucker = matches[2]
local eeType = matches[3]
local target = common.dotCase(matches[4])



common.eagleEye(target, function (eeData) 

	send('tell ' .. sucker .. ' repopped')
  
  if (eeType ~= 'ee-only') then
    local roomlist = searchRoom(eeData.location)
    
    local roomMatch = false
    
    for roomId, roomName in pairs(roomlist) do
      if (roomName == eeData.location) then
        send('tell ' .. sucker .. ' location: ' .. common.getAreaName(roomId) .. ' : #' .. tostring(roomId) .. ' ' .. roomName) 
        roomMatch = true
      end
    end
   
    if (not roomMatch) then
      send('tell ' .. sucker .. ' location: ' .. eeData.location)
    end
  end
  
end)


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) tells you[^:]*: "(ee|ee-only) (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>exit blocked</name>
				<script>local singleAttack = {
	['mists of sleep'] = true,
	['sleep'] = true
}

-- regular spell attack, queue up a couple of extras
if (player.attack_spell and not singleAttack[player.attack_spell]) then
	
	send('cast ' .. player.attack_spell .. ' ' .. common.dotCase(matches[2]))
	send('cast ' .. player.attack_spell)
	send('cast ' .. player.attack_spell)
	
else	
	
	-- sleep or mists, only cast one
	if (player.attack_spell) then
		
		local cmd = 'cast ' .. player.attack_spell
		
		-- if its mists, don't give a target
		if (player.attack_spell ~= 'mists of sleep') then
			cmd = cmd .. ' ' .. common.dotCase(matches[2])
		end
		
		send(cmd)
	
	-- regular attach		
	else	
		player.autoAttack(common.dotCase(matches[2]))
	end
	
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^An? (.*) is blocking the \w+ to the (north|east|south|west|up|down).</string>
					<string>^An? (.*) is blocking the \w+ (above|below) you\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>njs50-cleric</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>get x%</name>
				<script>-- expandAlias('ef &amp; dw')
-- 

display(matches[3])

local amt = tonumber(matches[3]) / 2

local getFull = false


if (healer.getPrepped() &lt; amt) then
	send('gt getting full')
	getFull = true
end
	
expandAlias('ef &amp; dw')
	
local pFullTrig = tempRegexTrigger([[^(.*) tells the group[^:]*: "getting full"]], function ()
	getFull = true
	send('gt me too')
end, 1)	
	
	
tempTimer(3, function () 

	killTrigger(pFullTrig)

	if (getFull) then
  
  	-- send('put all.tiny darion &amp; put all.wing darion')
  	cleric.prepFull(function () 
    	    
  		tempTimer(3, function ()
  			send('gstat ready (' .. player.name .. ')')
  			send('gstat prepped ' .. tostring(healer.getPrepped()) .. ' ' .. healer.spell )
  		end)
    		
    end)
		
	else
  	send('gstat ready (' .. player.name .. ')')
  	send('gstat prepped ' .. tostring(healer.getPrepped()) .. ' ' .. healer.spell )
  end
		
end)
	

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "prep full if less than (\d+) cure criticals"</string>
					<string>^(You) tell your group[^:]*: "prep full if less than (\d+) cure criticals"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cure blind</name>
				<script>if (group.members[matches[3]]) then
  send('cast cure blind ' .. matches[3])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) tells the group: "cb (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cure poison</name>
				<script>if (group.members[matches[3]]) then
  send('cast cure poison ' .. matches[3])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) tells the group: "cp (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>dead thing</name>
				<script>-- send('give all.armor,all.weapon,all.coin to mojune')
-- send('eat corpse')
-- send('group')

tempTimer(1, function ()
  cleric.count()
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>is DEAD!!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>summon - non consent</name>
				<script>local vic = matches[2]
send('gstat failed to summon ' .. vic .. ' due to lack of consent')


send('tell ' .. vic .. ' failed to summon due to lack of consent')

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Since (.+) does not automatically consent to your actions, the summoning fails\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>healing</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>queue cleared - sitting</name>
					<script>healer.clearQueued()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Perhaps you should stand first.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>poisoned</name>
					<script>if (not combat.active) then
	
	local target = matches[2] or 'self'
	
	local cmd = 'cast cure poison'
	
	if (matches[2]) then
		cmd = cmd .. ' ' ..target
	end
	
	send(cmd) 
  
  timedTempTrigger(5, 1, [[^(Perhaps you should stand first|You cannot do that while sleeping)\.$]], function () 
  	send('stand &amp; cast cure poison')
  end)
   
	
	timedTempTrigger(5, 1, [[^You need (\d+) energy points to cast cure poison\.$]], function () 
  	if (group.data[player.name].mp_max &lt; tonumber(matches[2])) then
			send('c ' .. target .. ' &amp; c ' .. target)
		end
		
		tempTimer(15, function () send(cmd) end)
  end) 
  
  -- in case this just woke us up. sleep again once cured...
  timedTempTrigger(0.5, 1, [[^You are suddenly awakened by the feeling of pain\.$]], function () 
  	timedTempTrigger(20, 1, [[^You are no longer poisoned\.$]], function () 
  		send('sleep')
  	end)
  end)
	
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your condition deteriorates from a poison affliction.</string>
						<string>^(\w+)'s condition deteriorates from a poison affliction.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>cp fails</name>
					<script>send('cast cure poison')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel a little better, but some poison remains in your body.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>blind</name>
					<script>murder.pause()
common.getManaAndCast(43, 'cure blindness', '', false, function ()
	murder.resume()
	send('get all corpse &amp; get all 2.corpse &amp; get all 3.corpse &amp; get all 4.corpse &amp; get all &amp; drop all.corpse')
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have been blinded!</string>
						<string>Colors swim briefly before your eyes, but you remain blind.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>confused</name>
					<script>if not player.sleepGear then
  murder.pause()
  common.getManaAndCast(48, 'neutralize', '', false, function ()
  	murder.resume()
  	send('get all corpse &amp; get all 2.corpse &amp; get all 3.corpse &amp; get all 4.corpse &amp; get all &amp; drop all.corpse')
  end)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You see colors.</string>
						<string>Things almost snap back into focus, but the colors soon return.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>count</name>
					<script>send('gstat prepped ' .. tostring(healer.getPrepped()) .. ' ' .. healer.spell )</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "count"</string>
						<string>^(An? .+?|The .+?|\w+) reports? group status: "count"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>heal group</name>
					<script>if (player.healingEnabled) then
  
  local from = matches[2]
  
  local chan = matches[3]
  
  local target = matches[4]
  
  if chan == 'tell' then
    chan = chan .. ' ' .. matches[2]
  end
  
  if chan == 'tells the group' then
    chan = 'gstat'
  end
  
  if chan == 'group status' then
    chan = 'gstat'
  end
  
  
  if (target ~= 'you' and #target &gt;= 2 and rex.match(player.name:lower(), target:lower())) then
    target = 'you'
  end
    
  if (target == 'you') then
  
    cecho('\n\nheal group\n\n')
    healer.topOffParty(function()  
      send(chan .. ' group healed') 
    end)
    
  end
  
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) (tell)s (you): "heal group"$</string>
						<string>^(.+?) reports? (group status): "(\w+) heal group"</string>
						<string>^(.+?) (tells? the group): "(\w+) heal group"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>heal group</name>
					<script>if (player.healingEnabled) then
  
  local from = matches[2]
  
  local chan = matches[3]
  
  local target = matches[4]
  
  local target2 = matches[5] or matches[4]
  
  
  if chan == 'tell' then
    chan = chan .. ' ' .. matches[2]
  end
  
  if chan == 'tells the group' then
    chan = 'gstat'
  end
  
  if chan == 'group status' then
    chan = 'gstat'
  end
  
  
  if (target ~= 'you' and #target &gt;= 2 and rex.match(player.name:lower(), target:lower())) then
    target = 'you'
  end
    
  if (target == 'you') then
  
    cecho('\n\nheal group\n\n')
    healer.topOff(target2, function()  
      send(chan .. ' ' .. target2 .. ' healed') 
    end)
    
  end
    
  
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) (tell)s (you): "top off (.+)"$</string>
						<string>^(.+?) reports? (group status): "(\w+) top off (.+)"</string>
						<string>^(.+?) (tells? the group): "(\w+) top off (.+)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>someone was bashed</name>
					<script>local vic = matches[2]

-- prob can't heal ourselves if we are bashed, let it occur naturally...
-- if (vic == 'you') then
  -- vic = player.name
-- end
send('gstat ' .. vic .. ' was bashed')

if (group.members[vic]) then
  healer.cast(vic)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>sends (.*) sprawling (on|in) the \w+!$</string>
						<string>delivers a quick kick, knocking (.*) down to the ground!$</string>
						<string>knocks (.*) head over heels!$</string>
						<string>sending (.*) sprawling!$</string>
						<string>^(.*) is knocked violently to the ground!$</string>
						<string>knocks (.*) to the \w+!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>silenced party member</name>
					<script>local vic = matches[2]

if group.members[vic] then
  common.getManaAndCast(50, 'neutralize', vic, false)  
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) reports group status: "I have been silenced"</string>
						<string>^(\w+) is still silenced!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cant cast cause gear</name>
				<script>expandAlias('st')

disableTrigger('cant cast cause gear')

tempTimer(10, function()
  enableTrigger('cant cast cause gear')
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't prepare spells while silenced.</string>
					<string>You cannot stand while holding a crystal orb of supplication.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>njs50-druid</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>spell improve path</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>x's size makes it easy for it to avoid the thick vines.</name>
					<script>tempTimer(3, function()
  send('cast undergrowth')
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>avoid the thick vines\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>autohide</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>autohide</name>
					<script>if (gmcp and gmcp.Room and gmcp.Room.Info) then
  
  local hiding = table.contains(gmcp.Char.Status.flags, 'hiding')
  local fighting = #table.keys(gmcp.Char.Fighting) &gt; 0
  local cantHide = false
  
  
  if not player.skills.hide or player.skills.hide &lt; 1 then
    cantHide = true
  end
  
  local classCanHide = {
    druid = 20,
    thief = 3,
    bard = 15,
    ranger = 10,
  }
  
  -- if any party member can't hide then don't hide
  -- if (gmcp.Group.members) then
    -- for player, details in pairs(gmcp.Group.members) do
      -- if (not classCanHide[details.class] or details.level &lt; classCanHide[details.class]) then
        -- cantHide = true
      -- end
    -- end
  -- end
  
  
  
  local noHideRooms = {
    ['170'] = true,
    ['107'] = true,
    ['5117'] = true,
    ['5113'] = true,
    ['3817'] = true,
    ['67500'] = true, -- tireth, messes with group entry/exit
    ['67502'] = true, -- tireth, messes with group entry/exit
    ['67523'] = true, -- tireth, messes with group entry/exit
    ['67524'] = true, -- tireth, messes with group entry/exit
    ['30877'] = true, -- tireth, messes with group entry/exit
    -- ['5880'] = true, -- using snakeskins for resist = no hiding
  }
  
  local noHideEnvironments = {
    River = true,
    Shallows = true
  }
  
  -- no hiding in the soup room or safe rooms
  if (gmcp.Char.Status.position ~= 'sleeping' and (noHideRooms[tostring(gmcp.Room.Info.num)] or table.contains(gmcp.Room.Info.flags, 'safe'))) then
    cantHide = true
    if (hiding) then 
      send('unhide')
    end
  end
  
  
  -- can't hide while over water
  if (noHideEnvironments[gmcp.Room.Info.environment]) then
    cantHide = true
  end
  
  -- no need to hide in safe rooms
  
  
  -- display(hiding,fighting,cantHide)
  
  local noHideItems = {
    'snakeskin bracer of elemental resistance', 
    'snakeskin bracer of elemental barring',
    'rune-inscripted snakeskin bracer',
    'ivory boots',
    'engemmed fiery red cloak',
    'cloak of flames',    
  }
  
  
  -- make sure we have checked out equip before autohide is enabled
  if (player and player.gear) then
        
    if catalog.isWearing(noHideItems) then
      cantHide = true
    end    

    if (gmcp.Char.Status.position == 'sleeping' or
        gmcp.Char.Status.position == 'wading' or
        gmcp.Char.Status.position == 'resting' or
        gmcp.Char.Status.position == 'mounted' or
        gmcp.Char.Status.position == 'swimming'
    ) then
      cantHide = true
    end
    
    if (player.unhide == true) then
      cantHide = true
    end
    
    
    if (not hiding and not fighting and not cantHide) then
      cecho('\n&lt;green&gt;AUTOHIDE:&lt;white&gt; time to hide!')
      send('hide')
      disableTrigger('autohide')
      tempTimer(1.5, function()
        enableTrigger('autohide')
      end, 'disable autohide')
    end
  
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string></string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>7</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>prevent trying to hide on login screen</name>
					<script>player.unhide = true

common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
  player.unhide = nil
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>System started</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>druid commands</name>
				<script>
local from = matches[2]

local chan = matches[3]

local target = matches[4]

local cmd = matches[5]

local args = matches[6]

if chan == 'tell' then
  chan = chan .. ' ' .. matches[2]
end

if chan == 'tells the group' then
  chan = 'gstat'
end

if chan == 'group status' then
  chan = 'gstat'
end

local commands = {

  ["help"] = function ()
    druid.help(chan)
  end,

  ["config"] = function ()
    druid.showConfig(chan)
  end,  
      
  ["assist"] = function (params)
    druid.assist.set(params, 'assist', chan)
  end,

  ["adds"] = function (params)
    druid.assist.set(params, 'adds', chan)
  end,

  ["aoe"] = function (params)
    druid.assist.set(params, 'aoe', chan)
  end,
  
  ["aoe-threshold"] = function (params)
    druid.assist.setAoeThreshold(params, chan)
  end,  

  ["nasty"] = function (params)
    druid.assist.set(params, 'nasty', chan)
  end,
  
  ["mode"] = function (params)
    druid.assist.setMode(params, chan)
  end,  
  
  ["add-mode"] = function (params)
    druid.assist.setAddMode(params, chan)
  end,  
  
  ["prep"] = function(params)
    druid.setStormPrep(params, chan)
  end,
  
  ["min-prepped"] = function(params)
    druid.setStormMinPrepped(params, chan)
  end,

}


if (target ~= 'you' and #target &gt;= 2 and rex.match(player.name:lower(), target:lower())) then
  target = 'you'
end


if (target == 'you') then

  if commands[cmd] then
  
    commands[cmd](args)
 
  end
  
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) (tell)s (you): "([A-Za-z\-]+) ?(.*)"$</string>
					<string>^(.+?) reports? (group status): "(\w+) ([A-Za-z\-]+) ?(.*)"</string>
					<string>^(.+?) (tells? the group): "(\w+) ([A-Za-z\-]+) ?(.*)"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>drink from puddles</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A small puddle containing a clear liquid seems to bubble up from the ground.</string>
					<string>A large puddle containing a clear liquid seems to bubble up from the ground.</string>
					<string>A very large puddle containing a clear liquid seems to bubble up from the ground.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>khiren - hidden</name>
				<script>expandAlias('unhide')
send('yell khiren')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>seeing no one, he retreats back to his forge.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>landbinding failed</name>
				<script>tfe = tfe or {}
tfe.supressNextRoomChange = true
send('queue cast landwalk &amp; cast landbinding')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Your skill as a landbinder fails you...</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>landbinding</name>
				<script>send('cast landbinding')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Nothing found matching "nexus".</string>
					<string>^You can see the \w+ \w+, but the \w+\.\.\.  bends\.\.\. </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>respell</name>
				<script>expandAlias('respell gstat')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* reports? group status[^:]*:\s+"respell"$</string>
					<string>^.* tells? the group[^:]*:\s+"respell"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>darklight</name>
				<script>cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; recasting darklight\n\n')
send('look darkl')
common.getManaAndCast(50, 'darklight', '', true)


-- You can no longer sense your surroundings without light.</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Nothing found matching "darklight".</string>
					<string>Your darklight's energy is beginning to fade.</string>
					<string>Your darklight is about to fade.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>darkflies</name>
				<script>cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; recasting darkflies\n\n')
send('look darkl')
common.getManaAndCast(25, 'darkflies', '', true)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Nothing found matching "obst dark".</string>
					<string>Your swarm of darkflies dims in an almost indiscernible way.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>refresh darkflies</name>
				<script>if (matches[2] ~= 'tremendous') then
  cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; recasting darkflies\n\n')
  common.getManaAndCast(25, 'darkflies', '', true)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>They provide a (.*) amount of darkness\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>hide failed</name>
				<script>send('hide')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You fail to step into the shadows.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>leveling</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>landbinding</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>infinite nexus</name>
						<script>send('enter nexus')</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You bind the entrance to .* and enter\.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>imp landbinding</name>
						<script>cecho('\n&lt;green&gt;IMPS:&lt;white&gt; queued landbind/walk etc\n\n')

local spell = 'cast landbinding &amp; cast landwalk &amp; enter nexus'

if (player.skills.landbinding &lt; 10 and not table.contains(improves.castQueue, spell)) then
  improves.queueSpell(spell)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your skill as a landbinder fails you...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>bandage fail</name>
					<script>expandAlias('imp-bandage')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You try to bandage your own wounds but just make the situation worse.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>snack break</name>
					<script>local vessel = player.vessel or 'leather.waterskin'

send('drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; queue give empty.' .. vessel .. ' ' .. group.leader)
send('gstat snack me')
send('eat food &amp; eat food &amp; eat food &amp; eat food')
send('drop all.food &amp; get 4*food')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports group status[^:]*:\s+"snack break"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>get full</name>
					<script>player.gettingFull = player.gettingFull or false

if (not player.gettingFull) then
	player.gettingFull = true
  send('ef &amp; dw &amp; dismount')

  tempTimer(2, function ()
  	send('sit couch &amp; sit chair &amp; sit pad &amp; sit boulder')
  	expandAlias('sl')
  	common.onFull( function ()
			expandAlias('st')
      send('mount')
    	-- expandAlias('give all.coin batso &amp; drop all.food &amp; get 2*food')

  		tempTimer(3, function ()
				player.gettingFull = false
  			expandAlias('gstat ready (' .. player.name .. ')')
  		end)

    end)
  end)

else
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* reports group status[^:]*: "(pfull|get full)"</string>
						<string>^.* tells? (?:your|the) group[^:]*: "(pfull|get full)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>druid - healing</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>heal casting</name>
					<script>druid.healCastStart()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You begin casting healing rain.</string>
						<string>You begin casting healing mist.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>heal cast</name>
					<script>druid.healStarted()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>+++ You cast healing rain +++</string>
						<string>+++ You cast healing mist +++</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>heal finished</name>
					<script>druid.healEnded()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The healing mists evaporate.</string>
						<string>The healing rains disperse.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>storm interrupted</name>
					<script>druid.healInterrupted()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&gt;&gt; Your healing (rain|mist) casting is disrupted\. &lt;&lt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>in combat fail</name>
					<script>druid.healCombatFail()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You cannot cast (healing rain|healing mist) while fighting\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>druid healing command</name>
					<script>if (player.healingEnabled) then
  
  local from = matches[2]
  
  local chan = matches[3]
  
  local target = matches[4]
  
  if chan == 'tell' then
    chan = chan .. ' ' .. matches[2]
  end
  
  if chan == 'tells the group' then
    chan = 'gstat'
  end
  
  if chan == 'group status' then
    chan = 'gstat'
  end
  
  
  if (target ~= 'you' and #target &gt;= 2 and rex.match(player.name:lower(), target:lower())) then
    target = 'you'
  end
    
  if (target == 'you') then
  
    cecho('\n\nheal group\n\n')
    druid.healGroup({
      skipAmount = druid.skipHealAmount or 300,
      callback = function()  
        send(chan .. ' group healed') 
      end
    })
    
  end
  
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) (tell)s (you): "heal group"$</string>
						<string>^(.+?) reports? (group status): "(\w+) heal group"</string>
						<string>^(.+?) (tells? the group): "(\w+) heal group"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>blind</name>
					<script>murder.pause()
common.getManaAndCast(43, 'cure blindness', '', false, function ()
	murder.resume()
	send('get all corpse &amp; get all 2.corpse &amp; get all 3.corpse &amp; get all 4.corpse &amp; get all &amp; drop all.corpse')
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have been blinded!</string>
						<string>Colors swim briefly before your eyes, but you remain blind.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>druid - storm</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>storm ended</name>
					<script>-- cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm ended\n')

if (player.stormEnabled) then

  player.ss.storm_active = nil
  cecho('&lt;green&gt; &lt;-- &lt;white&gt;ss end')
  -- display(gmcp.Char)
  
  
  -- start a new storm if we are still in combat
  -- if end of combat is pending then check again in 1.1 seconds
  if (combat.finishPending) then
    tempTimer(1.1, function()
      if (combat.active and not player.stormSkipRecast) then
        player.ss.cast(cancelQueue)
      else
        raiseEvent(player.ss.events.STORM_ENDED)
      end
    end)
  else
    if (combat.active and not player.stormSkipRecast) then
      player.ss.cast(cancelQueue)
    else
      raiseEvent(player.ss.events.STORM_ENDED)
    end
  end
  
 end
 </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The rolling black clouds fade to grey and dissipate</string>
						<string>The black and grey funnel clouds disappear like mist</string>
						<string>The heavy grey clouds of the blizzard melt away into the air</string>
						<string>The strange storm dissipates as quickly as it appeared</string>
						<string>The small squall dissipates as quickly as it appeared</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>casting storm</name>
					<script>if (player.stormEnabled) then
  
  player.ss.casting = true
  -- player.ss.storm_active = false
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss casting')
  
 end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You begin casting (tempest|tornado|blizzard|storm|squall)\.</string>
						<string>^\[ Queued \d+:\s+(queue\s*)?cast (tempest|tornado|blizzard|storm|squall)\s+\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>cast storm</name>
					<script>if (player.stormEnabled) then
  
  player.ss.casting = false
  player.ss.storm_active = true
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss cast')
 
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\+\+\+ You cast (tempest|tornado|blizzard|storm|squall) \+\+\+</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>storm interrupted</name>
					<script>local target = matches[2]

if (player.stormEnabled) then
  
  player.ss.casting = false
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss disrupt')
  player.ss.cast()
  
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&gt;&gt; Your (tempest|tornado|blizzard|storm|squall) casting is disrupted\. &lt;&lt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>not standing while trying to cast storm</name>
					<script>local target = matches[2]

if (player.stormEnabled and player.ss.casting) then
  
  player.ss.casting = false
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss just stood up (queuing recast)')
  player.ss.cast()
  
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You quickly jump to your feet.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>storm prep interrupted</name>
					<script>-- &gt;&gt; Your tempest preparation is disrupted. &lt;&lt;
local target = matches[2]

common.onClear(function()
  send('prepare ' .. target)
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&gt;&gt; Your (tempest|tornado|blizzard|storm|squall) preparation is disrupted\. &lt;&lt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>druid assist</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>delayed attack in current room</name>
					<script>local from = matches[2]
local at = matches[3]

if (from == 'You') then 
  from = gmcp.Char.Score.name
end

if from == gmcp.Group.leader then
  druid.assist.delayedAttack(at)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#d6ee14</mFgColor>
					<mBgColor>#005bff</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) reports? group status: "attack at (\d+\.?\d*)"</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>augments</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>augmented item</name>
					<script>
-- You are not experienced enough to augment a singular crimson armlet.
-- An elongated slarg rib is absorbed into the ivy...
-- You hold a shimmering slarg silk cloak in your hands.
-- You hold a singular copper-inset singular crimson armlet in your hands.
if (druid and druid.aug and druid.aug.item) then
  druid.aug.createdItem = common.dotCase(common.itemSanitize(matches[4]))
end
  -- display(druid.aug)


-- augment failed...
-- A zinc ingot is absorbed into the vines...
-- The vines begins to constrict a roll of medicated tape, but then receeds, leaving it as it was.
-- The ivy begins to constrict a glass-scale anklet, but then receeds, leaving it as it was.</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You) (create) (.*)\.$</string>
						<string>^(You) (hold) (.*) in your hands\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>cart tell</name>
					<script>druid.aug = druid.aug or {}


if (gmcp.Room.Info.num ~= druid.augRoom) then
  send('tell ' .. matches[2] .. ' I am not currently in the designated aug bot waiting room')
  return
end


if not druid.aug.pending then
  
  druid.aug = {
    vic = matches[2],
    pending = true
  }
  
  druid.aug.fuckedOutTimer = tempTimer(60, function()
    
    druid.landwalk(function()
      tfe.gotoRoom(druid.augRoom, function()
        druid.aug.pending  = false
        send('tell ' .. druid.aug.vic .. ' something went horribly wrong, you might need to try that again')
        send('drop cart')
      end)
    end)
    
  end, 'augment broke')
  
  send('tell ' .. druid.aug.vic .. ' your cart will be dumped in the soup room shortly!')
  
  druid.landwalk(function()
    tfe.gotoRoom(82220, function()
      send('get cart')
      druid.landwalk(function()
        tfe.gotoRoom(druid.augRoom, function()
          send('drop all.decr.cart')
          send('tell ' .. druid.aug.vic .. ' your cart has been delivered!')
          druid.aug.pending = false
          killTimer(druid.aug.fuckedOutTimer)
        end)
      end)
    end)
  end)
  
  
else

  send('tell ' .. matches[2] .. ' I currently have an augment queued for ' .. druid.aug.vic .. ' . try again later...')

end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"cart"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>augment tell</name>
					<script>druid.aug = druid.aug or {}


-- Nothing found matching "vine".

if (not player.skills['vine armor'] or player.skills['vine armor'] == 0) then
  send('tell ' .. matches[2] .. ' I am not qualified to augment items')
  return
end


if (gmcp.Room.Info.num ~= druid.augRoom) then
  send('tell ' .. matches[2] .. ' I am not currently in the designated aug bot waiting room')
  return
end


if (matches[3] == 'ivy' or matches[3] == 'vine') then
  
  if not druid.aug.pending then
    
    druid.aug = {
      vic = matches[2],
      spell = matches[3],
      terrain = matches[4]:lower(),
      item = matches[5],
      pending = true
    }
    
    druid.aug.fuckedOutTimer = tempTimer(60, function()
      
      tfe.gotoRoom(druid.augRoom, function()
        druid.aug.pending  = false
        send('tell ' .. druid.aug.vic .. ' something went horribly wrong, you might need to try that again')
        send('give ' .. druid.aug.item .. ' ' .. druid.aug.vic)
      end)
      
    end, 'augment broke')
    
    send('tell ' .. druid.aug.vic .. ' your augment is queued, don\'t leave the soup room or i\'ll keep your shit!')
    
    druid.augment(druid.aug.spell, druid.aug.terrain, druid.aug.item, function()
      send('unhide &amp; tell ' .. druid.aug.vic .. ' augment done!')
      druid.aug.pending = false
      killTimer(druid.aug.fuckedOutTimer)
      send('give ' .. (druid.aug.createdItem or druid.aug.item) .. ' ' .. druid.aug.vic) 
    end, function(msg)
      send('unhide &amp; tell ' .. druid.aug.vic .. ' augment failed! ' .. msg)
      send('give ' .. druid.aug.item .. ' ' .. druid.aug.vic) 
      send('tell ' .. matches[2] .. ' tell me "return &lt;item&gt;" if you fucked it up and want something back')
      druid.aug.pending = false
      killTimer(druid.aug.fuckedOutTimer)
    end)
    
    
  else
  
    send('tell ' .. matches[2] .. ' I currently have an augment queued for ' .. druid.aug.vic .. ' . try again later...')
  
  end
  
else

  send('tell ' .. matches[2] .. ' tell me "aug &lt;vine|ivy&gt; &lt;terrain&gt; &lt;item&gt;" after you\'ve given me the goods')
  send('tell ' .. matches[2] .. ' tell me "return &lt;item&gt;" if you fucked it up and want something back')

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"aug (vine|ivy) (jungle|beach|cave|forest|bamboo|tundra|desert|hills|field|swamp|mountain) (.*)"$</string>
						<string>^([A-Za-z]+) tells you:\s*"aug"$</string>
						<string>^([A-Za-z]+) tells you:\s*"aug\s(.*)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>aug fucks out</name>
					<script>-- The vines begins to constrict a roll of medicated tape, but then receeds, leaving it as it was.
-- The ivy begins to constrict a glass-scale anklet, but then receeds, leaving it as it was.

-- The ivy will not grow around a pair of gloves of deftness, and it recedes from it.

if (druid and druid.aug and druid.aug.item) then
  
  druid.aug.createdItem = common.dotCase(common.itemSanitize(matches[3]))
  
  if (matches[4] == 'leaving it') then
    send('tell ' .. druid.aug.vic .. ' looks like your reagent was consumed :-[')
  end
  
  if (matches[3] == 'recedes from it') then
    send('tell ' .. druid.aug.vic .. ' looks like your recipe was fucked. sometimes it needs vine instead of ivy armor')
  end
  
  send('tell ' .. druid.aug.vic .. ' ' .. matches[1])

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^The (vines|ivy) begins to constrict (.*), but then receeds, (leaving it) as it was\.</string>
						<string>^The ivy will not grow around (.*), and it (recedes from it).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>aug missing reagent</name>
					<script>if (druid and druid.aug and druid.aug.item) then

  send('tell ' .. druid.aug.vic .. ' ' .. matches[1])

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your druidic senses feel that something is missing...  (.*).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Nothing found matching "gem bright".</name>
					<script>if (druid and druid.aug and druid.aug.item) then
  
  local target = rex.gsub(druid.aug.item, [[\.]], " ")
  
  if matches[2] == target then
    send('tell ' .. druid.aug.vic .. ' looks like you told me to augment something i don\'t have')
    send('tell ' .. druid.aug.vic .. ' ' .. matches[1])
    send('tell ' .. druid.aug.vic .. ' sit in the naughty corner until i return')
  end

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Nothing found matching "(.*)"\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>make a living shield</name>
					<script>local vic = matches[2]

if player.skills['living shield'] &gt;= 10 then
  
  equipPartial('make-shields', function()
  
    njs50.cast('living shield', {
      callback = function()
        send('give vine-covered.shield ' .. vic)
        resetGear()
      end,
      failCallback = function(msg)
        send('tell ' .. vic .. ' failed due to reason:')
        send('tell ' .. vic .. ' ' .. msg)
        resetGear()
      end,
    })
  
  end)
  
else
 
  send('tell ' .. vic .. ' not qualified to make living shields')

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"living shield"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>cast thorn shield</name>
					<script>local vic = matches[2]
local spell = matches[3]

local spells = {
  ['thorn shield'] = true,
  ['embrace of earth'] = true,
  ['protection plants'] = true,
  ['water breathing'] = true,  
}

if not spells[spell] then  
  return
end


if player.skills[spell] &gt;= 10 then

  njs50.cast(spell, {
    target = vic,
    callback = function()
      send('tell ' .. vic .. ' successfully cast ' .. spell)
    end,
    failCallback = function(msg)
      send('tell ' .. vic .. ' failed due to reason:')
      send('tell ' .. vic .. ' ' .. msg)
      resetGear()
    end,
  })
  
else
 
  send('tell ' .. vic .. ' not qualified to cast ' .. spell)

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"(thorn shield|embrace of earth|protection plants|water breathing)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>cast corrosive weapon</name>
					<script>local vic = matches[2]
local target = matches[3]

if player.skills['corrosive weapon'] &gt;= 10 then

  njs50.cast('corrosive weapon', {
    target = target,
    callback = function()
      send('give ' .. target .. ' ' .. vic)
    end,
    failCallback = function(msg)
      send('tell ' .. vic .. ' corrosive weapon failed due to reason:')
      send('tell ' .. vic .. ' ' .. msg)
      send('give ' .. target .. ' ' .. vic)
      resetGear()
    end,
  })
  
else
 
  send('tell ' .. vic .. ' not qualified to cast corrosive weapon')

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"cw (.+)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>return item</name>
					<script>if (gmcp.Room.Info.num ~= druid.augRoom) then
  send('tell ' .. matches[2] .. ' I am not currently in the designated aug bot waiting room')
  return
end

local vic = matches[2]
local target = matches[3]

send('give ' .. target .. ' ' .. vic)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you:\s*"return (.+)"$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>dead thing - report juice</name>
				<script>-- send('skin corpse &amp; eat corpse &amp; get all &amp; drop all.corpse')
-- send('eat corpse')
-- send('get all 1.corpse &amp; get all 2.corpse &amp; get all 3.corpse &amp; get all &amp; drop all.corpse')

druid.reportMana()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive \d+ experience points.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>xerotes</name>
				<script>gmcp.Room.Info.wind = 'storm'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+++ You cast xerotes +++</string>
					<string>^\w+ casts xerotes\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>time check</name>
				<script>local chan = matches[3]

if chan == 'tell' then
  chan = chan .. ' ' .. matches[2]
end

if chan == 'tells the group' then
  chan = 'gt'
end

if chan == 'group status' then
  chan = 'gstat'
end

if chan == 'clan status' then
  chan = 'cstat'
end



local sleepTrig = tempRegexTrigger([[^You cannot do that while sleeping\.$]], function()
  send('stand &amp; observe &amp; sleep')
end, 1)

tempRegexTrigger([[^=\s+(\S.*?)\s+\|\s*(\S.*?)\s*=]], function()
  display(matches[2], matches[3])
  send(chan .. ' it is ' .. matches[3] .. ' on ' .. matches[2])
  killTrigger(sleepTrig)
end,1)
send('observe')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) reports? (clan status): "time"$</string>
					<string>^(.*) (tell)s you: "time"$</string>
					<string>^(.*) reports? (group status): "time"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cant use while hiding</name>
				<script>-- You can't use 2 snakeskin bracers of elemental resistance while hiding.

expandAlias('unhide')
resetGear()

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You can't use .* while hiding\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cast time</name>
				<script>local startTime = getEpoch()
timedTempTrigger(5, 1, [[^\+\+\+ You cast ]] .. matches[2] .. [[ \+\+\+]], function()
  local castTime = math.floor((getEpoch() - startTime) * 1000)
  cecho('&lt;green&gt; &lt;-- cast took ' .. tostring(castTime) .. 'ms')
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You begin casting (.+)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>joined group</name>
				<script>druid.assist.reset()
druid.helpShort('gt')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You join (\w+)'s group.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You cannot cast healing rain while fighting.</name>
				<script>local spell = 'healing ' .. matches[2]

common.onNextEvent(common.events.COMBAT_ENDED, function()
  send('cast ' .. spell)
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You cannot cast healing (mist|rain) while fighting. \$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>njs50-warrior</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>charge -&gt; fall down</name>
				<script>-- You attempt to charge a mountain bear, but miss and fall down.

local vic = common.dotCase(common.toMurderString(matches[2]))

send('|stand &amp; |opt parry &amp; |charge ' .. vic .. ' &amp; |opt parry')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00f600</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You attempt to charge (.*), but miss and fall down\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>njs50-legate</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>charge -&gt; fall down</name>
				<script>-- You attempt to charge a mountain bear, but miss and fall down.

local vic = common.dotCase(common.toMurderString(matches[2]))

send('|stand &amp; |opt parry &amp; |charge ' .. vic .. ' &amp; |opt parry')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00f600</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You attempt to charge (.*), but miss and fall down\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>njs50-reaver</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>recast entropic orb</name>
				<script>send('perform rite of illumination')
send('|perform rite of delumination')
send('|perform rite of marking')
send('|perform rite of envisioning')
send('|scan')

disableTrigger('recast entropic orb')

tempTimer(10, function()
  enableTrigger('recast entropic orb')
end, 'debounce light recast')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Nothing found matching "entr orb".</string>
					<string>^\s+\[Here\] : darkness$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Your entropic orb flickers.</name>
				<script>
if (player.skills['rite of delumination'] and player.skills['rite of delumination'] &gt; 0) then
  send('perform rite of delumination')
else
  send('perform rite of illumination')
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Your entropic orb flickers.</string>
					<string>Your entropic orb is fading.</string>
					<string>Your entropic orb dims slightly.</string>
					<string>Your entropic orb shimmers slightly.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>events</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>begin casting</name>
				<script>-- You begin casting gale.
-- ...
      -- A female kobold is DEAD!!           
raiseEvent(common.events.CAST_STARTED, matches[2])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You begin casting (.+)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>mob joined combat</name>
				<script>local mob = matches[2]
local mobTarget = matches[3] or gmcp.Char.Score.name

-- combat.mobs++
if (matches[3] == '' or matches[3] == 'you') then
  mobTarget = gmcp.Char.Score.name
end

-- dont trigger on mob changing target
-- A black rabbit stops attacking Darion and leaps to attack you!
if not rex.match(mob, [[stops attacking \w+ and]]) then
  
  mob = string.lower(mob):gsub(' ','.')
  
  if (not group.members[mob] and group.members[mobTarget]) then  
    -- raiseEvent(common.events.MOB_JOINED_COMBAT, mob)
    combat.mobJoined(mob) -- event now raised here so stats will be correct!
  end
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) leaps to attack (.*)!$</string>
					<string>^(.*) counterattacks (.*)!$</string>
					<string>^(.*) says \(in primal\): "Have at you, then!"$</string>
					<string>^(.*) says \(in primal\): "Please....please...h-help me..."$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>mob arrived in room</name>
				<script>-- A cult guardsman arrives from below.
-- A cult guardsman arrives from the west.
-- A minotaur guardian charges in from the south.

-- An aqua-goblin legionnaire swims in from the east.
-- .* tramps in from the (north|east|south|west)\.$

local mob = matches[2]

if (not group.members[mob]) then  

  mob = string.lower(mob):gsub(' ','.')
  
  -- raiseEvent(common.events.MOB_ENTERED_ROOM, mob)
  combat.mobJoinPending(mob) -- event now raised here to ensure correct stats
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Z].*) (?:arrives|\w+ in) from (?:the )?(north|east|south|west|above|below)\.$</string>
					<string>^([A-Z].*) (?:arrives) via the (.*)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>mob wandered away</name>
				<script>-- A Medienne guard marches west.
-- A fragile, ancient sage leaves west.
-- A citizen walks west.

-- not:
-- A cult guardsman arrives from the west.

local mob = matches[2]

-- dont trigger on mob arriving
-- A cult guardsman arrives from the west.

if not rex.match(mob, [[from]]) then
  if (not group.members[mob]) then  
    mob = string.lower(mob):gsub(' ','.')
    -- raiseEvent(common.events.MOB_ENTERED_ROOM, mob)
    combat.mobJoinNotPending(mob) -- event now raised here to ensure correct stats
  end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Z].*) (?:leaves|\w+) (north|east|south|west|above|below)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>mob left combat</name>
				<script>-- combat.mobs--
if (not group.members[matches[2]]) then  
  local mob = string.lower(matches[2]):gsub(' ','.')
  -- raiseEvent(common.events.MOB_LEFT_COMBAT, mob)
  combat.mobLeft(mob) -- event now raised from here to ensure stats are correct
end

-- A yeti stops attacking Darion.</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(.*) is DEAD!!$</string>
					<string>^(.*) blindly flees (north|east|south|west|up|down).</string>
					<string>^(.*) vanishes in the blink of an eye!</string>
					<string>^(.*) stops attacking (\w+)\.$</string>
					<string>^(.*) drops .* asleep\.</string>
					<string>^(.*) darts up into the air, disappearing from sight!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>mob changed</name>
				<script>local mob_from = matches[2]
local mob_to = matches[3]

mob_from = string.lower(mob_from):gsub(' ','.')
combat.mobLeft(mob_from) -- event now raised from here to ensure stats are correct

mob_to = string.lower(mob_to):gsub(' ','.')
combat.mobJoined(mob_to) -- event now raised here so stats will be correct!
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(A large black cat-like beast) becomes (a huge black cat-like beast)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>assist changed</name>
				<script>
raiseEvent(common.events.ASSIST_SET, matches[2])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You will auto.assist with (.*)\.</string>
					<string>^Your auto.assist skill has been set to (none)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>exit blocked</name>
				<script>-- A cult guardsman arrives from below.
-- A cult guardsman arrives from the west.
-- A minotaur guardian charges in from the south.

-- An aqua-goblin legionnaire swims in from the east.
-- .* tramps in from the (north|east|south|west)\.$

local mob = matches[2]

local direction = matches[3]

local dirConvert = {
  above = 'up',
  below = 'down',
}

if dirConvert[direction] then
  direction = dirConvert[direction]
end

mob = string.lower(mob):gsub(' ','.')

-- raiseEvent(common.events.MOB_ENTERED_ROOM, mob)
combat.mobBlockedExit(mob, direction) -- event now raised here to ensure correct stats

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) is blocking the \w+ to the (north|east|south|west|up|down)\.$</string>
					<string>^(.*) is blocking the \w+ (above|below) you\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>reformat opt</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>optionsCapture</name>
				<script>    _optionsType = matches[2] -- set up multiple triggers for different types of options categories maybe?
    _optionsDisplay = {}
    _optionsWhichLine = 0</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>3</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(General Options)\s*$</string>
					<string>^\s+(Channel Options)\s*$</string>
					<string>^\s+(Info Levels)\s*$</string>
					<string>^\s+(Noteboard Levels)\s*$</string>
					<string>^\s+(Message)\s*$</string>
					<string>^\s+(Message Levels)\s*$</string>
					<string>^\s+(Option Levels)\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>opt formatted</name>
					<script>setTriggerStayOpen("optionsCapture",1) -- parent remains open for 1 line

 deleteLine() -- shut it the hell up
 
if matches[1] == '\n' then
  -- cecho('&lt;green&gt; &lt;-- end\n')
  setTriggerStayOpen("optionsCapture",0)
  
  -- output the table
  local keys = table.keys(_optionsDisplay) -- get the options
  table.sort(keys) -- alphabetize them
  local thisLine = {} -- set up holder table for a given line
  for _,key in pairs(keys) do
      thisLine[#thisLine + 1] = string.format("% -16s (%s)",key,_optionsDisplay[key]) --spacing lines up nicely with 4 per row
      if (#thisLine == 4) then -- how many entries per line
          echo("\n"..table.concat(thisLine," ")) -- echo w/ leading carriage return and combine the table into a string
          thisLine = {} -- re-wipe this line
      end
  end  
  echo('\n\n')
  
else  
  resetFormat()
  local text = matches[1]
  for param,value in string.gmatch(text,"(%a+.%a+) %((.)%)") do -- capture sets of options
      _optionsDisplay[param] = value
  end
 
end





                                    -- -- Message 
                                    -- -- ------- 
       -- Bleeding (*)    Damage.Mobs (*) Damage.Players (*)       Door.Dir (*)      Followers (*)     
-- Hungry (*)     Item.Lists (*)     Long.Names (*)     Max.Energy (*)        Max.Hit (*)       
-- Max.Move ( )         Misses (*)          Queue (*)  Spell.Counter (*)        Thirsty (*)
        -- Weather (*)
-- 
                                 -- Message Levels
                                 -- ------- ------
          -- Banks (3)      Equipment (3)      Inventory (3)           Look (3)        Prepare (3)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.+\w+\.?\w* \(.\).*$</string>
						<string>^\s*$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>check who is online (grants bitches to clannies)</name>
			<script>send('who')</script>
			<command></command>
			<packageName></packageName>
			<time>00:15:00.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>dont' time out!</name>
			<script>-- send('\n', false)
sendSocket(string.char(255,241))</script>
			<command></command>
			<packageName></packageName>
			<time>00:03:00.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>stay hydrated</name>
			<script>-- setRoomUserData(gmcp.Room.Info.num, 'drink-target', 'fountain')

if (gmcp and gmcp.Room) then

  local target = getRoomUserData(gmcp.Room.Info.num, 'drink-target')
  
  if (target ~= '') then
    send('drink ' .. target)
  end

end</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:15.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>map backup</name>
			<script>mapper = mapper or {}
mapper.backupVersion = mapper.backupVersion or 0
mapper.backupVersion = (mapper.backupVersion + 1) % 5

local fileName = getMudletHomeDir() .. "/map/backup" .. mapper.backupVersion .. ".dat"
saveMap(fileName)
echo("Map has been saved as " .. fileName)</script>
			<command></command>
			<packageName></packageName>
			<time>00:10:00.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>xp</name>
			<script>-- run this every so often to clear out data older than 1hr

expandAlias('xp')</script>
			<command></command>
			<packageName></packageName>
			<time>00:20:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>check last kill time and alert</name>
			<script>local alertPeriod = 300

if (murder.lastKillTime and murder.enabled) then

  local lk = getEpoch() - murder.lastKillTime
  local msg = 'Last mob was killed ' .. common.formatElapsedTime(lk) .. ' ago'

  if (lk &gt; alertPeriod) then
    common.sendSlack(msg)
    cecho('\n&lt;red&gt;MURDER&lt;white&gt;: ' .. msg .. '\n')
  end

end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:30.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>kick/swim while no improve casts queued</name>
			<script>local cmd = '|kick stand &amp; |dive pool &amp; |climb chain'
-- local cmd = 'climb chain &amp; climb chain &amp; climb chain'
if (#improves.castQueue == 0) then
  send(cmd)
else
  
  if (improves.castFillerLastTick ~= false) then
    improves.castFillerLastTick = false
    tempTimer(65, function()
      send('+')      
      improves.castSpell()
      send('wait 3')
    end, 'casting buff delay')
  end
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.500</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>kick/swim while no improve casts queued w/smoking</name>
			<script>-- local cmd = 'queue dive pool &amp; queue climb chain' --  &amp; kick stand
local cmd = 'climb chain &amp; climb chain &amp; climb chain'
if (#improves.castQueue == 0) then
  send(cmd)
else
  
  if (improves.castFillerLastTick ~= false) then
    improves.castFillerLastTick = false
    tempTimer(65, function()     
      send('+') 
      murder.smokeUp('imps-no-wis','imps-regen', 22, function()
        improves.castSpell()
        send('wait 3')
      end)
    end, 'casting buff delay')
  end
  
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.100</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>respell improves</name>
			<script>cecho('\n\nchecking buffs!\n\n')
njs50.respell(player.buffs, {queueSpellImprove = true})</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>get pracs w imps + tob</name>
			<script>local cmd = 'climb chain &amp; climb chain &amp; climb chain'

local pracLimit = 450



murder.checkNum = ((murder.checkNum or 0) + 1) % 10

if murder.checkNum == 0 then
  disableTimer('get pracs w imps')
  murder.checkPracs(function(pracs)

    if (pracs &gt; pracLimit) then
      cecho('\n\ntoo many pracs!\n\n')
      -- send('cstat got enough prac points, quitting for now...')
      -- send('quit')
  
      return
    else  
      enableTimer('get pracs w imps')
      cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
    end
  
  end)
  
else

  if (#improves.castQueue == 0) then
    send(cmd)
  else
    
    if (improves.castFillerLastTick ~= false) then
      improves.castFillerLastTick = false
      tempTimer(65, function()     
        send('+') 
        murder.smokeUp('imps-no-wis','imps-regen', 22, function()
          improves.castSpell()
          send('wait 3')
        end)
      end, 'casting buff delay')
    end
  end
  
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve spells w/ non combat improve filler</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

improves.setFiller(player.improveNonCombat)

-- send('stand')
improves.castSpell(function()
  send('|drink trough &amp; |drink kettle &amp; |drink cauld')
  -- send('|sit couch &amp; |sleep')
end, function()
  disableTimer('improve spells w/ non combat improve filler')
  -- send('|stand')
  enableTimer('get pracs')
end)

improves.resetFiller()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:31.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve spells w/ non combat improve filler + tobacco</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

improves.setFiller(player.improveNonCombat)

-- send('stand')

murder.smokeUp('imps-no-wis','imps', 22, function()
  improves.castSpell(function()
    -- send('|drink trough &amp; |drink kettle &amp; |drink cauld &amp; |sit couch')
    -- send('|sleep')    
    improves.resetFiller()
  end, function()
    disableTimer('improve spells w/ non combat improve filler + tobacco')
    -- send('|stand')
    enableTimer('get pracs w/tobacco')
  end)
end)
    

</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:31.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>cast improve spell w/tobacco for buffs</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')
improves.setFiller(player.improveNonCombat)

send('stand')

if (#improves.castQueue &gt; 0) then

  if (improves.castFillerLastTick) then
    
    improves.castSpell()
  
  else

    murder.smokeUp('imps-no-wis','imps-regen', 22, function()
      local message = '[improves] : ' .. improves.castQueue[1]
      common.consoleMessage('Log', message, 'green', true)
      improves.castSpell() 
    end)
    
  end
  
else
  improves.castSpell(function()
    send('|drink cauldron')
    send('|sit couch &amp; |sleep')
  end)
end







improves.resetFiller()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:31.100</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve ticker</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

-- send('stand &amp; drink cauld &amp; inventory')
improves.castSpell()
-- send('queue sit couch &amp; queue sleep')lua </script>
			<command></command>
			<packageName></packageName>
			<time>00:00:45.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>get pracs</name>
			<script>-- local cmd = 'kick stand &amp; kick stand &amp; kick stand &amp; kick stand'
-- local cmd = 'kick stand &amp; punch bag &amp; kick stand &amp; punch bag'
local cmd = 'kick stand &amp; punch bag &amp; |dive pool &amp; climb chain'
-- local cmd = '|dive pool &amp; |climb chain &amp; |climb chain'

murder.checkNum = ((murder.checkNum or 0) + 1) % 20

if murder.checkNum == 0 then
  disableTimer('get pracs')
  murder.checkPracs(function(pracs)
  
  
  
    if (pracs &gt;= 500) then
      cecho('\n\ntoo many pracs!\n\n')
      -- send('cstat got enough prac points, quitting for now...')
      -- send('quit')

      return
    else  
      enableTimer('get pracs')
      cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
    end
  
  end)
else
  send(cmd)
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.100</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>get pracs w/tobacco</name>
			<script>local cmd = 'kick stand &amp; punch bag &amp; kick stand &amp; punch bag'
-- local cmd = 'kick stand &amp; kick stand &amp; kick stand &amp; kick stand'
-- local cmd = '|dive pool &amp; |climb chain &amp; kick stand &amp; punch bag'
-- local cmd = '|dive pool &amp; |climb chain &amp; |climb chain &amp; |climb chain'

murder.checkNum = ((murder.checkNum or 0) + 1) % 25

if murder.checkNum == 0 then
  disableTimer('get pracs w/tobacco')
  murder.checkPracs(function(pracs)
  

    if (pracs &gt; 300) then
      cecho('\n\ntoo many pracs!\n\n')
      -- send('cstat got enough prac points, quitting for now...')
      -- send('quit')
      enableTimer('get pracs')

      return
    else  
      
      murder.smokeUp('imps-no-wis','imps', 21, function()
        enableTimer('get pracs w/tobacco')
      end)
      cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
    end
  
  end)
else
  send(cmd)
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.100</time>
		</Timer>
		<TimerGroup isActive="no" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
			<name>njs50-druid</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<time>00:00:00.000</time>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>respell</name>
				<script>-- send('stand')
expandAlias('respell')</script>
				<command></command>
				<packageName></packageName>
				<time>00:01:00.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>improve spells w/ druid non combat improve filler</name>
				<script>cecho('\n&lt;white&gt;Improve - halftick\n')

improves.setFiller(druid.improveNonCombat)

send('stand')
improves.castSpell(function()
  send('|drink cauldron &amp; |sit couch &amp; |sleep')
end)

improves.resetFiller()
-- 
-- if player.skills['healing rain'] == 10 then
  -- send('quit')
  -- disableTimer('improve spells w/ druid non combat improve filler')
-- end</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:40.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>kick/swim while no improve casts queued</name>
				<script>-- local cmd = 'queue dive pool &amp; queue climb chain'
local cmd = '|kick stand &amp; |kick stand &amp; |kick stand'

-- local cmd = '|punch bag &amp; |punch bag &amp; |punch bag'

if (#improves.castQueue == 0) then
  send(cmd)
else
  
  if (improves.castFillerLastTick ~= false) then
    improves.castFillerLastTick = false
    tempTimer(65, function()
      send('+')
      murder.smokeUp('imps-no-wis','imps', 12, function()
        improves.castSpell()
        send('wait 3')
      end)
    end, 'casting buff delay')
  end
end</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:01.100</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>cast improve spell</name>
				<script>send(improves.getImproveSpell())</script>
				<command></command>
				<packageName></packageName>
				<time>00:01:05.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>drink cauldron + smoke</name>
				<script>
-- local timer = 'moj base pracs'
local timer = 'kick/swim while no improve casts queued'

disableTimer(timer)


send('drink cauldron')

murder.checkPracs(function(pracs)

  if (pracs &gt; 150) then
    cecho('\n\nto many pracs!\n\n')
    -- send('cstat got to 300 prac points, quitting for now...')
    -- send('quit')
    return
  else  
    cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
    murder.smokeUp('nowis','imps', 12, function()
      enableTimer(timer)
    end)
    
  end

end)
</script>
				<command></command>
				<packageName></packageName>
				<time>00:02:00.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>improve ticker w/ sleep + drink</name>
				<script>cecho('\n&lt;white&gt;Improve - halftick\n')

send('stand &amp; |drink trough &amp; |inventory')

improves.castSpell()

tempTimer(7, function()
  send('|sit couch &amp; |sleep')
end, 'pending imp attempt')</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:45.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>improve ticker w/tobacco</name>
				<script>cecho('\n&lt;white&gt;Improve - halftick\n')
-- send('stand')

if (#improves.castQueue &gt; 0) then

  murder.smokeUp('pracs-sans-wis','imps-regen', 19, function()
    tempTimer(3,function()
      improves.castSpell()
      -- send('sit couch &amp; sleep')
    end, 'casting improve')    
  end)
  
else
  improves.castSpell()
  -- send('sit couch &amp; sleep')
end</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:35.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>improve dowse</name>
				<script>send('cast dowse &amp; queue fill waterskin puddle &amp; queue empty waterskin &amp; queue fill waterskin puddle &amp; queue empty waterskin')</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:35.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>improve landwalk</name>
				<script>send('stand')

if (player.skills.landwalk &lt; 10) then
  tfe.gotoRoom(28112, function()
  
    send('gl &amp; ef &amp; dw &amp; pl &amp; queue cast landwalk')
    -- murder.smokeUp('imps-reg','imps', 10, function()
      -- send('queue hide &amp; queue sleep')
    -- end)
    tempTimer(3, function()
      send('queue hide &amp; queue sleep')
    end, 'landwalk improve')
    
  end)
  
else 

  tfe.gotoRoom({28112, 170})
  disableTimer('improve landwalk')
  
end</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:45.000</time>
			</Timer>
		</TimerGroup>
		<TimerGroup isActive="no" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
			<name>njs50-cleric</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<time>00:00:00.000</time>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>respell - improve buffs</name>
				<script>cecho('\n\nchecking buffs!\n\n')
njs50.respell(player.buffs, {queueSpellImprove = true})</script>
				<command></command>
				<packageName></packageName>
				<time>00:01:00.000</time>
			</Timer>
			<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>improve ticker w/tobacco</name>
				<script>cecho('\n&lt;white&gt;Improve - halftick\n')
-- send('stand')

if (#improves.castQueue &gt; 0) then

  if (improves.castFillerLastTick) then
    
    improves.castSpell()
  
  else

    murder.smokeUp('nowis','imps', 22, function()
      local message = '[improves] : ' .. improves.castQueue[1]
      common.consoleMessage('Log', message, 'green', true)
      improves.castSpell() 
    end)
    
  end
  
else
  -- improves.castSpell()
  -- send('sit couch &amp; sleep')
end</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:35.000</time>
			</Timer>
		</TimerGroup>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>player helpers</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>move from bag to bag</name>
				<script>local bag = matches[2]
local dest = matches[3]
local things = matches[4]
send('get ' .. things .. ' from ' .. bag)
send('put ' .. things .. ' ' .. dest)</script>
				<command></command>
				<packageName></packageName>
				<regex>^mb (.+) (.+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>deposit from bag</name>
				<script>local bag = matches[2]
local things = matches[3]
send('get ' .. things .. ' from ' .. bag)
send('deposit ' .. things)</script>
				<command></command>
				<packageName></packageName>
				<regex>^db (.+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>repair something</name>
				<script>local o = matches[2]

send('remove ' .. o)
o = o:gsub('2.','')
send('queue dip ' .. o .. ' youth')
send('queue repair ' .. o)
send('queue wear ' .. o)
send('queue eq')</script>
				<command></command>
				<packageName></packageName>
				<regex>^rep (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>all do</name>
				<script>local cmd = matches[2]

murder.allDo(cmd)</script>
				<command></command>
				<packageName></packageName>
				<regex>^ado (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>group do</name>
				<script>
murder.groupDo(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^gdo (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>see if anyone nearby is giving shields</name>
				<script>send('em tells you: "shields"')</script>
				<command></command>
				<packageName></packageName>
				<regex>^shield-check$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>refill barrel</name>
				<script>
send('gl')
  send('get ' .. player.barrelBag .. ' loot &amp; get barrel.' .. player.barrelContains .. ' ' .. player.barrelBag)
  
  send('empty barrel &amp; |fill barrel ' .. matches[2])
  
  send('put ' .. player.barrelContains .. '.barrel ' .. player.barrelBag .. ' &amp; put ' .. player.barrelBag .. ' loot')
send('pl')
send('dw') 
</script>
				<command></command>
				<packageName></packageName>
				<regex>^refill-barrel (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>check barrel</name>
				<script>
common.timedTempTrigger(5, 1, [[^A barrel (.*)\.$]], function()
  send('gstat ' .. matches[1])
end)


send('gl') 
  send('get ' .. player.barrelBag .. ' loot')
send('pl')
send('get barrel.' .. player.barrelContains .. ' ' .. player.barrelBag)

send('|look in barrel')

send('put ' .. player.barrelContains .. '.barrel ' .. player.barrelBag)
send('gl') 
  send('put ' .. player.barrelBag .. ' loot')
send('pl')
send('dw') 
</script>
				<command></command>
				<packageName></packageName>
				<regex>^check-barrel$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>put leveling gear</name>
				<script>send('put levWeap,levArmor leveling &amp; gs &amp; put leveling ' .. player.bag .. ' &amp; ps')</script>
				<command></command>
				<packageName></packageName>
				<regex>^pll$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>get leveling gear</name>
				<script>send('gs &amp; get leveling ' .. player.bag .. ' &amp; ps &amp; get levWeap,levArmor leveling')</script>
				<command></command>
				<packageName></packageName>
				<regex>^gll$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>check loot bag</name>
				<script>send('gl')
  send('|look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^cl$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>plank - cross gangplank when it lowers</name>
				<script>cecho('\n\n&lt;green&gt;PLANK:&lt;white&gt; waiting for gangplank\n\n')

tempTrigger('A gangplank swings down and clatters onto the deck', function()
  send('cross plank')
end, 1)</script>
				<command></command>
				<packageName></packageName>
				<regex>^plank$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>gear swap (uses swap script)</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>gear</name>
				<script>gearSets()</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear</name>
				<script>equipSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-partial</name>
				<script>equipPartial(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(gear-partial|equip your) (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-reset</name>
				<script>resetGear()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(gear-reset|put your usual gear back on)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-save</name>
				<script>saveGearSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear-save (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gear-delete</name>
				<script>deleteGearSet(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^gear-delete (.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>rotate weapons</name>
				<script>local lhWeap

if player.gear["left hand"] and player.gear["left hand"].base then
  lhWeap = common.dotCase(player.gear["left hand"].base.item)
end

local rhWeap = common.dotCase(player.gear["right hand"].base.item)


send('gs')

  if lhWeap then
    send('|remove ' .. lhWeap .. '.+3')
    send('|put ' .. lhWeap .. '.+3 ' .. player.bag)  
  end
  
  send('|remove ' .. rhWeap .. '.+3')
  send('|put ' .. rhWeap .. '.+3 ' .. player.bag)

  send('|get ' .. rhWeap .. '.+3 ' .. player.bag)  
  send('|wear ' .. rhWeap .. '.+3')

  if lhWeap then
    send('|get ' .. lhWeap .. '.+3 ' .. player.bag)   
    send('|wear ' .. lhWeap .. '.+3')
  end

send('ps')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^rotate weapons$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>drop junk (darion)</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>orog junk</name>
				<script>send('drop all.wood.shield, all.leather.armor, all.studded.armor, all.bronze.weapon, all.iron.weapon, all.steel.weapon' ..
		 ', all.frac.gem, all.padd.armor, all.bronze.shield, all.quarterstaff, all.old.boot, all.ringmail, all.cloth.robe')
		 
send('drop all.cloth.hat, all.coarse.cloak, all.chipped.gem, all.blemish.gem')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop orog junk</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort crytalline dragon loot</name>
				<script>send('give all.ruby to mojune')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort dragon loot$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort crypt  junk</name>
				<script>
-- send('give all.coin,all.phial,all.knight.helm to mojune')

send('drop all.bro.robe,all.fine.leat.boot,all.two-h.steel,all.weapon.iron,all.black.leat,' ..
		 'all.ringmail, all.old.armor, all.steel.mace, all.bronze.weapon')
		 
send('drop all.knight.armor,' ..
		 'all.narr.belt,all.steel.bast,all.bronze.chainm,all.iron.chainm,all.brass.knuck,' ..
		 'all.soft.boot,all.copper.coin'
)

send('drop all.dark.longswo,all.black.helm,all.dark.chainm,all.kni.girt,cloak.clasp,all.gray.iron.key,dark.robe')

send('empty all.glass.flask')


send('give phial,dark.crown,all.black.earth,glass.flask,diam.ring,black.sash,black.silk.robe,ivory.brac,all.coin mojune')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort crypt junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ent junk</name>
				<script>send('gt time to drop all.iron.shield, all.wood.shield, all.bronze.shield, maple.staf')
send('gt time to drop all.steel.shield, all.steel.weap, all.dam.swo.hilt, black.robe')
send('gt time to give all.note mojune')</script>
				<command></command>
				<packageName></packageName>
				<regex>^de$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort halfling junk</name>
				<script>send('drop all.brown.pants,all.studd.leather,all.homespun.blue,all.steel.short,all.ragg.pant,all.simp.mug,' ..
	 	'leath.journ,all.high.hard,all.wood.shield,all.leather.armor,all.wood.spear,all.wolf.skin,all.thick.deer')

send('drop all.banded.armor,all.cloth.robe,all.maple.staff,all.bronze.scale,all.meat.cleaver,all.rusty.iron.weap,' ..
		 'all.decrep.armor,all.steel.two-,all.hatchet,all.mug.simple,all.old.boot,short.ash.staff,all.rusty.iron.scale')

send('drop scrap.paper,official.paper,all.tarn.ringm,all.rusty.scalem,all.bear.skin,all.soft.leath,' .. 
     'all.padded.armor,all.soft.boot,all.hardt,dirty.robe,red.robe,all.bronze.weap')

send('label saddleb as deadHalfies &amp; open deadH &amp; get all deadH &amp; drop deadH &amp; get all.leather.cord')

send('drop all.copper.coin &amp; |get 100*copper.coin,all.gold.bear')

-- send('give all.silver.coin, all.copper.coin to mojune')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort halfling junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^sort stonies junk$</name>
				<script>-- send('give all.thimb,all.rag,all.coin, all.pillow to mojune')
send('drop all.thick.deer.skin,all.apron,all.dress,all.slab,all.berries')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort stonies junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop yeti junk</name>
				<script>send('drop all.yeti.foot,all.thick.yeti.hide,all.food &amp; get 5*food')

local dropJunk = "drop all.ringm,all.furred.steel.shield,all.hard leather,"..
	'all.low.boot,all.steel.scim,all.great.scim,all.furr.cloak,' ..
	"all.longs,all.wide.belt,all.spik.helm,all.yeti.foot,all.studded.leather" 

send(dropJunk)</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop yeti junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort luerna junk</name>
				<script>send('drop all.iron.dag,all.wooden.sword,all.ringmail,all.chainmail,' .. 
           'all.steel.battle.axe,all.empt.glass.vial')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort luerna junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort draconic junk</name>
				<script>send('drop all.two-.sword.bronze,all.two-.sword.iron,all.two-.sword.steel,all.hard.leather.armor')
send('put all.claw,all.scale,all.tooth in booty')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort draconic junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop mino junk</name>
				<script>send('drop all.red.black.shield,heavy.staff,bronze.weap,iron.weap,loincloth,' ..
     'forging.ham,protec.gogg,heavy.apron,steel.pole,all.steel.battle,' ..
     'oak.quarter,grey.robe,dark.red.robe, large.stone.tablet,gloss.book')
send('drop ' ..
     'oran.robe,yell.robe,quill.pen,paisl.robe,black.robe,sandy.volume,' .. 
     'wood.cup,blue.book,abacus,brown.robe,yell.wig,all.heavy.lance,' ..
     'all.stone.obsid.battle.axe')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop mino junk</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort mino junk</name>
				<script>send('get all burlap &amp; drop empty.burlap &amp; drop all.spider.corpse')
send('get all burlap &amp; drop empty.burlap &amp; drop all.spider.corpse')

send('put 5*silver.coin feath.sack &amp; |give all.coin darion &amp; get 5*silver.coin feath.sack &amp; give silver.coin ' .. group.leader)

send('label belly.pouch as arse &amp; |open arse &amp; get all arse &amp; drop arse')
send('gl')
send('put all.alloy.bar,all.darkish.phial,bat.tongue,shim.ball,all.torque,' .. 
     'all.mica,willow,angular.ham,all.dust,all.flask,all.graphi.rod,silk.pad,' .. 
     'green.tome,all.broke.crystal,summ.parch,map,chalk,blue-,wyv.scale in loot')
     
send('put all.coin,figur,adam.axe,all.beaker,cottonw.staff,astro,mith.lance,' .. 
     'glass.whist,great.obsid.axe,tome.parch,red.beak.axe,tiny.blue.pouch,head in loot')

send('get 5*silver.coin loot &amp; look in loot &amp; look loot')
     
send('pl')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort mino junk</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop tomb junk</name>
				<script>send('drop all.ringmail,all.chainmail,all.steel.shorts,all.steel.weapon,' ..
    'all.brown.robe,all.bronze.collar,wide.belt,white.robe,small.steel.shield,' .. 
    'training.armor,braid.tie,crims.robe,empt.sabretache,knee.boot,jag.longs')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop tomb junk</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop dogres junk</name>
				<script>send('drop all.worn.suit.leath,all.dusty.leath.boot,all.spike.stone.club,crims.black.robe,' ..
     'all.steel.two-,all.tarn.two-,all.hyen.skin')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop dogres junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort dogres junk</name>
				<script>send('drop all.tome.dispel &amp; gems')
send('gl')
  send('put all.dark.sand,all.feat.bone.charm,all.wand,all.incen,all.coin loot')
  send('get silver.coin loot &amp; give silver.coin mojune')
  send('look in loot &amp; | look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort dogres junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop citadel junk</name>
				<script>send('drop all.iron.halb,all.iron.hammer,all.leather.doubl,all.black.robe,all.heavy.oak.quart,' ..
     'all.hauberk,all.dark.tab,all.steel.bast,all.war.hat,all.arming.cap,all.chainm.cowl')
send('drop ' .. 
     'all.bronze.pike,all.iron.pike,all.cabasset,all.unholy.symbol,head.dark,all.burg.helm')
     </script>
				<command></command>
				<packageName></packageName>
				<regex>^drop citadel junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort citadel junk</name>
				<script>send('tell myrth do give all.phial darion')

send('give 2*silver.coin mojune &amp; |give all.copper.coin,all.silver.coin,all.gold.coin myrth &amp; |tell myrth do convert')

send('gl')

send('put all.beak,all.rusty.key,all.electrum.ring,all.human.hair,all.candle,all.mirror,all.coin,all.ebon.gem,' .. 
     'all.weight.gaunt,all.phial,all.spiked.armor,all.black.weapon,black.shield,glitt.ring,black.amul loot')

send('|get 5*silver.coin loot &amp; |look in loot &amp; |look loot')

send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort citadel junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort cyc junk</name>
				<script>send('give all.coin mojune')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort cyc junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>eldritch junk</name>
				<script>send('drop all.bear.skin,all.bear.slab,all.bear.entrail,cer.wing')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort eldrich junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort flowers junk</name>
				<script>send('drop honeycomb,all.buttonb')

send('gl')
  -- send('open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb &amp; open buttonb')
  send('put all.leaf,all.buttonb,all.achene,all.snail.shell,honey,white.lil,' .. 
       'all.turt.shell,all.tulw,all.willow,all.flower,all.moon,all.petal,' ..
       'all.eye loot &amp; |get 10*achene loot')
  send('|look loot &amp; |look in loot')
send('pl')

send('drop red.tunic,red.cap,old.boot,all.hard.leath.armor,all.turt.meet,all.saddle')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort flowers junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop fgs junk</name>
				<script>send('drop all.mass.club,all.stone-.obsid.axe,all.gigan.obsid.mace,all.mino.horn,stone-link.skirt')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop fgs junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort fgs junk</name>
				<script>send('gl')
  send('put all.coin,crude.obsid.skirt,all.broken.mino.horn,all.tiny.pouch,' .. 
       'all.bru.rose,all.coch,ivory-.clea loot')
  send('|look loot &amp; |look in loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort fgs junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort aspects junk</name>
				<script>send('drop all.copper.coin')
send('gl')
  send('put all.coin,shim.gem,heart-,all.phial,fiery.ruby,' .. 
       'all.brain,velv.blank,pearl.neckl,hand-woven,rune-.bas,' .. 
       'glim.stan loot')
  send('|get 5*silver.coin loot &amp; |look loot &amp; |look in loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort aspects junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort brass.block junk</name>
				<script>send('gl')
  send('put all.ingot,all.block,all.icon,all.wire,all.rod,' .. 
       'all.cryst.frag,cryst.but,all.gear,all.spring,all.sand,all.shard loot')
  send('|get 5*silver.coin loot &amp; |look loot &amp; |look in loot')
send('pl')

send('drop all.algae,all.white.snail,all.junk.ore &amp; | get 5*junk.ore')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort brass.block junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort warthogs junk</name>
				<script>send('drop green.cotm,maple.staff,blue.mushr,brown.robe')

send('gl')
  send('put all.tusk loot')
  send('|look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort warthogs junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort vcave.ghouls junk</name>
				<script>send('drop all.soft.leather,all.royal.potion,all.bronze.weapon,all.old.boot,' .. 
     'all.scrap.paper,all.ball-.hammer,all.bronze.ring,all.iron.longs')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort vcave.ghouls junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort specter of a knight junk</name>
				<script>send('drop all.blemished.gem, all.chipped.gem, all.scratched.gem, all.frac.gem, all.steel.bastard, all.iron.nails, all.rock, all.boulder')
send('label empt.sadd as notReplicated &amp; gl &amp; put notReplicated, all.timeworn,all.phial,all.gem,all.flint,all.horsesh,all.metal.frag,all.lance, all.keyr in loot &amp; pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort knight junk</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>drop junk</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>drop tg junk</name>
				<script>
send('drop all.black.armband,all.black.leather.armor,all.bone.ring,all.soft.leath.armor' .. 
     ',all.hard.leath.armor,all.high.boot,all.scor.mith,all.open-.mith,all.large.wood.club,' ..
     'all.wood.shield,all.quilt.pad,all.steel-h.spear,all.scale.arm,all.spike.shield,')

send('drop all.stud.leat.arm,all.two-hand.war.club,all.bron.shie,all.banded.armor,' .. 
     'all.iron-.shield,all.ringmail,all.two-.sto.swo,all.furr.steel.shie,all.small.iron.shield')

send('gl')
  send('put all.flesh,all.bless,all.great.war.club,all.reflec.glai,all.coin loot')
  send('|get 20*silver.coin loot &amp; |look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop tg junk</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort panda junk</name>
				<script>send('drop all.shred.burl.dress')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort panda junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort palace junk</name>
				<script>send('gl')
  send('put all.dark.purple.robe, all.dark.green.robe, all.gold.ring in loot')
  -- send('put all.palace.uniform, all.dirty.rag, all.sash.palace, all.dark.robe, voal.guard.tab, all.copper.coin,' ..
   -- 'all.silver.coin, all.candle, all.spec, all.tome, all.ring, scimit, all.phial, all.ascot, all.potio in loot')
  send('look in loot')
send('pl')
-- send('look in moreloot')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort (palace|palace.full) junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop palace junk</name>
				<script>  send('drop all.sandal, all.brown.robe, all.two-hand.iron, all.red.dress, slend.wood.key,' ..
       'rough.iron.key, all.apron, all.rusty.cleaver, all.harp, all.drum, jet.robe')
       
  expandAlias('drop damaged palace.uniform')
  expandAlias('drop damaged voal.tabard')
  expandAlias('drop damaged sash.palace.guard')
  expandAlias('drop damaged fine.boot')
  </script>
				<command></command>
				<packageName></packageName>
				<regex>^drop (palace|palace.full) junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^sort tomb junk$</name>
				<script>send('gl')
  send('put all.phial,all.coin,all.cryst.great,raz.diam.bla,elec.shav loot &amp; |get 10*silver.coin loot')
  send('|look loot &amp; |look in loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort tomb junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop temple junk</name>
				<script>send('drop all.barb.flail,blue.gown,all.steel.bast,all.green.ball,all.rusty.punch,' ..
      'all.cowled.robe,all.iron.pike,all.empty.vial,all.bronze.pike,all.ringmail,' .. 
      'all.chainmail,all.wood.spear,all.iron.shorts,all.cerem.halb,all.brass.knuck')
send('drop all.blue.silv.robe,all.tarn.mith.bast,all.red.leath')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop temple junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort temple junk</name>
				<script>send('give silver.coin ' .. group.leader)
send('gems &amp; appr gem &amp; appr gem &amp; appr gem &amp; appr gem &amp; appr gem &amp; appr gem &amp; gems')
send('gl')
  send('put all.phial,all.bluish.incen,all.blessed.candle,all.sapph,all.diam,all.emeral,' .. 
       'all.trans.blue,all.sable.shield,all.red.leather,all.black.opal,all.crims.gem loot')
  send('|look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort temple junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop wastes junk</name>
				<script>send('drop all.boar.tusk,all.dented.breastpl,all.steel.broad,all.brass.knuck,all.slend.steel.longs,all.waln')
send('drop 5*silver.coin')
-- send('give all.chan.cryst,all.coin,nekode,blue.trans,claym,silv.mith.brea,all.owlb,all.blacken,all.unicorn,all.dark.hair,all.shrieker.flesh Bimgore')
send('get 5*silver.coin')</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop wastes junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort wastes junk</name>
				<script>send('gl')
  send('put all.chan.cryst,nekode,blue.trans,claym,silv.mith.brea,all.owlb,all.blacken,all.unicorn,' .. 
       'all.dark.hair,all.shrieker.flesh,all.elip.disk loot')
  send('|look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort wastes junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^sort tireth.demon junk$</name>
				<script>send('gl')
  send('put all.coin,all.turq.cryst,all.dusk.scale,rune.ensc.obs.rod,tatt.demo loot')
  send('|get 10*silver.coin loot')
  send('|look loot &amp; |look in loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort tireth.demon junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>crone turn in</name>
				<script>send('get ' .. matches[2] .. ' loot' .. ' &amp; give ' .. matches[2] .. ' crone')</script>
				<command></command>
				<packageName></packageName>
				<regex>^cr (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>spooky isles</name>
				<script>send('gl')
  send('drop all.rodent.meat,all.monkey.brain')
  
  if (player.name == group.leader) then
    send('get all.reagent ' .. player.pack)  
  end
  
  send('put all.root,all.bloom,all.seas,all.starf,all.heart,all.tooth,all.claws,' ..
      'all.goos,all.seed,all.dewb,all.yell.feat,all.flower,birch.bark,thorn,uncut.gem,' .. 
      'all.tri-.fea,all.scale,all.gems,nightst,gold.cube,all.reagent,all.oct.seed loot')
  send('|look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort spooky.isle junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort pod junk</name>
				<script>send('gems')
send('drop jet.black.robe,bronze.cup,steel.bast.sword,mith.bast,' ..
     'steel-tip.boot,all.chainm,heavy.quart,steel.dagger,all.bronze.scale.armor,' ..
     'all.wood.shield,all.brown.robe,all.narrow.leather.belt,all.mushroom,all.spear,' ..
     'all.steel.shield,all.steel.shorts,all.steel.bast,all.mith.bast,all.bro.batt.axe')

send('drop all.iron.scale.mail,all.bear.skin')

send('gl')
  send('put all.gem,all.smoo.crys,all.phial,rune-.skul,lion.mane,all.diam,all.griz.hair,' .. 
       'all.incen,all.ingot,all.tatt.scro,all.bott.amber,kopis,old.greav,twist.stick in loot')
  send('|get smoo.clear.canteen loot &amp; |look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort pod junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort plantation junk</name>
				<script>
     
send('gl')
  send('put all.catfish,all.basket,all.reagent,all.leather.strap,all.tiny.bone,all.sapph.pend,all.rainbow,' .. 
       'all.feather,gold.circl,coll.sapph,all.claw,all.tooth,dire.skin,were.skin,ess.purp in loot')
  send('|get all.rainbow.bait loot &amp; |look in loot &amp; |look loot')
send('pl')

send('drop all.food,all.dog.coll,all.rusty.saw,all.skillet,all.trowel,all.stuff.bat,' .. 
     'maid.unif,all.spectacle,all.ceramic.cup,all.quill.pen,all.apple,all.gard.shear,' ..
     'all.goat.horn')

send('drop ' ..     
     'all.saddle.blanket,all.soap,all.white.glove,all.apple.core,all.goat.skin,' .. 
     'all.acorn,all.bronze.cup,all.cigar')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort plantation junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort wood.imps junk</name>
				<script>send('drop all.hard.leather,all.soft.leather,all.pine.dag,all.pine.bracel,apron,iron.rapier,' .. 
      'chipped.mask,oak.staff,maple.staff,bronze.sabre,wood.ladl,all.steel.dag,all.flint.dag')
      
send('gl')
  
  if (player.name == group.leader) then
    send('get all.reagent ' .. player.pack)  
  end

  send('put all.reagent,all.waxy.green,all.crims.inc,all.dusty.brown loot')
  send('|look in loot &amp; |look loot')     
  
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort wood.imps junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop ahrimans junk</name>
				<script>send('drop all.heavy.oak.staff,all.ash.staff,all.maple.staff,all.fine.boot,all.purp.robe,' ..
     'all.instruct.robe,all.star-pat.robe,all.knee-.boot,all.steel.shorts,all.iron.shorts,' .. 
     'all.black.leather.armor,all.steel.two-hand,bron.bad,lar.wood.spea,steel.bast,headstone')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop ahrimans junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort ahrimans junk</name>
				<script>send('drop faded.red.diar,all.tomato,all.onion,deep.blue.key,blocky.green.key,' .. 
           'tri-.note,crude.note,empt.vial,cyan.pelt')
           
send('give purp.charm ' .. group.leader)

</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort ahrimans junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort western.expanse junk</name>
				<script>send('get all burl.bag')
send('drop all.empt.burl.bag,all.eel.meat,all.raw.crawf.tail,all.bison.meat')

send('gl')
  send('|put all.fang,all.eyeball,all.bone,all.skin,all.turt.shell,all.rib,' .. 
       'all.iris,all.bloss loot')
  send('|look in loot &amp; |look loot')
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort western.expanse junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort myconids junk</name>
				<script>send('drop all.decrep')

send('gl')
  
  if (player.name == group.leader) then
    send('get all.reagent ' .. player.pack)  
    send('put all.reagent ' .. player.pack)  
  end

  send('put wyrm,all.spinn,batt.axe,all.myconid,tiger-,anc.grea,all.ring,all.fauc loot')
  send('|look in loot &amp; |look loot')     
  
send('pl')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort myconids junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop myconids junk</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex>^drop myconids junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sort bag.holding junk</name>
				<script>send('drop yel.chal,blue.chal,gre.chal,iron.key,white.apron,grey.robe,ash.staff,note')</script>
				<command></command>
				<packageName></packageName>
				<regex>^sort bag.holding junk$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>drop damaged</name>
				<script>local target = matches[2]

send('drop all.worthless.' .. target .. ',all.damaged.'  .. target .. ',all.worn.' .. target .. ',all.scratch.' .. target)</script>
				<command></command>
				<packageName></packageName>
				<regex>^drop damaged (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^bank voaleth loot$</name>
				<script>send('empty all.glass.flask')
      
send('|dep all.coin,all.tob,all.+3,all.mitre,all.silver.armor,all.dagger,all.sword,' ..
     'all.brown.boot,all.wiza.hat,all.morningstar,all.stone.staff,all.book.ages,' ..
     'all.swirl.potion,emerald.ring,sapp.diam,bloody.cleav,ascot,head.tyran,censer,all.flute,' .. 
     'all.empty.flask,all.phial')

send('|with 20050')

send('get all.tobacco,all.reagent morel &amp; |deposit all.reagent,all.tobacco')

-- send('get all.glass.shard backp')
-- 
-- send('bal')</script>
				<command></command>
				<packageName></packageName>
				<regex>^bank voaleth loot$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>damage meter</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>dm</name>
				<script>local cmd = matches[2]
local param = matches[3]


local commands = {
	
	start = damageMeter.start,
	
	stop = damageMeter.stop,

    
	show = function (target)
   damageMeter.report(target)
	end,
  

}

local fn = commands[cmd]

if (fn) then
	fn(param)
else
  cecho('\n\n&lt;red&gt;DM: &lt;white&gt;error - unknown command ' .. cmd .. '\n')
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^dm (\S+) ?(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>misc</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>grep</name>
				<script>local pattern = matches[3]
local cmd = matches[2]

cecho('\n&lt;green&gt;GREP:&lt;white&gt; searching "' .. cmd .. '" for: ' .. pattern .. '\n')

local killLineTrig = tempRegexTrigger([[^.*$]], function()
  if (not rex.match(matches[1], [[(?i)]] .. pattern)) then
    display(matches[1])
    deleteLine()
  end
end)


common.onNextEvent(common.events.PARSED_PROMPT, function()
  killTrigger(killLineTrig)
  tempTimer(0, function()
    send('\n', false) -- get a new prompt since we killed the last one
    cecho('\n&lt;green&gt;GREP:&lt;white&gt; search done\n')
  end)
end)

send(cmd, false)</script>
				<command></command>
				<packageName></packageName>
				<regex>(.+?) ?\| grep (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>display gates</name>
				<script>cecho('\n&lt;green&gt;Brithbarad &lt;white&gt;&gt; Outback')
cecho('\n&lt;green&gt;Chiiron &lt;white&gt;&gt; Wayward')
cecho('\n&lt;green&gt;Medienne &lt;white&gt;&gt; Knight')
cecho('\n&lt;green&gt;Kha-da &lt;white&gt;&gt; Cairn')
cecho('\n&lt;green&gt;Voaleth &lt;white&gt;&gt; Whisper')
cecho('\n&lt;green&gt;Vaasa &lt;white&gt;&gt; Blade')
cecho('\n&lt;green&gt;Pennan &lt;white&gt;&gt; Hollow')
cecho('\n&lt;green&gt;Narak &lt;white&gt;&gt; Corsair')
cecho('\n&lt;green&gt;Sos-kul &lt;white&gt;&gt; Fire')
cecho('\n&lt;green&gt;Orlumber &lt;white&gt;&gt; Midnight')
cecho('\n&lt;green&gt;Brembledon &lt;white&gt;&gt; Amber')</script>
				<command></command>
				<packageName></packageName>
				<regex>^gates$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>xp report</name>
				<script>xp_record = xp_record or {}

local getSlice = function(arr, dt_min)

  local ret = {}
    
  for idx, val in pairs(arr) do
    
    if val.dt &gt;= dt_min then
      table.insert(ret, val)
    end
    
  end

  return ret

end


local sumVals = function(arr)
  
  local ret = 0
    
  for idx, val in pairs(arr) do
    ret = ret + val.val
  end

  return ret

end

local last_hour = getSlice(xp_record, getEpoch() - (60*60))

-- discard any records older than one hour
xp_record = last_hour

local xpt = sumVals(last_hour)
local timeToLevel = gmcp.Char.Score.xp_needed / xpt
local entireLevelTime = gmcp.Char.Score.xp_level / xpt

cecho('\n' .. tostring(#last_hour) .. ' kills in previous hour is: &lt;purple&gt;' .. njs50.commaCase(tostring(xpt)) .. 'xp\n')



local last_five_mins = getSlice(xp_record, getEpoch() - (60*10))
xpt = sumVals(last_five_mins)
cecho(tostring(#last_five_mins) .. ' kills in previous ten minutes is: &lt;purple&gt;' .. njs50.commaCase(tostring(xpt)) .. '\n')




cecho('\nTime to level is: &lt;purple&gt;' .. common.formatElapsedTime(timeToLevel*3600) .. '\n')

cecho('Entire level would take: &lt;purple&gt;' .. common.formatElapsedTime(entireLevelTime*3600) .. '\n\n')



</script>
				<command></command>
				<packageName></packageName>
				<regex>^xp$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>set optiion</name>
				<script>local option = matches[2]
local desiredVal = matches[3]


local kilTempTimedTrig = common.timedTempTrigger(4, 1, '^' .. option .. [[ set to (\S+)\.$]] , function()

  if (matches[2] ~= desiredVal) then
    cecho(' &lt;orange&gt;&lt;--- incorrect option value\n')
    send('opt ' .. option)
  else
    cecho(' &lt;green&gt;&lt;--- correct option value\n')
  end

end)

send('opt ' .. option)</script>
				<command></command>
				<packageName></packageName>
				<regex>^setOption (\S+) (true|false)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>set optiion</name>
				<script>local option = matches[2]
local desiredVal = matches[3]


local kilTempTimedTrig = common.timedTempTrigger(4, 1, '^' .. option .. [[ on scan options set to (\S+)\.$]] , function()
  if (matches[2] ~= desiredVal) then
    cecho(' &lt;orange&gt;&lt;--- incorrect option value\n')
    send('scan -o ' .. option)
  else
    cecho(' &lt;green&gt;&lt;--- correct option value\n')
  end

end)

send('scan -o ' .. option)</script>
				<command></command>
				<packageName></packageName>
				<regex>^set scan option (\S+) (true|false)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>healing</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>healer</name>
				<script>local param = matches[3]

local command = matches[2]

local commands = {

  mode = function(mode)
    healer.setMode(mode)
  end,

  config = function(mode)
    healer.showConfig()
  end,
  
  set = function(args)
    healer.set(args)
  end,
  
  spell = function(args)
    healer.setHealSpell(args)
  end,
  
  minPrepped = function(args)
    healer.setMinPrepped(args)
  end,  

  help = function()
    healer.help()
  end,

}

commands[command](param)</script>
				<command></command>
				<packageName></packageName>
				<regex>^healer (\w+) ?(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>farmer</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>farm</name>
				<script>farmer.start(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^farm (\S+)\s?(\S+)?</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>report gstat</name>
				<script>-- send('level')
-- farmer.startTime, farmer.lapStartTime

local totalTime = getEpoch() - farmer.startTime
local lapTime = getEpoch() - farmer.lapStartTime



send('gstat Farm laps: ' .. tostring(farmer.lapCounter or 0))

if (lapTime ~= nil) then
	send('gstat Current lap time: ' .. common.formatElapsedTime(lapTime))
end

if (farmer.lapRepopWaitTime ~= nil) then
	send('gstat Current lap repop wait time: ' .. common.formatElapsedTime(farmer.lapRepopWaitTime))
end

if (farmer.lapInfo ~= nil) then
  for k, v in pairs(farmer.lapInfo) do
    send('gstat ' .. k .. ': ' .. tostring(v))
  end
else
  send('gstat no additional lap info\n\n')
end

if (totalTime ~= nil) then
	send('gstat Total time: ' .. common.formatElapsedTime(totalTime))
end

if (totalTime ~= nil and farmer.lapCounter &gt; 0) then
	send('gstat Average run time: ' .. common.formatElapsedTime((totalTime - lapTime) / farmer.lapCounter))
end

if (farmer.repopWaitTime ~= nil and farmer.lapCounter &gt; 0) then
	send('gstat Average repop wait time: ' .. common.formatElapsedTime(farmer.repopWaitTime / farmer.lapCounter))
end

send('gstat Confirmed kills: ' .. tostring(farmer.killcount or 0) .. '\n')

if (farmer.cumulativeInfo ~= nil) then
  for k, v in pairs(farmer.cumulativeInfo) do
    local str = ''
    for i=1, #v do
       str = str .. tostring(v[i])
       if (i ~= #v) then
        str = str .. ', '
       end
    end
    
    send('gstat ' .. k .. ': ' .. str)
  end
else
  send('gstat no additional lap info\n\n')
end
</script>
				<command></command>
				<packageName></packageName>
				<regex>^report gstat$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>report</name>
				<script>-- send('level')
-- farmer.startTime, farmer.lapStartTime

local totalTime = getEpoch() - farmer.startTime
local lapTime = getEpoch() - farmer.lapStartTime



cecho('\n\n&lt;green&gt;Farm laps:&lt;white&gt; ' .. tostring(farmer.lapCounter or 0))

if (lapTime ~= nil) then
	cecho('\n&lt;green&gt;Current lap time:&lt;white&gt; ' .. common.formatElapsedTime(lapTime))
end

if (farmer.lapRepopWaitTime ~= nil) then
	cecho('\n&lt;green&gt;Current lap repop wait time:&lt;white&gt; ' .. common.formatElapsedTime(farmer.lapRepopWaitTime))
end

if (farmer.lapInfo ~= nil) then
  for k, v in pairs(farmer.lapInfo) do
    cecho('\n&lt;green&gt;' .. k .. ':&lt;white&gt; ' .. tostring(v))
  end
else
  cecho('no additional lap info\n\n')
end

if (totalTime ~= nil) then
	cecho('\n&lt;green&gt;Total time:&lt;white&gt; ' .. common.formatElapsedTime(totalTime))
end

if (totalTime ~= nil and farmer.lapCounter &gt; 0) then
	cecho('\n&lt;green&gt;Average run time&lt;white&gt; : ' .. common.formatElapsedTime((totalTime - lapTime) / farmer.lapCounter))
end

if (farmer.repopWaitTime ~= nil and farmer.lapCounter &gt; 0) then
	cecho('\n&lt;green&gt;Average repop wait time:&lt;white&gt; ' .. common.formatElapsedTime(farmer.repopWaitTime / farmer.lapCounter))
end

cecho('\n&lt;green&gt;Confirmed kills: &lt;white&gt;' .. tostring(farmer.killcount or 0) .. '\n')

if (farmer.cumulativeInfo ~= nil) then
  for k, v in pairs(farmer.cumulativeInfo) do
    cecho('\n&lt;green&gt;' .. k .. ':&lt;white&gt; ')
    for i=1, #v do
       cecho(tostring(v[i]) )
       if (i ~= #v) then
        cecho(', ')
       end
    end
  end
else
  cecho('no additional lap info\n\n')
end
</script>
				<command></command>
				<packageName></packageName>
				<regex>^report$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>explore</name>
				<script>local cmd = matches[3]
local param = matches[4]

local displayTargets = function(label, targets)

  cecho('  &lt;white&gt;' .. label .. ' &lt;yellow&gt;= &lt;white&gt;{\n')
  for mob, val in pairs(targets) do
    cecho('    &lt;white&gt;["&lt;light_blue&gt;' .. mob .. '&lt;white&gt;"] = &lt;pink&gt;1&lt;white&gt;,\n')
  end
  cecho('  &lt;white&gt;},\n\n')
  
end


local commands = {
	
	start = function ()
    murder.runName = 'exploreScript'
		murder.explore()
	end,
	
	stop = function()
		murder.stop()
	end,
	
	nonHostile = function (mob)
		murder.targets[mob] = nil
		murder.nonHostileTargets[mob] = true
	end,
		
	ignore = function (mob)
		murder.targets[mob] = nil
		murder.ignoreTargets[mob] = true
	end,
		
  		
	name = function (name)
		murder.runName = name
	end,  
    
	show = function ()
		cecho('\n\n&lt;green&gt;EXPLORE: &lt;white&gt;targets\n')
		display(murder.targets)
    
    if (njs50.tablelength(murder.nastyTargets) &gt; 0) then
    		cecho('\n\n&lt;green&gt;EXPLORE: &lt;white&gt;nasty targets\n')
    		display(murder.nastyTargets)
    end 
        
    if (njs50.tablelength(murder.nonHostileTargets) &gt; 0) then
    		cecho('\n\n&lt;green&gt;EXPLORE: &lt;white&gt;non hosttile targets\n')
    		display(murder.nonHostileTargets)
    end
    
    if (njs50.tablelength(murder.ignoreTargets) &gt; 0) then
    		cecho('\n\n&lt;green&gt;EXPLORE: &lt;white&gt;ignored targets\n')
    		display(murder.ignoreTargets)
    end
    
		cecho('\n\n&lt;green&gt;EXPLORE: &lt;white&gt;waypoints\n')
		for k, v in pairs(murder.xpoints) do
			cecho(k .. ' - ' .. njs50.tableToString(v.rooms) .. ' : ' .. v.note .. '\n')
		end
	end,
  
  
  
  script = function ()
  
    local firstTarget = ''
    for k, v in pairs(murder.targets) do
      firstTarget = k
      break;
    end
  
    cecho('\n\n&lt;green&gt;MURDER SCRIPT: &lt;white&gt;' .. murder.runName .. '\n\n')
    
    cecho('&lt;white&gt;farmer.afterCommonLoaded(&lt;yellow&gt;function &lt;white&gt;()\n\n')
    
    
    cecho('&lt;yellow&gt;local &lt;white&gt;options &lt;yellow&gt;= &lt;white&gt;{\n')
    cecho("\n  &lt;white&gt;longName = '&lt;light_blue&gt;" .. murder.runName .. "&lt;white&gt;',\n\n")

    displayTargets('targets', murder.targets)
  
    if (njs50.tablelength(murder.nastyTargets) &gt; 0) then
  		  displayTargets('nastyTargets', murder.nastyTargets)
    end
  
    if (njs50.tablelength(murder.nonHostileTargets) &gt; 0) then
  		  displayTargets('nonHostileTargets', murder.nonHostileTargets)
    end
    
    if (njs50.tablelength(murder.ignoreTargets) &gt; 0) then
  		  displayTargets('ignoreTargets', murder.ignoreTargets)
    end
        
    cecho('  &lt;white&gt;waitForSplitAmount&lt;yellow&gt; = &lt;pink&gt;3&lt;white&gt;,\n\n')
    cecho('  &lt;white&gt;notifyMobBeforeMove&lt;yellow&gt; = &lt;orange&gt;true&lt;white&gt;,\n\n')
    
    cecho("  &lt;white&gt;onStopByTrigger = &lt;yellow&gt;function &lt;white&gt;()\n")
    cecho("    &lt;white&gt;send('&lt;light_blue&gt;stop was commanded - begin self destruct sequence&lt;white&gt;')\n")
    cecho("  &lt;yellow&gt;end&lt;white&gt;,\n\n")
    cecho('&lt;white&gt;}\n\n')    
    
    

    
    -- steps
    cecho('&lt;yellow&gt;local &lt;white&gt;steps &lt;yellow&gt;= &lt;white&gt;{\n\n')
    for k, v in pairs(murder.xpoints) do
      cecho('  &lt;white&gt;{\n')
      cecho('    &lt;white&gt;waypoints&lt;yellow&gt; = &lt;white&gt;{&lt;pink&gt;' .. njs50.tableToString(v.rooms) ..'&lt;white&gt;}, -- ' .. v.note .. '\n')

      if (k == 1) then
        cecho('    &lt;white&gt;action&lt;yellow&gt; = function &lt;white&gt;(cb)\n')
        cecho("      &lt;white&gt;send('&lt;light_blue&gt;group -l " .. player.name .. "&lt;white&gt;')\n")
        cecho("      &lt;white&gt;common.comeToMe(&lt;yellow&gt;function &lt;white&gt;()\n")
        cecho("        &lt;white&gt;common.groupPrepFull(&lt;yellow&gt;function &lt;white&gt;()\n")
        cecho("          &lt;gray&gt;-- some sort of repop check\n")
        cecho("          &lt;white&gt;cb()\n")
        cecho("        &lt;yellow&gt;end&lt;white&gt;)\n")
        cecho("      &lt;yellow&gt;end&lt;white&gt;)\n")
        cecho('    &lt;white&gt;end,\n')
      end
      
      -- cecho(k .. ' - ' .. njs50.tableToString(v.rooms) .. ' : ' .. v.note .. '\n')
      cecho('  &lt;white&gt;},\n\n')
		end
    cecho('&lt;white&gt;}\n\n')
    
    cecho('&lt;yellow&gt;local &lt;white&gt;completeCallback &lt;yellow&gt;= function&lt;white&gt; ()\n')
    cecho("  &lt;white&gt;send('&lt;light_blue&gt;gstat " .. murder.runName .. " is done...&lt;white&gt;')\n")
    cecho("  &lt;white&gt;expandAlias(&lt;light_blue&gt;'sort " .. murder.runName .. " junk&lt;white&gt;')\n")
    cecho("  &lt;white&gt;tempTimer(&lt;pink&gt;5&lt;white&gt;, &lt;yellow&gt;function &lt;white&gt;()\n")
    cecho("    &lt;gray&gt;-- farmer.restart()\n")
    cecho("  &lt;yellow&gt;end&lt;white&gt;)\n")
    cecho('&lt;yellow&gt;end\n\n')

    cecho("&lt;white&gt;farmer.configure('" .. murder.runName .. "', steps, completeCallback, options)\n\n")

    cecho("&lt;yellow&gt;end&lt;white&gt;)\n\n")
  		-- 
  -- farmer.configure('xxxx', steps, completeCallback, opts)   
    -- 
    
      
  end,

  -- action = function (cb)
    -- -- send('gt time to sort monestry junk')
    -- maintainJuice(cb)
  -- end

  

	step = function ()
		
		local wpt = {
			rooms = { tfe.roomInfo.num },
			note = matches[4]
		}
		
		table.insert(murder.xpoints, wpt)
		
	end,
  
  ["step-reset"] = function ()

		table.remove(murder.xpoints)
		
	end,
  
   	
	add = function ()
		
		local wpt = murder.xpoints[#murder.xpoints]

    table.insert(wpt.rooms, tfe.roomInfo.num)
		
	end, 
  

}

local fn = commands[cmd]

if (fn) then
	fn(param)
else
  
  
  if (cmd:match('^%d+$')) then
    local target = tonumber(cmd)
    if (murder.xpoints[target]) then
      tfe.gotoRoom(murder.xpoints[target].rooms)
    else
      cecho('\n\n&lt;red&gt;EXPLORE: &lt;white&gt;error - invalid waypoint ' .. cmd .. '\n')
    end
    
  else  
  
    cecho('\n\n&lt;red&gt;EXPLORE: &lt;white&gt;error - unknown method ' .. cmd .. '\n')
    
  end



	
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(x|explore) (\S+) ?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>explore kill</name>
				<script>

local dir = tfe.consts.exitmap[matches[2]]
local exit = murder.exits[dir]

if (murder.exploring and exit and exit.firstTarget) then
  
  	local cmd  = dir .. ' &amp; ' .. murder.getKillCommand(exit, murder.exits, dir)  
 
  if (murder.notifyMobBeforeMove and exit) then

    murder.sendNextTarget(exit)
    
    	tempTimer(1.5, function ()
    		expandAlias(cmd)
    	end)
      
  else 
  	 expandAlias(cmd)
  end

else

	expandAlias(dir)
	-- cecho('\n\n&lt;green&gt;EXPLORE: &lt;white&gt;no mobs ' .. dir .. '\n')
end

</script>
				<command></command>
				<packageName></packageName>
				<regex>^k([neswud])$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>load zone info</name>
				<script>local zones = {
	tg = {
	
		targets = {
      ["acolyte Morkith"] = true,
      ["valley warder"] = true,
      ["troll foot soldier"] = true,
      ["acid hound"] = true,
      ["acolyte Temohpab"] = true,
      ["ogre foot soldier"] = true,
      ["young lizardwoman monk"] = true,
      ["silver-veined gargoyle black marble"] = true,
      ["hardy shopkeeper"] = true,
      ["goblin eremite chosen Morkith"] = true,
      ["priestes Morkith"] = true,
      ["colossal muscular troll"] = true,
      ["vyan adept chosen Morkith"] = true,
      ["acolytes Morkith"] = true,
      ["young monk"] = true
    },
    
    fixCommas = {
      ["vyan adept, chosen Morkith"] = "vyan adept chosen Morkith",
      ["colossal, muscular troll"] = "colossal muscular troll",
      ["goblin eremite, chosen Morkith"] = "goblin eremite chosen Morkith"
    },
		
  	mobElements = {
      ["human.sculptor"] = "Acid",
      ["priestes.Morkith"] = "Cold",
      ["research.imp"] = "Cold",
      ["altar.boy"] = "Fire",
      ["colossal.muscular.troll"] = "Fire",
      ["young.lizardwoman.monk"] = "Acid",
      ["acolyte.Temohpab"] = "Fire",
      ["silver-veined.gargoyle.black.marble"] = "Acid",
      ["ogre.foot.soldier"] = "Elec",
      ["dwarven.architect"] = "Acid",
      ["young.monk"] = "Fire",
      ["acid.hound"] = "Fire",
      ["troll.foot.soldier"] = "Fire",
      ["dwarven.sculptor"] = "Elec",
      ["vyan.adept.chosen.Morkith"] = "Fire",
      ["acolyte.Morkith"] = "Elec",
      ["goblin.eremite.chosen.Morkith"] = "Elec"
    }

	},
	
	cycs = {
		targets = {
      ["cyclop monk"] = true,
      ["cyclop shaman"] = true,
      ["greater bat"] = true,
      ["lesser cyclope"] = true,
      ["cyclop warleader"] = true,
      ["greater cyclop"] = true,
      ["cyclop cook"] = true,
      ["grizzly bear"] = true,
      ["greater cyclope"] = true,
      ["mammoth rat"] = true,
      ["lesser cyclop"] = true,
    	["cave strangler"] = true,		
		},
		fixCommas = {},
		mobElements = {
      ["cyclop.cook"] = "Fire",
      ["cyclop.warleader"] = "Elec",
      ["greater.bat"] = "Fire",
      ["greater.cyclop"] = "Elec",
      ["mammoth.rat"] = "Elec",
      ["cyclop.shaman"] = "Elec",
      ["lesser.cyclop"] = "Elec",
      ["cyclop.monk"] = "Fire"
    }
	
	},
	
	vyans = {
		targets = {
      ["spectral direwolf"] = true,
      wraith = true,
      ["Mojune "] = true,
      presence = true,
      ["spectral guardian"] = true,
      ["pale solemn wraithlord"] = true,
      ["lesser wraith"] = true,
      ["screech bat"] = true,
      ["vyan maiden"] = true,
      ["mas darknes"] = true,
      ["flowing serene wraith"] = true,
      wraithlord = true,
      ["dark figure"] = true
    },
		fixCommas = {
      ["flowing, serene wraith"] = "flowing serene wraith",
      ["pale, solemn wraithlord"] = "pale solemn wraithlord"
    },
		mobElements = {
      ["pale.solemn.wraithlord"] = "Elec",
      ["lesser.wraith"] = "Elec",
      ["spectral.guardian"] = "Fire",
      ["mas.darknes"] = "Elec",
      ["dark.figure"] = "Fire",
      wraithlord = "Elec",
      ["flowing.serene.wraith"] = "Fire",
      wraith = "Elec",
      presence = "Elec"		
		}
	},
	
	theater = {
		targets = {},
		fixCommas = {},
		mobElements = {
      ["ghost.effect.master"] = "Fire",
      ["dark.phantom"] = "Fire",
      ["backstage.collection.guard"] = "Elec",
      ["stage.manager"] = "Elec",
      ["theatre.sentry"] = "Elec",
      ["fat.opera.singer"] = "Elec",
      ["well-groomed.patron"] = "Fire",
      ["royal-looking.actor"] = "Elec",
      ["theatre.employee"] = "Elec",    
      ["thespian.playing.queen"] = "Elec",
      ["theatre.collection.guard"] = "Elec"
    }
	
	}

}

local zone = zones[matches[2]]

if (zone) then
	murder.targets = zone.targets
	murder.fixCommas = zone.fixCommas
	mobElements = zone.mobElements
else
	cecho('\n\n&lt;red&gt;LOADER: &lt;white&gt; unknown zone!!\n\n')
end

</script>
				<command></command>
				<packageName></packageName>
				<regex>^load (.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Debug</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>show triggers</name>
				<script>displayTempTriggers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^triggers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show timers</name>
				<script>displayTempTimers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^timers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show file watchers</name>
				<script>displayFileWatchers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^fileWatchers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show event handlers</name>
				<script>displayEventHandlers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^events$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>killAll</name>
				<script>display(tempTimers)
display(tempTriggers)

for id, val in pairs(tempTimers) do
	killTimer(id)
end

for id, val in pairs(tempTriggers) do
	killTrigger(id)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^killAll$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>kill event</name>
				<script>killAnonymousEventHandler(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^killEvent (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>njs50-mage</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>casting</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>^fir(conflag)</name>
					<script>if (player.attack_spell ~= "conflagration") then
  cecho('\nSetting attack to &lt;red&gt;Conflagration\n\n')
  player.attack_spell = "conflagration"
  send('alias *k cast conflagration')
  -- send('assist -a conflagration')
  send('assist -a none')
  send('gstat switching to conflagration')
  player.attack_element = "fire"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(fire|Fire)</regex>
				</Alias>
				<Alias isActive="no" isFolder="no">
					<name>^fire (flame strike)</name>
					<script>if (player.attack_spell ~= "flame strike") then
  cecho('\nSetting attack to &lt;red&gt;Flame Strike\n\n')
  player.attack_spell = "flame strike"
  send('alias *k cast flame strike')
  -- send('assist -a flame strike')
  send('assist -a none')
  send('gstat switching to flame strike')
  player.attack_element = "fire"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(fire|Fire)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>flame strike</name>
					<script>if (player.attack_spell ~= "flame strike") then
  cecho('\nSetting attack to &lt;red&gt;Flame Strike\n\n')
  player.attack_spell = "flame strike"
  send('alias *k cast flame strike')
  -- send('assist -a flame strike')
  send('assist -a none')
  send('gstat switching to flame strike')
  player.attack_element = "fire"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^flame strike</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^probe</name>
					<script>if (player.attack_spell ~= "probe") then
  cecho('\nSetting attack to &lt;purple&gt;Probe!\n\n')
  player.attack_spell = "probe"
  send('alias *k cast probe')
  -- send('assist -a probe')
  send('assist -a none')
  send('gstat preparing to probe the next target')
  player.attack_element = "Probe"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^probe</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^acid</name>
					<script>if (player.attack_spell ~= "acid storm") then
  cecho('\nSetting attack to &lt;green&gt;Acid Storm\n\n')
  player.attack_spell = "acid storm"
  send('alias *k cast acid storm')
  -- send('assist -a acid storm')
  send('assist -a none')
  send('gstat switching to acid storm')
  player.attack_element = "acid"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(acid|Acid)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^elec</name>
					<script>if (player.attack_spell ~= "arc lightning") then
  cecho('\nSetting attack to &lt;yellow&gt;Arc Lightning\n\n')
  player.attack_spell = "arc lightning"
  send('alias *k cast arc light')
  -- send('assist -a arc light')
  send('assist -a none')
  send('gstat switching to arc lightning')
  player.attack_element = "elec"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(elec|Elec)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^chain</name>
					<script>if (player.attack_spell ~= "chain lightning") then
  cecho('\nSetting attack to &lt;yellow&gt;Chain Lightning\n\n')
  player.attack_spell = "chain lightning"
  send('alias *k chain lightning')
  -- send('assist -a chain lightning')
  send('assist -a none')
  send('gstat switching to chain lightning')
  player.attack_element = "chain"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(chain|Chain)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^kicker</name>
					<script>if (player.attack_spell ~= "nada &amp; bash") then
  cecho('\nSetting attack to &lt;purple&gt;kick\n\n')
  player.attack_spell = "nada"
  send('alias *k bash')
  -- send('assist -a bash')
  send('assist -a none')
  send('gstat switching to bash')
  player.attack_element = "kicker"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(kicker)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^cold</name>
					<script>if (player.attack_spell ~= "ice lance") then
  cecho('\nSetting attack to &lt;white&gt;Ice Lance\n\n')
  player.attack_spell = "ice lance"
  send('alias *k cast ice lance')
  -- send('assist -a ice lance')
  send('assist -a none')
  send('gstat switching to ice lance')
  player.attack_element = "cold"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(cold|Cold)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^magic</name>
					<script>if (player.attack_spell ~= "prismic missile") then
  cecho('\nSetting attack to &lt;purple&gt;Prismic Missile &lt;white&gt;prep some!!\n\n')
  player.attack_spell = "prismic missile"
  send('alias *k cast prismic missile')
  -- send('assist -a prismic missile')
  send('assist -a none')
  send('gstat switching to prismic missile')
  player.attack_element = "magic"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^magic</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^lb</name>
					<script>if (player.attack_spell ~= "lightning bolt") then
  cecho('\nSetting attack to &lt;yellow&gt;Lightning Bolt\n\n')
  player.attack_spell = "lightning bolt"
  send('alias *k cast lightning bolt')
  -- send('assist -a lightning bolt')
  send('assist -a none')
  send('gstat switching to lightning bolt')
  player.attack_element = "elec"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^lb</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^mist</name>
					<script>if (player.attack_spell ~= "mists of sleep") then
  cecho('\nSetting attack to &lt;purple&gt;Mists of Sleep\n\n')
  player.attack_spell = "mists of sleep"
  send('alias *k cast mists')
  -- send('assist -a mists')
  send('assist -a none')
  send('gstat switching to mists of sleep')
  player.attack_element = "Mind"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^mist$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^sleeper</name>
					<script>if (player.attack_spell ~= "sleep") then
  cecho('\nSetting attack to &lt;purple&gt;sleep\n\n')
  player.attack_spell = "sleep"
  send('alias *k cast sleep')
  send('assist -a sleep')
  send('gstat switching to sleep')
  player.attack_element = "sleeper"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^sleeper</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^acid blast</name>
					<script>if (player.attack_spell ~= "acid blast") then
  cecho('\nSetting attack to &lt;green&gt;Acid Blast\n\n')
  player.attack_spell = "acid blast"
  send('alias *k cast acid blast')
  -- send('assist -a acid blast')
  send('assist -a none')
  send('gstat switching to acid blast')
  player.attack_element = "acid"
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^acid blast</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>setup.mists.aliases</name>
					<script>for short, long in pairs(tfe.consts.exitmap) do
    -- tfe.consts.short[v] = k
		display(short)
		display(long) 
		
		local cmd = 'alias *' .. short .. 'm ' .. long .. ' &amp; cast mists'
		
		if (matches[2] ~= '') then  
			cmd = cmd .. ' &amp;' .. matches[2]
		end
		send(cmd)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^mists.setup(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>cast / move / kill</name>
					<script>

local dir = tfe.consts.exitmap[matches[2]]
local exit = murder.exits[dir]

local exit = murder.exits[dir]


if (exit and exit.firstTarget) then

  local mobData = probe.getMobData(exit.firstTarget)
  
  send('gt next is ' .. exit.firstTarget)

  if(mobData ~= nil) then
		
		expandAlias(probe.getBestElement(mobData))
		send(dir .. ' &amp; cast ' .. player.attack_spell .. ' ' .. mobData.dotName .. ' &amp; cast ' .. player.attack_spell)

		
  else
  	send(dir .. ' &amp; cast probe ' .. exit.firstTarget)
		
		common.onNextEvent(probe.events.MOB_PROBED, function(evt, mobData)
			-- cecho('\n\n&lt;red
			expandAlias(probe.getBestElement(mobData))
			send('+cast ' .. player.attack_spell .. ' ' .. mobData.dotName .. ' &amp; cast ' .. player.attack_spell)

  	end)	
				
  end
	
	

else
	
	cecho('&lt;orange&gt;cast-kill-move: &lt;white&gt;no mob found')
	send('scan')
	
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^c([neswud])$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>probe</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>sleep mode</name>
					<script>if (matches[2] == 'on') then
	probe.mode = 'sleep'
else
	probe.mode = 'standard'
end

cecho('\n\n&lt;green&gt;SLEEP MODE: &lt;white&gt;' .. matches[2] .. '\n\n')</script>
					<command></command>
					<packageName></packageName>
					<regex>^sleepMode (on|off)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>check resists</name>
					<script>
local mobData = probe.getMobData(matches[2])


if(mobData) then

	display(mobData)
	
	local element = probe.getBestElement(mobData)
	
	cecho('&lt;green&gt;MOB DB: &lt;white&gt;mob found: ' .. mobData.name .. ', element: ' ..  element .. '\n')
	display(mobData)
	
else
	cecho('\n\n&lt;yellow&gt;MOB DB: &lt;white&gt;mob not found: ' .. matches[2] .. '\n')
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^check (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>reset resists</name>
					<script>
local mobData = probe.getMobData(matches[2])


if(mobData) then

	display(mobData)
  db:delete(probe.db.mob, mobData._row_id)

else
	cecho('\n\n&lt;yellow&gt;MOB DB: &lt;white&gt;mob not found: ' .. matches[2] .. '\n')
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^reset-mob (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>set sleepable</name>
					<script>
local mobData = probe.getMobData(matches[2])


if(mobData) then

	display(mobData)
	
	local element = probe.getBestElement(mobData)
	
	if (matches[3] == true) then
		mobData.canSleep = 1
	else
		mobData.canSleep = 0
	end
	
	db:update(probe.db.mob, mobData)
	
	cecho('&lt;green&gt;MOB DB: &lt;white&gt;mob updated: ' .. mobData.name .. ', sleepable: ' ..  matches[3] .. '\n')
	
else
	cecho('\n\n&lt;yellow&gt;MOB DB: &lt;white&gt;mob not found: ' .. matches[2] .. '\n')
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^sleepable (.*) (true|false)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>prep etc</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>sleep|rest</name>
					<script>generic.equipSleep(matches[2])	
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(sl|rest)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>generic.equipStand()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(st)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFree</name>
					<script>local cmd = matches[3]

generic.prepFree()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(prepFree|pfree)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFull</name>
					<script>local cmd = matches[2]

generic.prepFull()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^upp$</name>
					<script>
player.gettingFull = false

expandAlias('st')</script>
					<command></command>
					<packageName></packageName>
					<regex>^upp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group check and prep</name>
					<script>common.groupPrepIfUnder({ 
  mana = 50,
  heals = 1000,
  storms = 3,
  -- type = "full",
  callback = function()
  
  end,
})</script>
					<command></command>
					<packageName></packageName>
					<regex>^gc$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>get ready</name>
					<script>send('gstat ready (' .. player.name .. ')')
</script>
					<command></command>
					<packageName></packageName>
					<regex>^getReady$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>njs50-druid</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>storm</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>post-storm-check</name>
					<script>
player.postStormCheck()

</script>
					<command></command>
					<packageName></packageName>
					<regex>^p$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>storm</name>
					<script>
local cmd = ''
local lhs = matches[2]
local rhs = matches[3]
local mc = false

if (matches[2] ~= '') then
  cmd = rex.gsub(lhs, [[ &amp; $]], '')
  expandAlias(cmd)
  if (rex.find(cmd, [[(?i)^(n|e|s|w|u|d|north|east|south|west|up|down)\b]])) then
    cecho('\n&lt;green&gt;STORM:&lt;white&gt; moving and casting, fancy!\n')
    player.ss.casting = nil
    player.ss.storm_active = nil
    mc = true
  end
end

if not (player.ss.move_cast) then
  if (mc) then 
    player.ss.move_cast = true
  end
  player.ss.cast()  
else
  cecho('\n&lt;green&gt;STORM:&lt;white&gt; moving and only casting once!\n')
end


-- cecho('&lt;green&gt;storm&lt;reset&gt;')

if (rhs ~= '') then
  cmd = rex.gsub(rhs, [[^ &amp; ]], '')
  expandAlias(cmd)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>(?i)^(.* &amp; |)storm(| &amp; .*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>move + storm</name>
					<script>expandAlias(matches[2] .. ' &amp; storm')</script>
					<command></command>
					<packageName></packageName>
					<regex>^s([neswud])$</regex>
				</Alias>
			</AliasGroup>
			<Alias isActive="yes" isFolder="no">
				<name>up - in a hurry!</name>
				<script>cecho('\n&lt;green&gt;TEAMWORK: &lt;white&gt;command to stand!')

player.gettingFull = nil

send('stand')
resetGear()

-- cancel any prep timers/triggers

if (common.checkFullTimer) then 
	common.checkFullTimer()
	common.checkFullTimer = nil
end

druid.stand(function ()
	send('gstat Ready (' .. player.name .. ')')
	druid.reportMana()
end)

</script>
				<command></command>
				<packageName></packageName>
				<regex>^upp$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>stand</name>
				<script>druid.stand()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(st)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>sleep|rest</name>
				<script>druid.rest(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(sl|rest)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>get ready</name>
				<script>player.postStormCheck(function()
  send('gstat ready (' .. player.name .. ')')
end)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^getReady$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^prepFree</name>
				<script>local cmd = matches[3]

druid.prepFree(function()
  expandAlias('gstat ready (' .. player.name .. ')')
end)</script>
				<command></command>
				<packageName></packageName>
				<regex>^(prepFree|pfree)\s?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^prepFull</name>
				<script>local cmd = matches[2]

druid.getFull(function()
  expandAlias('gstat ready (' .. player.name .. ')')
end)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(pfull|prepFull)\s?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>improveNonCombat</name>
				<script>druid.improveNonCombat()</script>
				<command></command>
				<packageName></packageName>
				<regex>^improveNonCombat$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>resetDruidSpellImproves</name>
				<script>improves.spellList = {
  'dry',
  -- 'desiccate',
  'gale',
  -- 'blaze',
  'gloom',
  -- 'earthen fist',
  -- 'undergrowth',
  -- 'whirlwind',
  
  -- prob only want at 7
  -- 'aqueous spirit',
  -- 'healing rain',
  
  -- AOE no target required section
  -- 'impede',
  -- 'squall',
  -- 'storm', 
  -- 'anemogenesis',
  -- 'xerotes',
  -- 'healing rain',
  -- 'healing rain',
  -- 'tornado',
  -- 'tempest',
  
  'aqueous surge',
  'viper nest',
  
}</script>
				<command></command>
				<packageName></packageName>
				<regex>^rdsi$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>improve aqua spell</name>
				<script>
local spell = 'aqueous surge'

if (player.skills[spell] &lt; 7) then

  send('stand &amp; rem diam.ring &amp; queue wea diam.ring &amp; queue cast ' .. spell .. ' self &amp; queue drink cauldron &amp; queue sit couch &amp; queue sleep')
    
else
    
  cecho('\n\n&lt;green&gt; ' .. spell .. ' is maxxed(ish), hooray!\n')
end


</script>
				<command></command>
				<packageName></packageName>
				<regex>^imp-aqua$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>go to druid ways</name>
				<script>local dest = matches[2]
druid.landwalk(function()
  if (dest ~= '') then
    expandAlias('go ' .. dest)
  end
end)</script>
				<command></command>
				<packageName></packageName>
				<regex>^gw ?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>timecheck</name>
				<script>
local sleepTrig = tempRegexTrigger([[^You cannot do that while sleeping\.$]], function()
  send('stand &amp; observe &amp; sleep')
end, 1)

tempRegexTrigger([[^=\s+(\S.*?)\s+\|\s*(\S.*?)\s*=]], function()
  display(matches[2], matches[3])
  killTrigger(sleepTrig)
end,1)
send('observe')
</script>
				<command></command>
				<packageName></packageName>
				<regex>timecheck</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>xerotes</name>
				<script>if player.skills.xerotes and 
   player.skills.xerotes &gt;= 10 and 
   not druid.skipXerotes[gmcp.Room.Info.wind] and
   not player.disableXerotes
then
  cecho('\n\n&lt;green&gt;XEROTES:&lt;white&gt; recasting xerotes as wind was: ' .. gmcp.Room.Info.wind  .. '\n\n')
  send('cast xerotes')
end
</script>
				<command></command>
				<packageName></packageName>
				<regex>^xerotes</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>farscan</name>
				<script>-- first check if we need to re-up BM
common.getAffects( function (affects)
  if (not affects["You can see a great distance."]) then
    common.getReagents('a shard of glass', 1, function()
      send('cast far-sight')
    end)
  end
end)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^farscan$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>unhide</name>
				<script>player.unhide = true
send('unhide')

common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
  player.unhide = nil
end)</script>
				<command></command>
				<packageName></packageName>
				<regex>^unhide$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>tranquility</name>
				<script>send('cast tranquility')</script>
				<command></command>
				<packageName></packageName>
				<regex>^tranquility$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>respell</name>
				<script>local target = matches[2] or 'gstat'

if (target == '') then target = 'gstat' end

if (player.gear.nearby and 
    player.gear.nearby.base and 
    player.gear.nearby.base.item == "obstruction of darkflies") then
    send('look obstr.darkflies')
end


-- send('|perform rite of delumination')    

njs50.respell(player.buffs, {
  target = target, 
  callback = function()
    druid.reportMana()
    send(target .. ' respell complete')
  end
})

-- expandAlias('xerotes')
</script>
				<command></command>
				<packageName></packageName>
				<regex>^respell ?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>light</name>
				<script>cecho('\n----------------------------------------\n')
cecho('Spell|wind |dry  |shad |sun  |earth|aqua\n')
cecho('----------------------------------------\n')
cecho('none |Phy  |Phy  |Cold |Fire |Phy  |Phy\n')
cecho('----------------------------------------\n')
cecho('Flame|Phy  |&lt;yellow&gt;ELEC&lt;reset&gt; |Cold |&lt;red&gt;BOOST&lt;reset&gt;|Phy  |Phy\n')
cecho('----------------------------------------\n')
cecho('Earth|&lt;orange&gt;SONIC&lt;reset&gt;|&lt;red&gt;FIRE&lt;reset&gt; |Cold |Fire |&lt;white&gt;BOOST&lt;reset&gt;|Phy\n')
cecho('----------------------------------------\n')
cecho('Dark |&lt;cyan&gt;COLD&lt;reset&gt; |Phy  |&lt;cyan&gt;BOOST&lt;reset&gt;|Fire |Phy  |Phy\n')
cecho('----------------------------------------\n')
cecho('Cloy |Phy  |Phy  |&lt;purple&gt;MIND&lt;reset&gt; |Fire |&lt;red&gt;FIRE&lt;reset&gt; |&lt;green&gt;ACID&lt;reset&gt;\n')
cecho('----------------------------------------\n\n')</script>
				<command></command>
				<packageName></packageName>
				<regex>^light$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>njs50-cleric</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="no" isFolder="no">
				<name>filler</name>
				<script>local spell = 'restor'
local item = 'crude.skirt,flow.ankl,fae.shie'

send('stand &amp; queue prep ' .. spell .. ' &amp; remove ' .. item .. ' &amp; wait 1 &amp; queue queue wear ' .. 
      item .. ' &amp; queue cast ' .. spell .. ' &amp; sit couch &amp; sleep'  )</script>
				<command></command>
				<packageName></packageName>
				<regex>^filler$</regex>
			</Alias>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>prep etc</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>prep-set</name>
					<script>
if (matches[2] == 'start') then
	
	cleric.prepStart( function() 
		cecho('prep started...')
	end)
	
	

else

	cleric.prepEnd( function () 
		cecho('prep done...')
	end)

end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^prep (start|end)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>sleep|rest</name>
					<script>cleric.equipSleep(matches[2])	
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(sl|rest)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>cleric.equipStand()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(st)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFree</name>
					<script>local cmd = matches[3]

cleric.prepFree()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(prepFree|pfree)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="no" isFolder="no">
					<name>^prepFull w/buff improves</name>
					<script>local cmd = matches[2]


njs50.respell(player.buffs, {
  target = 'gstat', 
  cancelLeechForImproves = true,
  callback = function()
    cleric.prepFull()
  end,
  failCallback = function()
    send('gstat unable to full respell')
    send('gstat ready (' .. player.name .. ')')
  end, 
})
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFull</name>
					<script>local cmd = matches[2]

cleric.prepFull()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^upp$</name>
					<script>
player.gettingFull = false
common.killPrep()
expandAlias('st')</script>
					<command></command>
					<packageName></packageName>
					<regex>^upp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>get ready</name>
					<script>cleric.getReady()</script>
					<command></command>
					<packageName></packageName>
					<regex>^getReady$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>respell</name>
					<script>
local target = matches[2] or 'gstat'

if (target == '') then target = 'gstat' end

njs50.respell(player.buffs, target)
</script>
					<command></command>
					<packageName></packageName>
					<regex>^respell ?(.*)$</regex>
				</Alias>
			</AliasGroup>
			<Alias isActive="yes" isFolder="no">
				<name>gsummon</name>
				<script>
common.onNextEvent(njs50.scanner.events.SCAN_PROCESSED, function()
  
  local roomContains = njs50.scanner.exits['[Here]'] or {}

  local needsSummon = {}

  for name, details in pairs(gmcp.Group.members) do
      
      -- display(roomContains, name)
      local missing = true
      for idx, unit in pairs(roomContains) do
      
        if unit.raw == name then
          missing = false
          break
        end
      
      end
      
      
      if (missing) then
        table.insert(needsSummon, name)
      end
  
  end
      
 if #needsSummon &gt; 0 then
  send('gstat summoning these useless fuckers: ' .. table.concat(needsSummon, ', '))

 end     
      
      
  local summon 
  local idx = 0
  
  summon = function (cb)
  
    if (idx == #needsSummon) then
    
      tempTimer(1, function()
        send('gstat group summon complete!')
      end)
      
    else
    
      idx = idx + 1
    
      njs50.cast('summon', { 
        target = needsSummon[idx],
        failCallback = function(err)
          send('gstat ' .. err)
        end,
        callback = summon
      })    
    
    end
  
  end
  
  summon()
  
end)


send('scan')</script>
				<command></command>
				<packageName></packageName>
				<regex>^gsum(mon)?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>njs50-paladin</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>prep etc</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>prep-set</name>
					<script>
if (matches[2] == 'start') then
	
	paladin.prepStart( function() 
		cecho('prep started...')
	end)
	
	

else

	paladin.prepEnd( function () 
		cecho('prep done...')
	end)

end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^prep (start|end)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>sleep|rest</name>
					<script>paladin.equipSleep(matches[2])	
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(sl|rest)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>paladin.equipStand()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(st)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFree</name>
					<script>local cmd = matches[3]

paladin.prepFree()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(prepFree|pfree)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFull</name>
					<script>local cmd = matches[2]

paladin.prepFull()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^upp$</name>
					<script>
player.gettingFull = false
expandAlias('st')</script>
					<command></command>
					<packageName></packageName>
					<regex>^upp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group check and prep</name>
					<script>common.groupPrepIfUnder({ 
  mana = 50,
  heals = 1000,
  storms = 3,
  -- type = "full",
  callback = function()
  
  end,
})</script>
					<command></command>
					<packageName></packageName>
					<regex>^gc$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>get ready</name>
					<script>njs50.respell(player.buffs, {
  target = 'gstat', 
  callback = function()
    send('gstat ready (' .. player.name .. ')')
  end,
  failCallback = function()
    send('gstat unable to full respell')
    send('gstat ready (' .. player.name .. ')')
  end, 
})</script>
					<command></command>
					<packageName></packageName>
					<regex>^getReady$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>njs50-warrior</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>prep etc</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>sleep|rest</name>
					<script>generic.equipSleep(matches[2])	
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(sl|rest)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>generic.equipStand()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(st)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFree</name>
					<script>local cmd = matches[3]

generic.prepFree()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(prepFree|pfree)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFull</name>
					<script>local cmd = matches[2]

generic.prepFull()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^upp$</name>
					<script>
player.gettingFull = false

expandAlias('st')</script>
					<command></command>
					<packageName></packageName>
					<regex>^upp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group check and prep</name>
					<script>common.groupPrepIfUnder({ 
  mana = 50,
  heals = 1000,
  storms = 3,
  -- type = "full",
  callback = function()
  
  end,
})</script>
					<command></command>
					<packageName></packageName>
					<regex>^gc$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>get ready</name>
					<script>send('gstat ready (' .. player.name .. ')')
</script>
					<command></command>
					<packageName></packageName>
					<regex>^getReady$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>njs50-reaver</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>prep etc</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>sleep|rest</name>
					<script>reaver.equipSleep(matches[2])	
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(sl|rest)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>reaver.equipStand()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(st)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFree</name>
					<script>local cmd = matches[3]

reaver.prepFree()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(prepFree|pfree)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFull</name>
					<script>local cmd = matches[2]

reaver.prepFull()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^upp$</name>
					<script>
player.gettingFull = false

expandAlias('st')</script>
					<command></command>
					<packageName></packageName>
					<regex>^upp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group check and prep</name>
					<script>common.groupPrepIfUnder({ 
  mana = 50,
  heals = 1000,
  storms = 3,
  -- type = "full",
  callback = function()
  
  end,
})</script>
					<command></command>
					<packageName></packageName>
					<regex>^gc$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>get ready</name>
					<script>reaver.getReady()</script>
					<command></command>
					<packageName></packageName>
					<regex>^getReady$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>respell</name>
					<script>local target = matches[2] or 'gstat'

if (target == '') then target = 'gstat' end
      
expandAlias('check weapons')

-- send('|perform rite of delumination')    

njs50.respell(player.buffs, {
  target = target, 
  callback = function()
    -- mojune.reportMana()
    -- send('gstat respell complete')
  end
})

-- expandAlias('xerotes')
</script>
					<command></command>
					<packageName></packageName>
					<regex>^respell ?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>check weapons</name>
					<script>

local getWeaponAffects = function(weapon, cb)

  local weapTrig  = timedTempTrigger(10, 1, [[^You look at (.*) you are (holding|wielding)\.$]], function()
  
    if (matches[3] == 'wielding') then

      
      -- missing the cleric holy weapon thing
      local affects = {
        ['acid-dripping'] = matches[2]:find('acid-dripping') ~= nil,
        ['spiteful'] = matches[2]:find('spiteful') ~= nil,
        ['jinxing'] = matches[2]:find('jinxing') ~= nil,
        ['flaming'] = matches[2]:find('flaming') ~= nil,
        ['frost-covered'] = matches[2]:find('frost-covered') ~= nil,
      }
    
      cb(affects)
    
    else
    
      cb()
    
    end 
  
  end)
    
  send('look ' .. common.dotCase(weapon))

end


local needMalediction = function(cb)
  
  if not player.skills['rite of malediction'] then
    if player.skills['rite of jinxing'] then
      send('perform rite of jinxing')
    end
    return
  end
  
  local rhWeap = player.gear["right hand"].base.item
  getWeaponAffects(rhWeap, function(affects)
  
  
    if (affects and affects.spiteful == false) then
      cb(true)
    else
    
      if (player.gear["left hand"] and player.gear["left hand"].base) then
        
        -- need to wait til the current line is done processing
        tempTimer(0, function()
          local lhWeap = player.gear["left hand"].base.item
          getWeaponAffects(lhWeap, function(affects)            
            if (affects and not affects.spiteful) then
              cb(true)
            else
              cb(false)
            end
          end)
        end)
      
      end
    
    end
  
  end)
end

if (player.weaponBuffs ~= false) then

  needMalediction(function(bCast)
  
    local spell = 'rite of malediction'
  
    if player.skills['rite of imprecation'] and player.skills['rite of imprecation'] &gt; 0 then 
      spell = 'rite of imprecation'
    end
  
    if (bCast) then
      send('|perform ' .. spell)
    end
  end)
  
end


-- You look at a spiteful, jinxing bloody meat cleaver +3 you are wielding.
-- You look at a runed spiteful, jinxing mithril hand axe 'Vengeance' +3 you are wielding.

-- You look at (.*) you are wielding.</script>
					<command></command>
					<packageName></packageName>
					<regex>^check weapons$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>njs50-legate</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>prep etc</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>sleep|rest</name>
					<script>legate.equipSleep(matches[2])	
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(sl|rest)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>legate.equipStand()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(st)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFree</name>
					<script>local cmd = matches[3]

legate.prepFree()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(prepFree|pfree)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^prepFull</name>
					<script>local cmd = matches[2]

legate.prepFull()</script>
					<command></command>
					<packageName></packageName>
					<regex>^(pfull|prepFull)\s?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^upp$</name>
					<script>
player.gettingFull = false

expandAlias('st')</script>
					<command></command>
					<packageName></packageName>
					<regex>^upp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group check and prep</name>
					<script>common.groupPrepIfUnder({ 
  mana = 50,
  heals = 1000,
  storms = 3,
  -- type = "full",
  callback = function()
  
  end,
})</script>
					<command></command>
					<packageName></packageName>
					<regex>^gc$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>get ready</name>
					<script>legate.getReady()</script>
					<command></command>
					<packageName></packageName>
					<regex>^getReady$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>^init-profile$</name>
			<script>
saveProfile()

-- uninstall the generic mapper
uninstallPackage("generic_mapper")
uninstallPackage("tfe-mapper")

njs50plev = njs50plev or {}

njs50plev.finishInstall = function()

  common.initPlayer()

  tempTimer(2, function()



    send('color columns 300')
    send('color lines 150')
    expandAlias("setOption Auto.Assist true")
    expandAlias("setOption Numeric true")
    expandAlias("setOption Numerical.Damage true")
    expandAlias("setOption Auto.Assist true")
    expandAlias("setOption Join.Fight true")
    expandAlias("setOption Show.Language false")
    
    -- send('scan -o enable.autoscan')

    
    send('opt room.info 1')
    
    -- configure auto scan
    expandAlias('set scan option Enable.Autoscan true')
    expandAlias('set scan option Autoscan.Towns true')
    expandAlias('set scan option Autoscan.Current.Room true')
    expandAlias('set scan option Ignore.Wordwrap true')
    expandAlias('set scan option Autoscan.Shows.Empty true')


    -- set prompt

    send("prompt ?p' -- MORE -- '&amp;lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&amp;gt;%\\")

    -- setup aliases
    send('alias *ef eat food')
    send('alias *dw drink ' .. player.vessel)
    
    -- create a default gear set if it doesn't exist
    if (not player.gearSets or not player.gearSets.default) then
		  saveGearSet('default')
    end
    
  end)

  tempTimer(5, function()
    cecho("\n\n&amp;lt;green&amp;gt;INSTALL: &amp;lt;white&amp;gt;Install complete?! - it might be a good idea to restart mudlet\n\n\n")
  end)

 end


-- download and install latest tfe mapper
local URL = "https://raw.githubusercontent.com/njs50/tfe-mapper/master/tfe-mapper.xml"
common.onNextEvent("sysDownloadDone", function (_, f)
  if not f:find("tfe-mapper", 1, true) then
    return
  end
  uninstallPackage("tfe-mapper")
  tempTimer(2, function()
    if not table.contains(getModules(), "tfe-mapper") then
      installPackage(f)
    end
    os.remove(f)
    cecho("&amp;lt;lime_green&amp;gt;Package installed!\n")

    -- install map
    -- download and install latest tfe mapper
      local URL = "https://github.com/njs50/tfe-mapper/raw/master/njs50-comprehensive-map.dat"
      common.onNextEvent("sysDownloadDone", function (_, f)
        if not f:find("njs50-comprehensive-map", 1, true) then
          return
        end
        local loadOK = loadMap(f)
        if not loadOK then
         cecho("&amp;lt;red&amp;gt;INSTALL: &amp;lt;white&amp;gt;Couldn't load - was the mapper open? :(\n")
        else
          cecho("&amp;lt;green&amp;gt;INSTALL: &amp;lt;white&amp;gt;Loaded fine!\n")
        end
        os.remove(f)

        -- install dark theme
        local downloaded_package = function(a,b)
          if not b:find("DarkTheme",1,true)then return end
          installPackage(b)
          os.remove(b)

          njs50plev.finishInstall()

        end

        common.onNextEvent("sysDownloadDone", downloaded_package)
    
        downloadFile(getMudletHomeDir().."/DarkTheme.mpackage","https://raw.githubusercontent.com/njs50/njs50-plev/master/DarkTheme.mpackage")

      end)
      downloadFile(getMudletHomeDir()..(URL:ends("dat") and "/njs50-map.dat"), URL)
  end)

end)
downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/tfe-mapper.xml" or "/tfe-mapper.zip"), URL)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^init-profile$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>search helpers</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>meteorite_alias</name>
				<script>murder.area.we.search_meteor()</script>
				<command></command>
				<packageName></packageName>
				<regex>^meteorite_alias$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>common (must be first)</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>common</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common = common or {}
player = player or {}
roomInfo = roomInfo or {}
group = group or {
	combat = false
}

common.damState = {
 ['perfect health'] = 1,
 ['perfect'] = 1,
 ['slightly scratched'] = 0.95,
 ['scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['bruised'] = 0.85,
 ['some cuts'] = 0.75,
 ['cut'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['nastily wounded'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['dying'] = 0,
 ['DEAD!'] = 0
}

common.damStateInverse = {
 ['1']    = 'perfect health',
 ['0.95'] = 'scratched',
 ['0.85'] = 'bruised',
 ['0.75'] = 'cut',
 ['0.65'] = 'several wounds',
 ['0.55'] = 'wounded',
 ['0.45'] = 'nastily wounded',
 ['0.35'] = 'bleeding freely',
 ['0.25'] = 'covered in blood',
 ['0.15'] = 'leaking guts',
 ['0.10'] = 'mostly dead',
 ['0']    = 'fucked'
}




common.tableHasValue =  function (tab, val)
  for index, value in ipairs(tab) do
    if tab[index] == val then
    	return true
    end
  end
  return false
end


common.sendToChan = function(chan, msg)

  if (not chan or chan == 'cecho') then   
    cecho(msg .. '\n')
  else
    msg = rex.gsub(msg, [[(&lt;[^&gt;]+&gt;)]], '')
    
    msgs = msg:split('\n')
    for idx, m in ipairs(msgs) do
      if (m == '') then
        m = '.'
      end
      send(chan .. ' ' .. m)
    end
  end

end

common.tfeItemListAdd = function (list, item)

	local idx = 0
	local match = nil

	-- see if this value is already in the list
	for index, value in ipairs(list) do
		match = rex.match(value, '^(\\d+)?\\*?' .. item .. '$')
    if match ~= nil then
    	idx = index
			break
    end
  end

	--  if we found a match, see how many of this item are already in the list
	if (idx &gt; 0) then
		local count = 1
		if (match ~= false) then
			count = tonumber(match)
		end
		count = count + 1
		list[idx] = tostring(count) .. '*' .. item
	else -- this is a new item
		table.insert(list, item)
	end

	return list
end

common.reverseList = function(list)

	local i = 1
	local j = #list

	while i &lt; j do
		list[i], list[j] = list[j], list[i]
		i = i + 1
		j = j - 1
	end

	return list

end


common.setParryState = function (state, reason, callback, permanent)

	local cb = callback

	player.parryQueue = player.parryQueue or 0

  -- if we have queued parry changes defer until they have all happened
  if (player.parryQueue &gt; 0) then
    common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
  		  common.setParryState(state, reason, callback, permanent)
    end)
    return
  end

	local currentState = player.parry

	if (player.parryRevertTimer) then
		killTimer(player.parryRevertTimer)
		player.parryRevertTimer = nil
	end


	-- if we need to swap opt parry
	if (currentState ~= state) then

  	-- if we are turning parry on, make sure we have a plan to turn it off again
  	if (not permanent and state) then
  		player.parryRevertTimer = tempTimer(15, function ()
  			if (player.parry) then
  				common.setParryState(false, 'opt parry has been on too long!')
  			end
  		end)
  	end

  	cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - ' .. reason or '?' .. '\n')
  	send('opt parry')
		player.parryQueue = player.parryQueue + 1
    cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

  	common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
      cecho('\n&lt;green&gt;PARRY: &lt;white&gt;state change happened!\n')
  		if (cb) then cb() end
    end)

	else
		cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - skipping as no change needed\n')
		if (cb) then cb() end
	end

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>events</name>
				<packageName></packageName>
				<script>
common.events = {
  PARSED_PROMPT = 'COMMON::parsed_prompt',
  PARSED_EXITS = 'COMMON::parsed_room_exits',
  PARSED_SCORE = 'COMMON::parsed_score_page',
  PARSED_GROUP = 'COMMON::parsed_group_status',
  PARSED_ABILITIES = 'COMMON::parsed_player_abilities',
  PARSED_AFFECTS = 'COMMON::parsed_player_affects',
  PARSED_INVENTORY = 'COMMON:parsed_inventory_contents',
  PARSED_PREPARED = 'COMMON:parsed_prepared_spells',
  PARSED_EQUIPMENT = 'COMMON:parsed_equipment',
  PARSED_WHO = 'COMMON::parsed_who',
  CHANGED_EQUIPMENT = 'COMMON:changed_equipment',
  MOVE_DETECTED = 'COMMON::move_detected',
  ROOM_CHANGED = 'COMMON::room_changed',
  COMBAT_ENDED = 'COMMON::combat_ended',
  COMBAT_STARTED = 'COMMON::combat_started',
  COMBAT_ATTACK = 'COMMON::combat_attack',
  COMBAT_PLAYER_HIT = 'COMMON::combat_player_hit',
  WALK_DONE = 'COMMON::speedwalk_completed',
  ROOM_CLEAR = 'COMMON::current_room_is_clear',
  PARRY_STATE_CHANGE = 'COMMON::parry_state_change',
  SCAN_PROCESSED = 'COMMON::scan_data_processed',
  UI_LOADED = 'COMMON:UI_loaded',
  PARSED_GMCP_GROUP = 'COMMON:parsed_gmcp_group_data',
  CAST_STARTED = 'COMMON:spell_cast_started',
  ASSIST_SET = 'COMMON:assist_set',
  FIGHTING_UPDATE = 'COMMON:gmcp_fighting_updated',
  FIGHTING_TARGET_UPDATE = 'COMMON:gmcp_fighting_target_updated',
  MOBS_JOINED_COMBAT = 'COMMON:gmcp_fighting_mob_added',
  MOB_JOINED_COMBAT = 'COMMON:trigger_fighting_mob_added',
  MOB_LEFT_COMBAT = 'COMMON:trigger_fighting_mob_left',
  MOB_ENTERED_ROOM = 'COMMON:trigger_mob_entered_room',
  MOB_LEFT_ROOM = 'COMMON:trigger_mob_left_room',
  MOB_BLOCKED_EXIT = 'COMMON:trigger_mob_blocked_exit'
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>debug helpers</name>
				<packageName></packageName>
				<script>-- preserve functions we are about to decorate
oKillTimer = oKillTimer or killTimer
oTempTimer = oTempTimer or tempTimer
oTempRegexTrigger = oTempRegexTrigger or tempRegexTrigger
oTempTrigger = oTempTrigger or tempTrigger
oTempPromptTrigger = oTempPromptTrigger or tempPromptTrigger

oRaiseEvent = oRaiseEvent or raiseEvent
oRegisterAnonymousEventHandler = oRegisterAnonymousEventHandler or registerAnonymousEventHandler
oKillAnonymousEventHandler = oKillAnonymousEventHandler or killAnonymousEventHandler

oAddFileWatch = oAddFileWatch or addFileWatch
oRemoveFileWatch = oRemoveFileWatch or removeFileWatch

eventHandlers = eventHandlers or {}

fileWatchers = fileWatchers or {}

addFileWatch = function(path)  
  if (fileWatchers[path]) then
    cecho('\n&lt;red&gt;DEBUG: &lt;white&gt;tried to add a duplicate file watch - ' .. path .. '\n')
    return nil
  end
  fileWatchers[path] = true
  return oAddFileWatch(path)
end

removeFileWatch = function(path)
  fileWatchers[path] = nil
  return oRemoveFileWatch(path)
end


displayFileWatchers = function()
  display(table.keys(fileWatchers))
end

function registerAnonymousEventHandler(evt, fn, selfDestruct)

	local thisData = {
		handlerId = 0,
		thisEvt = evt,
		lcb = fn,
	}

  local callback

	if (type(thisData.lcb) == 'string') then
  		callback = thisData.lcb
		cecho('\n&lt;orange&gt;EVENT: &lt;white&gt;warning: event handler defined as string - ' .. thisData.lcb ..  '\n')
	else
		callback = function (...)
    		local cb = thisData.lcb
    		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;event handler triggered - ' .. tostring(thisData.handlerId) .. ' : ' .. thisData.thisEvt .. '\n')
				-- display(arg)
    		return cb(unpack(arg))
    	end
	end

	thisData.handlerId = oRegisterAnonymousEventHandler(evt, callback, selfDestruct)
	eventHandlers[thisData.handlerId] = evt

	return thisData.handlerId

end

function killAnonymousEventHandler(id)

	if (eventHandlers[id] ~= nil) then
		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;killed handler - ' .. tostring(id) .. ' : ' .. eventHandlers[id] .. '\n')
		eventHandlers[id] = nil
	else
		-- cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing event handler - ' .. id .. '\n')
	end

	return oKillAnonymousEventHandler(id)

end

function killAnonymousEventHandlerByName(name)
  for i, k in pairs(eventHandlers) do 
    if (k == name) then
      cecho('\n&lt;green&gt;EVENT: &lt;white&gt;killed handler - ' .. tostring(i) .. ' : ' .. k .. '\n')
      killAnonymousEventHandler(i)
    end
  end
end


-- allow us to track raised events
function raiseEvent(...)
	-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;raised - ' .. arg[1] .. '\n')
	return oRaiseEvent(unpack(arg))
end

function displayEventHandlers()
	display(eventHandlers)
end


-- triggers

local oKillTrigger = oKillTrigger or killTrigger
tempTriggers = tempTriggers or {}

tempPromptTrigger = function(oCode, expires, desc)

  desc = desc or 'mystery prompt trigger'
  
  local trigId

  if (type(oCode) == 'string') then
    -- cecho('\n\n&lt;orange&gt;WARNING:&lt;white&gt; timer code, is not a function: ' .. oCode .. '\n\n')
    oCode = loadstring(oCode)
  end    

	local newCode = function (...)

		if (tempTriggers[trigId]) then
    		tempTriggers[trigId].calls = tempTriggers[trigId].calls + 1
    		if (tempTriggers[trigId].calls == expires) then
  	  			tempTriggers[trigId] = nil
    			-- cecho('\n&lt;orange&gt;trigger died of natural causes - ' .. trigId .. ' : ' .. regex .. '\n')
    		end
		end

		return oCode(...)
	end

	trigId = oTempPromptTrigger(newCode, expires)

	tempTriggers[trigId] = tempTriggers[trigId] or { calls = 0, regex = desc }

	return trigId
  

end


local wrapTrigger = function (triggerCommand)

	local oCommand = triggerCommand

	return function (regex, code, expireAfter)

  	local trigId = nil
  	local oCode = code
  	local expires = expireAfter
    
  if (type(oCode) == 'string') then
    -- cecho('\n\n&lt;orange&gt;WARNING:&lt;white&gt; timer code, is not a function: ' .. oCode .. '\n\n')
    oCode = loadstring(oCode)
  end    

  	local newCode = function (...)

			if (tempTriggers[trigId]) then
      		tempTriggers[trigId].calls = tempTriggers[trigId].calls + 1
      		if (tempTriggers[trigId].calls == expires) then
    	  			tempTriggers[trigId] = nil
      			-- cecho('\n&lt;orange&gt;trigger died of natural causes - ' .. trigId .. ' : ' .. regex .. '\n')
      		end
			end

  		return oCode(...)
  	end

  	trigId = oCommand(regex, newCode, expires)

  	tempTriggers[trigId] = tempTriggers[trigId] or { calls = 0, regex = regex }

  	return trigId
  end


end



tempRegexTrigger = wrapTrigger(oTempRegexTrigger)
tempTrigger = wrapTrigger(oTempTrigger)



killTrigger = function(id)
	if (tempTriggers[id] ) then
		tempTriggers[id] = nil
	end
	return oKillTrigger(id)
end

displayTempTriggers = function()
	display(tempTriggers)
end


-- timers



tempTimers = tempTimers or {}

tempTimer = function(seconds, code, repeating, description)
  
  if (type(repeating) == 'string') then
    description = repeating
    repeating = false
  end

  -- repeating being nil breaks mudlet :-[
  if (not repeating) then
    repeating = false
  end


	local timerId

	local oCode = code

  if (type(oCode) == 'string') then
    -- cecho('\n\n&lt;orange&gt;WARNING:&lt;white&gt; timer code, is not a function: ' .. oCode .. '\n\n')
    oCode = loadstring(oCode)
  end

	local decoratedCode = function (...)
		-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer ran - ' .. tostring(timerId)  .. ' : ' .. (tempTimers[timerId] or '???') .. '\n')
		-- display(tempTimers)
    -- rabies. next to check if oCode is a string and eval it or something lke that. bleh
		
    if (not repeating) then
      tempTimers[timerId] = nil
    else
      tempTimers[timerId].startTime = getEpoch()  
    end
    
    
    oCode(...)
    

	end

	timerId = oTempTimer(seconds, decoratedCode, repeating)

  -- if (repeating) then
    -- error 'someone made a repeating timer'
  -- end

	tempTimers[timerId] = {
    description = description or 'mystery timer',
    duration = seconds,
    startTime = getEpoch(),
    repeating = repeating,
  }

	-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer setup - ' .. tostring(timerId) .. ' : ' .. tempTimers[timerId] .. '\n')

  

	return timerId

end


killTimer = function(timerId)

	if (tempTimers[timerId] ) then
  	-- cecho('\n&lt;orange&gt;TIMER: &lt;white&gt;killed with fire - ' .. timerId .. ' : ' .. tempTimers[timerId] .. '\n')
  	tempTimers[timerId] = nil
  	oKillTimer(timerId)
	else
		cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing timer - ' .. timerId .. '\n')
    oKillTimer(timerId)
	end
end


displayTempTimers = function()
	display(tempTimers)
  njs50.ui.showTimers()
end




</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>trigger helpers</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- moved to common
common.timedTempTrigger = njs50.timedTempTrigger
timedTempTrigger = njs50.timedTempTrigger

common.killTimedTempTrigger = njs50.killTimedTempTrigger
killTimedTempTrigger = njs50.killTimedTempTrigger


common.onNextEvent = function (evt, callback)

	if not evt then

		echo('no event defined!!!')
		error()

	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		-- kill the event handler now in case the event errors preventing it's destruction
		killAnonymousEventHandler(handlerId)
		-- cecho('\n&lt;blue&gt;self destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

onNextEvent = common.onNextEvent

common.oneRoomExitTrig = function (direction, code)

  local tempTrigId = tempRegexTrigger('^You see no exit to the (' .. direction .. ')\.$', function ()
		code(matches[2])
	end, 1)

  echo(' &lt;- room sepecific trig: ' .. tostring(tempTrigId))

	-- need to dest these as the first room change will be entering the room where we
	-- want to watch for the event
	common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
		-- got to wait for a prompt or else this will trigger on the same event as the first
		common.onNextEvent(common.events.PARSED_PROMPT, function ()
      common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
      	echo('\n ^^ killed room specific trig : '  .. tostring(tempTrigId) .. '\n')
        killTrigger(tempTrigId)
      end)
		end)
	end)

end

oneRoomExitTrig = common.oneRoomExitTrig


common.clearTriggers = function(aTriggers)
  for i, j in pairs(aTriggers) do 
    killTrigger(j)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>repop</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
common = common or {}


common.eagleEye = function (mob, cb)
	local callback = cb
  
  common.startRepopWaitTimer()
  
  common.performEE(mob, function(eeData)
    if(eeData.state == 'alive') then
      common.stopRepopWaitTimer()
      callback(eeData)    
    else
  		  send('gstat trying again in 15')
      common.updateCurrentRepopWaitTime()
    		tempTimer(15, function  ()
    			common.eagleEye(mob, callback)
    		end, 'eagle eye recheck')    
    end
  
  end)

end


common.performEE = function(mob, cb)

-- mage.events.EAGLE_EYE

-- You need 75 energy points to cast summon.
  if (mage.pendingEE == nil) then
  
    mage.pendingEE = true
  
    local oomTrig = tempRegexTrigger([[You need \d+ energy points to cast eagle eye\.$]], function()
      mage.pendingEE = nil
      cecho('\n\n&lt;yellow&gt;EAGLE EYE:&lt;white&gt; need more mana, trying again in 10\n\n')
      tempTimer(10, function()
        common.performEE(mob,cb)
      end, 'pending eagle eye')
    end, 1)
  
    common.onNextEvent(mage.events.EAGLE_EYE, function(evt, eeData) 
      killTrigger(oomTrig)
      mage.pendingEE = nil
      cb(eeData)
    end)
  
  
    send('cast eagle eye ' .. common.dotCase(mob))
    
  else
    
    cecho('\n\n&lt;green&gt;EAGLE EYE:&lt;white&gt; delayed due to pending eagle eye.\n\n')
    tempTimer(5, function()
      common.performEE(mob, cb)
    end, 'eagle eye (delayed by pending cast)')
  
  
  end

end



common.remoteEagleEye = function (mage, mob, cb, cbf)
	local callback = cb
	
  local t1, t2
  
  t2 = tempRegexTrigger([[^Nothing found matching "]] .. mage .. [["\.]], function()
    killTrigger(t1)
    cbf()
  end, 1)  
  
	t1 = tempRegexTrigger([[^]] .. mage .. [[ tells you: "repopped"]], function ()
    killTrigger(t2)
    common.stopRepopWaitTimer()
    cb()
  end, 1)
	
  common.startRepopWaitTimer()	
	send('tell ' .. mage .. ' ee-only ' .. mob)

end


common.playerEagleEye = function (player, mob, cb)
	local callback = cb
	
	tempRegexTrigger(player .. [[ tells you[^:]*: "repopped"]], function ()
    common.stopRepopWaitTimer()
    cb()
  end, 1)
	
  common.startRepopWaitTimer()	
	send('tell ' .. player .. ' ee ' .. mob)

end

common.scanRepopCheck = function(mob, cb, useFarSight) 

  common.startRepopWaitTimer()	

  if (useFarSight == true and player.skills["far-sight"] and player.skills["far-sight"] &gt; 0) then
    expandAlias('farscan')
  end
  
  common.onNextEvent(common.events.SCAN_PROCESSED, function()
    
    local mobs = {}
  
    if (type(mob) == 'table') then
      mobs = mob
    else
      table.insert(mobs, mob)
    end
    
    local checkTbl = {}
    for idx, mob in pairs(mobs) do
      checkTbl['1.' .. common.dotCase(common.toMurderString(mob))] = true
    end
  
    for exit, deets in pairs(murder.exits) do
      for idx, mob in pairs(deets.allTargets) do
        if (checkTbl[mob]) then
          -- mob found, invoke callback and exit processing
          cecho('\n&lt;green&gt;REPOP:&lt;white&gt; repop! mob is ' .. exit .. '\n')
          common.stopRepopWaitTimer()
          return cb()
        end
      end
    end 
  
    -- mob not found
    -- cecho('\n&lt;yellow&gt;REPOP:&lt;white&gt; mob not yet on scan, retrying in 10\n')
    tempTimer(5, function()
      common.updateCurrentRepopWaitTime()
      common.scanRepopCheck(mob, cb, useFarSight)
      cecho('\n\n&lt;orange&gt;-=[ no repop, waiting 5s, total wait so far: ' .. common.formatElapsedTime(farmer.lapRepopWaitTime) .. ' ]=-\n')
    end, 'scanning for mob repop')
  
  end)
  
  tempTimer(1, function() murder.scan('scan repop check') end)

end



-- common.checkRepopByDrop('south', [[^\S tiny .* lies heaped upon the ground\.$]], function ()
	-- send('jig')
-- end)

common.startRepopWaitTimer = function ()
	common.repopWaits = common.repopWaits or {}

	if (not common.repopWaitStartTime) then
		common.repopWaitStartTime = getEpoch()
	end
  
end

common.updateCurrentRepopWaitTime = function()
  farmer.lapRepopWaitTime = getEpoch() - common.repopWaitStartTime
end

common.stopRepopWaitTimer = function ()

		common.repopWaitStartTime = common.repopWaitStartTime or getEpoch()
	
		farmer.lapRepopWaitTime = getEpoch() - common.repopWaitStartTime
		
		cecho('\n\n&lt;green&gt;repop (took ' .. common.formatElapsedTime(farmer.lapRepopWaitTime) .. ')\n')
		
		-- keep track of all the wait times we've had...
		if (farmer.lapRepopWaitTime &gt; 0) then
			table.insert(common.repopWaits, farmer.lapRepopWaitTime)
		end  
		
		common.repopWaitStartTime = nil
  
end


common.checkRepopByDrop = function (dir, regex, callback, waitForRegexTime, invert) 

  local startRoomId = tfe.roomInfo.num
  
  local startInWays = false
  
  murder.exitForSleepKill = true -- allow us to leave the party behind
  
  -- convert exit dir to room num
  if (type(dir) == 'string') then 
    dir = gmcp.Room.Info.exits[dir]
  end
  
  if (gmcp.Room.Info.area == "The Ways") then
    startInWays = true
    waitForRegexTime = waitForRegexTime or 10
    cecho('\n\n&lt;green&gt;REPOP:&lt;white&gt;checking from druid ways\n')
  end

  waitForRegexTime = waitForRegexTime or 5

  common.startRepopWaitTimer()

  
  local sawRepop = true
  
  local checkRepopTrig = tempRegexTrigger(regex, function()
    cecho('&lt;orange&gt; &lt;- no repop\n')
    sawRepop = false
  end)

  
  
  local returnedToStart = function()

    if (
         (sawRepop and not invert) or 
         (not sawRepop and invert)
       ) then
   
      cecho('\n\n&lt;green&gt;-=[ repoped ]=-\n')
      common.stopRepopWaitTimer()
      murder.exitForSleepKill = nil
      callback()   
    
    else

      local delay = 12 + math.random (1, 18)
      
      common.updateCurrentRepopWaitTime()
    
      tempTimer(waitForRegexTime, function ()
        cecho('\n\n&lt;orange&gt;-=[ no repop, waiting ' .. tostring(delay) .. 's, total wait so far: ' .. common.formatElapsedTime(farmer.lapRepopWaitTime) .. ' ]=-\n')
      end, 'repop check')
      
      tempTimer(delay, function () 
        common.checkRepopByDrop(dir, regex, callback, waitForRegexTime, invert)
      end, 'repop check')

    end
  
  end
  
  -- if room number provided go there then back to start location
  if (startInWays) then

    tfe.gotoRoom(dir, function(cb)
      druid.landwalk(function()
        killTrigger(checkRepopTrig)
        tfe.gotoRoom(startRoomId, returnedToStart)
      end)
    end)
    
  else

    tfe.gotoRoom(dir, function()
      tempTimer(0.25, function() killTrigger(checkRepopTrig) end, 'checking repop time is over')
      tfe.gotoRoom(startRoomId, returnedToStart)
    end)

  end
  
end


common.checkRepop = function (repopRegex, failRegex, checkCommand, failCommand, callback)

	cecho('&lt;green&gt;REPOP: &lt;white&gt;Checking for repop!\n')
	local repopTrig = nil
	local failTrig = nil
	local cb = callback
	 
	repopTrig = tempRegexTrigger(repopRegex, function() 
		cecho('&lt;green&gt;REPOP: &lt;white&gt;Good to go!\n')
		killTrigger(failTrig)
		cb()
	end, 1)
	
	failTrig = tempRegexTrigger(failRegex, function() 
		cecho('&lt;green&gt;REPOP: &lt;white&gt;not yet grasshopper!\n')
		killTrigger(repopTrig)
		send(failCommand)
	end, 1)
	
	send(checkCommand)
	
end

common.waitForRepop = function(delay, repopRegex, failRegex, checkCommand, failCommand, callback)

	cecho('&lt;green&gt;REPOP: &lt;white&gt;waiting for repop...\n')
	
	local checkFn
	
	local cb = callback
	
	local repopped = false
	
	local onClear = function ()
		repopped = true
		cb()
	end
	
	checkFn = function ()
		
		if (not repopped) then
			
			common.checkRepop(repopRegex, failRegex, checkCommand, failCommand, onClear)
			
			tempTimer (delay, function() 
				checkFn()
			end)

		end
		
	end
	
	checkFn()

	
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>reagents</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common.getReagents = function (reagent, amount, callback, failCallback)

	local sleeping = false

	local shortReg = common.dotCase(reagent)
	
	-- You get an acid-filled globe from a large burlap bag labeled duped.
	-- an acid-filled globe            1  .15
	-- an acid-filled globe            2  .30
	
	-- display(shortReg)
	
	common.onNextEvent(common.events.PARSED_INVENTORY, function() 
	
		local holding = player.inventory[reagent] or 0
	
		cecho('\n&lt;green&gt;reagent check: &lt;white&gt;' .. reagent .. ', holding: ' .. tostring(holding) .. ' want ' ..  tostring(amount) .. '\n') 
		
		-- display(player)
		
		if (holding &lt; amount) then
			
			if (sleeping) then send('stand') end
			
      if (player.reagentBag == player.pack) then
        send('get ' .. shortReg .. ' ' .. player.reagentBag .. ' &amp; inventory')
      else
			   send('gs &amp; get ' .. shortReg .. ' ' .. player.reagentBag .. ' &amp; ps &amp; inventory')
      end
			
			if (sleeping) then send('sleep') end
			
			local haveTrig
			local outTrig
			
			haveTrig = tempRegexTrigger('^You get ' .. reagent .. ' from', function ()
				killTrigger(outTrig)
        -- give us time to have rechecked inventory
        tempTimer(2, function()
				  common.getReagents(reagent, amount, callback, failCallback)	
        end)
			end, 1)
			
			local failReag = rex.gsub(shortReg, [[\.]], ' ')
			
			outTrig = tempRegexTrigger([[^Nothing found matching "]] .. failReag .. [["\.]], function () 
				killTrigger(haveTrig)
				cecho('\n&lt;red&gt;reagent check: &lt;white&gt;out of ' .. reagent .. '\n') 
				if (failCallback) then 
					failCallback()
				end
			end, 1)
			
		else
			
			if (callback) then
				callback()
			end
			
		end
	
	
	end)
	
	common.timedTempTrigger(2, 1, [[^You cannot do that while sleeping\.]], function ()
		sleeping = true
		send('stand &amp; inventory &amp; sleep')
	end)
	
	send('inventory')

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>JSON</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
common = common or {}

--
-- json.lua
--
-- Copyright (c) 2019 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { [ "\\/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return escape_char_map[c] or string.format("\\u%04x", c:byte())
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val &lt;= -math.huge or val &gt;= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=iws-appendixa
  local f = math.floor
  if n &lt;= 0x7f then
    return string.char(n)
  elseif n &lt;= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n &lt;= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n &lt;= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(3, 6),  16 )
  local n2 = tonumber( s:sub(9, 12), 16 )
  -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local has_unicode_escape = false
  local has_surrogate_escape = false
  local has_escape = false
  local last
  for j = i + 1, #str do
    local x = str:byte(j)

    if x &lt; 32 then
      decode_error(str, j, "control character in string")
    end

    if last == 92 then -- "\\" (escape char)
      if x == 117 then -- "u" (unicode escape sequence)
        local hex = str:sub(j + 1, j + 5)
        if not hex:find("%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        if hex:find("^[dD][89aAbB]") then
          has_surrogate_escape = true
        else
          has_unicode_escape = true
        end
      else
        local c = string.char(x)
        if not escape_chars[c] then
          decode_error(str, j, "invalid escape char '" .. c .. "' in string")
        end
        has_escape = true
      end
      last = nil

    elseif x == 34 then -- '"' (end of string)
      local s = str:sub(i + 1, j - 1)
      if has_surrogate_escape then
        s = s:gsub("\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
      end
      if has_unicode_escape then
        s = s:gsub("\\u....", parse_unicode_escape)
      end
      if has_escape then
        s = s:gsub("\\.", escape_char_map_inv)
      end
      return s, j + 1

    else
      last = x
    end
  end
  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx &lt;= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


common.json = json</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>demonnic</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>EMCO</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>EMCO</name>
						<packageName></packageName>
						<script>--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
-- @module EMCO
EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
})

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _,channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.activeColors.r, config.activeColors.g, config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g, config.inactiveColors.b)
  constraints = string.format("%s  consoleColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Make a new script, then copy and paste the following output into it.
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then self.ae(funcName, "position as number expected, got " .. position) end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then self.ae(funcName, tabCheck) end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  if oldTab ~= tabName and oldTab ~= "" then
    self.windows[oldTab]:hide()
    self.tabs[oldTab]:setStyleSheet(self.inactiveTabCSS)
    self.tabs[oldTab]:setColor(self.inactiveTabBGColor)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor, "c")
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self.tabs[tabName]:setStyleSheet(self.activeTabCSS)
  self.tabs[tabName]:setColor(self.activeTabBGColor)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor, "c")
  if oldTab and self.windows[oldTab] then
    self.windows[oldTab]:hide()
  end
  self.windows[tabName]:show()
  self.currentTab = tabName
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({
    name = string.format("%sTab%s", self.name, tabName)
  }, self.tabBox)
  tab:echo(tabName, self.inactiveTabFGColor, 'c')
  -- use the inactive CSS. It's "" if unset, which is ugly, but
  tab:setStyleSheet(self.inactiveTabCSS)
  -- set the BGColor if set. if the CSS is set it overrides the setColor, but if it's "" then the setColor actually covers that.
  -- and we set a default for the inactiveBGColor
  tab:setColor(self.inactiveTabBGColor)
  tab:setClickCallback("EMCOHelper.switchTab", nil, string.format("%s+%s",self.name, tabName))
  self.tabs[tabName] = tab
  local window
  local windowConstraints = {
    x = 1,
    y = 1,
    height = "-2px",
    width = "100%",
    name = string.format("%sWindow%s", self.name, tabName)
  }
  local parent = self.consoleContainer
  if self.mapTab and tabName == self.mapTabName then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    window = Geyser.MiniConsole:new(windowConstraints, parent)
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
  end
  self.windows[tabName] = window
  window:hide()
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _,tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end
  local default
  if self.currentTab == "" then
    default = self.allTabName or self.consoles[1]
  else
    default = self.currentTab
  end
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x=0,
    y=0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel"
  }, self)
  self.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "100%",
    name = self.name .. "TabBox"
  }, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer"
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[hHmMszZaApPdy:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName, "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- &lt;br&gt;This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then self.ae(funcName, "allTabName expected as string, got" .. allTabNameType) end
  if not table.contains(self.consoles, allTabName) then self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.containers, ",")) end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName .. ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- &lt;br&gt;Forces a redraw of the object
-- &lt;br&gt;CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got ".. type(blinkeTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function() self:blink() end, true, 'EMCO: blink timer')
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab,_ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _,tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.windows[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _,console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    local tab = self.tabs[console]
    if console == self.currentTab then
      tab:setStyleSheet(self.activeTabCSS)
      tab:setColor(self.activeBGColor)
    else
      tab:setStyleSheet(self.inactiveTabCSS)
      tab:setColor(self.inactiveBGColor)
    end
  end
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.windows[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
    self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
    self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got ".. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _,console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.windows[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.windows[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- &lt;br&gt;it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _,console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.windows[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- &lt;br&gt;depending on this object's configuration, may gag the line
-- &lt;br&gt;depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got ".. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.windows[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.windows[self.allTabName] or false
  local ofr,ofg,ofb,obr,obg,obb
  if xtype == "a" then
    selectCurrentLine()
    ofr,ofg,ofb = getFgColor()
    obr,obg,obb = getBgColor()
    if self.preserveBackground then
      local r,g,b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r,g,b)
    end
    copy()
  else
    ofr,ofg,ofb = Geyser.Color.parse("white")
    obr,obg,obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab and tabName ~= self.allTabName then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function() deleteLine() end, 1)
      end
    end
  else
    console[xtype](console, message)
    if allTab then allTab[xtype](allTab, message) end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then allTab:echo("\n") end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local console = self.windows[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.windows[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      local ofr,ofg,ofb = Geyser.Color.parse("white")
      local obr,obg,obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then allTab[linkType](allTab, unpack(arguments)) end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  if not table.contains(self.allTabExclusions, tabName) then table.insert(self.allTabExclusions, tabName) end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then table.remove(self.allTabExclusions, index) end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.windows[console]:enableScrollBar()
      else
        self.windows[console]:disableScrollBar()
      end
    end
  end
end

EMCOHelper = EMCOHelper or {}
EMCOHelper.items = EMCOHelper.items or {}
function EMCOHelper:switchTab(designator)
  local args = string.split(designator, "+")
  local emcoName = args[1]
  local tabName = args[2]
  for _,emco in ipairs(EMCOHelper.items) do
    if emco.name == emcoName then
      emco:switchTab(tabName)
      return
    end
  end
end

EMCO.parent = Geyser.Container

--- Creates a new Embeddable Multi Console Object.
-- &lt;br&gt;see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or { "All" }
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" and string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] .. table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then self:se(funcName, "allTabExclusions must be a table if it is provided") end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag)then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.blinkTime = cons.blinkTime or 3
  me.fontSize = cons.fontSize or 9
  me.activeTabCSS = cons.activeTabCSS or ""
  me.inactiveTabCSS = cons.inactiveTabCSS or ""
  me.activeTabFGColor = cons.activeTabFGColor or "purple"
  me.inactiveTabFGColor = cons.inactiveTabFGColor or "white"
  me.activeTabBGColor = cons.activeTabBGColor or "&lt;0,180,0&gt;"
  me.inactiveTabBGColor = cons.inactiveTabBGColor or "&lt;60,60,60&gt;"
  me.consoleColor = cons.consoleColor or "black"
  me.tabBoxCSS = cons.tabBoxCSS or ""
  me.tabBoxColor = cons.tabBoxColor or "black"
  me.consoleContainerCSS = cons.consoleContainerCSS or ""
  me.consoleContainerColor = cons.consoleContainerColor or "black"
  me.gap = cons.gap or 1
  me.consoles = cons.consoles
  me.tabHeight = cons.tabHeight or 25
  if cons.autoWrap == nil then
    me.autoWrap = true
  else
    me.autoWrap = cons.autoWrap
  end
  me.wrapAt = cons.wrapAt or 300
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.windows = {}
  self.blinkTimerID = tempTimer(me.blinkTime, function() me:doBlink() end, true, 'EMCO: blink timer 2')
  me:reset()
  if me.allTab then me:setAllTabName(me.allTabName or me.consoles[1]) end
  table.insert(EMCOHelper.items, me)
  return me
end
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>TextFormatter</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>standaloneFormatter</name>
						<packageName></packageName>
						<script>--- fText processing
-- @module demonnic
demonnic = demonnic or {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then
    error("Improper argument: options expected to be passed as table")
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
  options.rightCap = options.cap
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then
      gapSpaces = 2
    else
      gapSpaces = 1
    end
  end
  options.nontextlength = options.width - options.strLen - gapSpaces
  options.leftPadLen = math.floor(options.nontextlength / 2)
  options.rightPadLen = options.nontextlength - options.leftPadLen
  options.effWidth = options.width - ((options.capLen * gapSpaces) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end

  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end

  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing.
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne"
  -- "endcap================= some text"
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else
  --"=====endcap some text endcap====="
  --"=====endcap some text pacdne====="
  --"=================endcap some text"
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."

  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"

  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"

  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>reusableFormatter</name>
						<packageName></packageName>
						<script>--- Stand alone text formatter object. Remembers the options you set and can be adjusted as needed
-- @module demonnic.textFormatter
demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}

--- Set's the formatting type whether it's for cecho, decho, or hecho
--@tparam string typeToSet What type of formatter is this? Valid options are { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}
function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

--- Sets whether or not we should do word wrapping.
--@tparam boolean shouldWrap should we do wordwrapping?
function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

--- Sets the width we should format for
--@tparam number width the width we should format for
function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

--- Sets the cap for the formatter
--@tparam string cap the string to use for capping the formatted string.
function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

--- Sets the color for the format cap
--@tparam string capColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

--- Sets the color for spacing character
--@tparam string spacerColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

--- Sets the color for formatted text
--@tparam string textColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

--- Sets the spacing character to use. Should be a single character
--@tparam string spacer the character to use for spacing
function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

--- Set the alignment to format for
--@tparam string alignment How to align the formatted string. Valid options are 'left', 'right', or 'center'
function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

--- Set whether the the spacer should go inside the the cap or outside of it
--@tparam boolean spacerInside 
function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

--- Set whether we should mirror/reverse the caps. IE &lt;&lt; becomes &gt;&gt; if set to true
--@tparam boolean shouldMirror
function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

--- Format a string based on the stored options
--@tparam string str The string to format
function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

--- Creates and returns a new TextFormatter. For valid options, please see https://github.com/demonnic/fText/wiki/fText
--@tparam table options the options for the text formatter to use when running format()
function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tableFormatter</name>
						<packageName></packageName>
						<script>--- Easy formatting for text tables
-- @module demonnic.TableMaker

demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",
  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
  autoEcho = false,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

--- Adds a column definition for the table. 
--@tparam table options Table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position The position of the column you're adding, counting from the left. If not provided will add it as the last column
function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

--- Deletes a column at the given position
--@tparam number position the column you wish to delete
function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

--- Replaces a column at a specific position with the newly provided formatting
--@tparam table options table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position which column you are replacing, counting from the left.
function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

--- Adds a row of output to the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down. If not provided defaults to the last line in the table.
function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

--- Deletes the row at the given position
--@tparam number position the row to delete
function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

--- Replaces a row of output in the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down.
function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  local allowedTypes = {
    "string"
  }
  if self.allowPopups then
    table.insert(allowedTypes, "table")
  end
  local entryType = type(entry)
  if entryType == "function" then
    entryType = type(entry())
  end
  if table.contains(allowedTypes, entryType) then
    return entry
  else
    return 0
  end
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

--- Sets a specific cell's display information
--@tparam number row the row number of the cell, counted from the top down
--@tparam number column the column number of the cell, counted from the left
--@param entry What to set the entry to. Must be a string, or a table of options for insertLink/insertPopup if allowPopups is set. Or a function which returns one of these things
function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:getType()
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, self.formatType) then
    return 'd'
  elseif table.contains(hex, self.formatType) then
    return 'h'
  elseif table.contains(col, self.formatType) then
    return 'c'
  else
    return ''
  end
end

function demonnic.TableMaker:echo(message, echoType, ...)
  local fType = self:getType()
  local consoleType = type(self.autoEchoConsole)
  local console = ""
  if echoType == nil then echoType = "" end
  if consoleType == "string" then
    console = self.autoEchoConsole
  else
    console = self.autoEchoConsole.name
  end
  local functionName = string.format("%secho%s", fType, echoType)
  local func = _G[functionName]
  if fType == "" then formatted = false end
  if echoType == "" then
    func(console, message)
  else
    func(console, message, ...)
  end
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:echoRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    if type(str) == "table" then 
      str = str[1]
    end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    self:echo(ec)
    for index,column in ipairs(columns) do
      local message = column[i]
      if index ~= 1 then 
        self:echo(sep)
      end
      if type(row[index]) == "string" then
        self:echo(message)
      elseif type(row[index]) == "table" then
        local rowEntry = row[index]
        local echoType = ""
        if type(rowEntry[2]) == "string" then
          echoType = "Link"
        elseif type(rowEntry[2]) == "table" then
          echoType = "Popup"
        end
        self:echo(message, echoType, rowEntry[2], rowEntry[3], rowEntry[4] or true)
      end
    end
    self:echo(ec)
    if i ~= linesInRow then
      self:echo("\n")
    end
  end
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

--- enables making cells which incorporate insertLink/insertPopup
function demonnic.TableMaker:enablePopups()
  self.autoEcho = true
  self.allowPopups = true
end

--- enables autoEcho so that when assemble is called it echos automatically
function demonnic.TableMaker:enableAutoEcho()
  self.autoEcho = true
end

--- disables autoecho. Cannot be used if allowPopups is set
function demonnic.TableMaker:disableAutoEcho()
  if self.allowPopups then
    error("demonnic.TableMaker:disableAutoEcho(): you cannot disable autoEcho once you have enabled popups.")
  else
    self.autoEcho = false
  end
end

--- Enables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:enableAutoClear()
  self.autoClear = true
end

--- Disables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:disableAutoClear()
  self.autoClear = false
end

--- Set the miniconsole to echo to
--@param console The miniconsole to autoecho to. Set to "main" or do not pass the parameter to autoecho to the main console. Can be a string name of the console, or a Geyser MiniConsole
function demonnic.TableMaker:setAutoEchoConsole(console)
  local funcName = "demonnic.TableMaker:setAutoEchoConsole(console)"
  if console == nil then 
    console = "main" 
  end
  local consoleType = type(console)
  if consoleType ~= "string" and consoleType ~= "table" then
    error(funcName .. " ArgumentError: console as string or Geyser.MiniConsole expected, got " .. consoleType)
  elseif consoleType == "table" and console.type ~= "miniConsole" then
    error(funcName .. " ArgumentError: console received was a table and may be a Geyser object, but console.type is not miniConsole, it is " .. console.type)
  end
  self.autoEchoConsole = console
end

--- Assemble the table. If autoEcho is enabled/set to true, will automatically echo. Otherwise, returns the formatted string to echo the table
function demonnic.TableMaker:assemble()
  if self.allowPopups and self.autoEcho then
    self:popupAssemble()
  else
    return self:textAssemble()
  end
end

function demonnic.TableMaker:popupAssemble()
  if self.autoClear then
    local console = self.autoEchoConsole
    if console and console ~= "main" then
      if type(console) == "table" then
        console = console.name
      end
      clearWindow(console)
    end
  end
  local divWithNewLines = string.format("\n%s\n", self:createRowDivider())
  local header = self:makeHeader() .. "\n"
  local footer = string.format("\n%s%s%s\n", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  self:echo(header)
  for _,row in ipairs(self.rows) do
    if _ ~= 1 then
      self:echo(divWithNewLines)
    end
    self:echoRow(row)
  end
  self:echo(footer)
end

function demonnic.TableMaker:textAssemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s\n", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  if self.autoEcho then
    local console = self.autoEchoConsole or "main"
    if type(console) == "table" then console = console.name end
    if self.autoClear and console ~= "main" then
      clearWindow(console)
    end
    self:echo(sheet)
  end
  return sheet
end

--- Creates and returns a new TableMaker. See https://github.com/demonnic/fText/wiki/TableMaker for valid entries to the options table.
--@tparam table options table of options for the TableMaker object
function demonnic.TableMaker:new(options)
  local funcName = "emonnic.TableMaker:new(options)"
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  if options.allowPopups == true then
    options.autoEcho = true
  else
    options.allowPopups = false
  end
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>player configuration</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>player.config</name>
				<packageName></packageName>
				<script>common = common or {}
player = player or {}
player.scripts = player.scripts or {}


player.defaultConfig = function ()

  player.initialized = true

	player.bag = 'backpack.holding'
	player.pack = 'black.silk.bag'
  player.vessel = 'leather.waterskin'
  player.hasFoodBasket = false
	player.caster = false
	player.gearSet = 'default'
  
  player.getAttackCommand = function(target)
    return 'kill ' .. target
  end
  
  player.autoAttack = function(target)
    send(player.getAttackCommand(target))
  end  

end

common.fullEnough = function()
  
  if ((group.data[player.name].hp / group.data[player.name].hp_max) &gt; 0.9) and
     ((group.data[player.name].mp / group.data[player.name].mp_max) &gt; 0.9) and
     ((group.data[player.name].moves / group.data[player.name].moves_max) &gt; 0.8) then
     
    return true
  end
  
  return false

end


common.initPlayer = function ()
  
	echo('\n\nINITIAL STATUS CHECK\n\n')
  
  -- rest to defaults for init
  
  -- set extra big scrollback
  setConsoleBufferSize("main", 500000, 500)
  
  common.onNextEvent(common.events.PARSED_ABILITIES, function()
    
    if (not gmcp.Char.Score.name) then
      cecho('\ngmcp not init, trying again in 2 seconds\n\n')
      tempTimer(2, function()
        common.initPlayer()
      end)
      return
    end
      
  	player.name = gmcp.Char.Score.name
  
  
  	if not (player.scripts and player.scripts[player.name]) then
      echo('\nSetting  default player script for ' .. player.name .. '!\n')
      player.scripts[player.name] = player.defaultConfig
  	end
  
  		echo('\nRunning player script for ' .. player.name .. '!\n')
    player.defaultConfig()
  		player.scripts[player.name]()
      
    njs50.ui.init()
  
    -- cecho('\nloading gear sets. if it fails you should do "gear-save default" to save a default set\n')
    loadSavedGearSets()
    
    raiseEvent(common.events.UI_LOADED)
  
  end)
  
  send('score &amp; eq &amp; group &amp; inv &amp; typo &amp; prep &amp; abil all')

end

    </script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>njs50 UI</name>
				<packageName></packageName>
				<script>njs50 = njs50 or {}
njs50.ui = njs50.ui or {}


njs50.ui.enabled = njs50.ui.enabled or false

njs50.ui.tc_height = njs50.ui.tc_height or 25
njs50.ui.map_width = njs50.ui.map_width or 40
njs50.ui.lc_width = njs50.ui.lc_width or 200



njs50.ui.resetWindows = function(event, x, y)

  if (common.topContainer) then
    local tch = common.topContainer.get_height()

    if (tch ~= common.wm.tc_height) then
          -- setBorderTop(tch)
      common.wm.tc_height = tch

      if (njs50.ui.resizeTimer) then killTimer(njs50.ui.resizeTimer) end

      njs50.ui.resizeTimer = tempTimer(0.1, function()
        setBorderTop(common.wm.tc_height)
        setBorderLeft(njs50.ui.lc_width)
        njs50.ui.resizeTimer = nil
      end)

    end
  else

    -- player is not yet init. resize once windows are setup
    tempTimer(1, function()
      njs50.ui.resetWindows(event, x, y);
    end)
  end

end


if (njs50.ui.resizeEventWatcher) then
  killAnonymousEventHandler(njs50.ui.resizeEventWatcher)
  njs50.ui.resizeEventWatcher = nil
end

njs50.ui.resizeEventWatcher = registerAnonymousEventHandler("sysWindowResizeEvent", njs50.ui.resetWindows)




njs50.ui.init = function()

  
  	if (njs50.ui.enabled and not common.topContainer) then
  
  		-- init windows
      common.topContainer = Geyser.Container:new({
        name = "top_container",    -- give it a unique name here
    			x=0,
    			y=0,
        width = "100%",
    			height = tostring(njs50.ui.tc_height) .. '%',
      })
  
      common.leftContainer = Geyser.Container:new({
        name = "left_container",    -- give it a unique name here
    			x = 0,
    			y = tostring(njs50.ui.tc_height) .. '%',
        width = njs50.ui.lc_width,
  			  height = tostring(100 - njs50.ui.tc_height) .. '%',
      })
  
  		common.mapContainer = Geyser.Container:new({
        name = "map_container",    -- give it a unique name here
    			x=0,
    			y=0,
        width = tostring(njs50.ui.map_width) .. '%',
  			  height="100%",
      }, common.topContainer) --
  
  		common.chatContainer = Geyser.Container:new({
        name = "chat_container",    -- give it a unique name here
    			x = tostring(njs50.ui.map_width) .. '%',
    			y = 0,
        width = tostring( 100 - njs50.ui.map_width) .. '%',
  			 height = "100%",
        padding = 10,
      }, common.topContainer)
  
  				-- init windows
      common.mapper = Geyser.Mapper:new({
        name = "geyser_map",    -- give it a unique name here
    			x=0,
    			y=0,
        width = "100%",
  			  height="100%",
      }, common.mapContainer)
  
      common.chatConsole = EMCO:new({
        x = 0,
        y = 0,
        width = "100%",
        height = "100%",
        allTab = true,
        scrollbars = true,
        allTabName = "All",
        fontSize = 14,
        gap = 10,
        consoles = {
          "All",
          "Clan",
          "Group",
          "Tell",
          "Combat",
          "Public", 
          "Other",
          "Log",
        },
        -- mapTabName = "Map",
        mapTab = false,
        -- activeTabCSS = stylesheet,
        -- inactiveTabCSS = istylesheet,
      }, common.chatContainer)
        
      
  
  	end
    
end


njs50.ui.timers = njs50.ui.timers or Geyser.UserWindow:new({
  name = "Active Timers",
  titleText ="Active Timers", -- only available since Mudlet 4.8+
  x = "20%", y="20%",
  width="30%", height ="40%"
})




njs50.ui.showTimers = function()
  njs50.ui.timers:show()
  if (not njs50.ui.timerRefreshTimer) then
    njs50.ui.timerRefreshTimer = tempTimer(0.5, function()
      njs50.ui.updateTimers()
    end, true, 'refresh timer list')
  end
end


common.wm = common.wm or {}

common.wm.gridEntries = common.wm.gridEntries or {};


common.addGridEntry = function()

  local idx = tostring(#common.wm.gridEntries)

	local thisGrid = Geyser.Container:new({
    name = "grid_entry_" .. idx,    -- give it a unique name here
		x=0,
		y= #common.wm.gridEntries * 60,
    width = "100%",
		height=60,
  }, common.leftContainer)


  local hpbar = Geyser.Gauge:new({
    name="hpbar-" .. idx,
    x=5, 
    y=5,
    width = njs50.ui.lc_width - 10, 
    height=25,
  }, thisGrid)

  hpbar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f04141, stop: 0.1 #ef2929, stop: 0.49 #cc0000, stop: 0.75 #a40000, stop: 1 #cc0000);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  hpbar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bd3333, stop: 0.1 #bd2020, stop: 0.49 #990000, stop: 0.75 #700000, stop: 1 #990000);
    border-radius: 3;
    padding: 3px;
  ]])

  hpbar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  hpbar.text:setFontSize(18)

  local manabar = Geyser.Gauge:new({
    name="mpbar-" .. idx,
    x=5, 
    y=30,
    width = njs50.ui.lc_width - 10, 
    height=20,
  }, thisGrid)


  manabar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #4141f0, stop: 0.1 #2929ef, stop: 0.49 #0000cc, stop: 0.75 #0000a4, stop: 1 #0000cc);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  manabar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #3333bd, stop: 0.1 #2020bd, stop: 0.49 #000099, stop: 0.75 #000070, stop: 1 #000099);
    border-radius: 3;
    padding: 3px;
  ]])
  manabar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  manabar.text:setFontSize(18)

  local movebar = Geyser.Gauge:new({
    name="mbbar-" .. idx,
    x=5, 
    y=50,
    width = njs50.ui.lc_width - 10, 
    height=10,
  }, thisGrid)


  movebar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #41f041, stop: 0.1 #29ef29, stop: 0.49 #00cc00, stop: 0.75 #00a400, stop: 1 #00cc00);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  movebar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #33bd33, stop: 0.1 #20bd20, stop: 0.49 #009900, stop: 0.75 #007000, stop: 1 #009900);
    border-radius: 3;
    padding: 3px;
  ]])
  movebar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  movebar.text:setFontSize(7)

  table.insert(common.wm.gridEntries, {
    container = thisGrid,
    hpbar = hpbar,
    manabar = manabar,
    movebar = movebar
  })

end


common.updateGrid = function ()
 
 if (common.topContainer) then
    -- make sure we have one grid item per group member at least
    if (#common.wm.gridEntries &lt; group.memberCount) then
      for i = #common.wm.gridEntries, group.memberCount -1 do
        common.addGridEntry();
      end
    end
  
    -- hide any extra grid items
    if (#common.wm.gridEntries &gt; group.memberCount) then
      for i = group.memberCount + 1, #common.wm.gridEntries do
        common.wm.gridEntries[i].container:hide()
      end
    end  
      
    for idx, name in pairs(table.keys(group.members)) do
      -- display(idx,val)
      local data = group.data[name]
      local grid = common.wm.gridEntries[idx]
      
      grid.container:show()
      
      -- display(data)
      
      grid.hpbar:setValue(data.hp, math.max(data.hp_max, 1), name .. ' : ' .. tostring(data.hp) .. 'hp')
      grid.manabar:setValue(data.mp, math.max(data.mp_max, 1), tostring(data.mp) .. '/' .. tostring(data.mp_max))
      grid.movebar:setValue(math.min(data.moves, data.moves_max), math.max(data.moves_max, 1))
    end 
  end
end



if (common.wm.groupWatcher) then
  killAnonymousEventHandler(common.wm.groupWatcher)
  common.wm.groupWatcher = nil
end


common.wm.groupWatcher = registerAnonymousEventHandler(common.events.PARSED_GMCP_GROUP, common.updateGrid)



njs50.ui.hideTimers = function()
  njs50.ui.timers:hide()
  if (njs50.ui.timerRefreshTimer) then
    killTimer(njs50.ui.timerRefreshTimer)
    njs50.ui.timerRefreshTimer = nil
  end
end

njs50.ui.hideTimers()


njs50.ui.timerBars = njs50.ui.timerBars or {}

njs50.ui.addTimerBar = function()

  local idx = #njs50.ui.timerBars

	local thisGrid = Geyser.Container:new({
    name = "timer_entry_" .. tostring(idx),    -- give it a unique name here
		x=0,
		y= idx * 40,
    width = "100%-10px",
		height=40,
  }, njs50.ui.timers)


  local hpbar = Geyser.Gauge:new({
    name="timer-" .. tostring(idx),
    x=5, y=10,
    width="100%", height=30,
  }, thisGrid)

  hpbar.front:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f04141, stop: 0.1 #ef2929, stop: 0.49 #cc0000, stop: 0.75 #a40000, stop: 1 #cc0000);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 3px;
  ]])
  hpbar.back:setStyleSheet([[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bd3333, stop: 0.1 #bd2020, stop: 0.49 #990000, stop: 0.75 #700000, stop: 1 #990000);
    border-radius: 3;
    padding: 3px;
  ]])

  hpbar.text:setStyleSheet([[
   qproperty-alignment: 'AlignCenter';
  ]])

  hpbar.text:setFontSize(20)

  table.insert(njs50.ui.timerBars, {
    container = thisGrid,
    bar = hpbar
  })


end

local idSort = function(t, a, b)
  display(t[a], t[b])
  return t[a] &lt; t[b]
end

njs50.ui.updateTimers = function()
  -- tempTimers
  
  local activeTimers = #table.keys(tempTimers)
 
  if (njs50.ui.timers) then
    -- make sure we have one grid item per group member at least
    if (#njs50.ui.timerBars &lt; activeTimers) then
      for i = #njs50.ui.timerBars, activeTimers -1 do
        njs50.ui.addTimerBar();
      end
    end
  
    -- hide any extra grid items
    if (#njs50.ui.timerBars &gt; activeTimers) then
      for i = activeTimers + 1, #njs50.ui.timerBars do
        njs50.ui.timerBars[i].container:hide()
      end
    end  
    
    local timerIdxList = table.keys(tempTimers)
    table.sort(timerIdxList)
    
    for idx, key in ipairs(timerIdxList) do
      -- display(idx,val)
      local data = tempTimers[key]
      local grid = njs50.ui.timerBars[idx]
      
      grid.container:show()
      
      -- display(data)
      -- display((getEpoch() - data.startTime) * 100, math.max(data.duration*100, 1))
      grid.bar:setValue((getEpoch() - data.startTime) * 100, math.max(data.duration*100, 1), data.description)

    end 
  end  
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>player.config.example.template</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}

-- player.initialized is set after default config is loaded
if (player.initialized) then
  
  player.scripts = player.scripts or {}
  
  -- nb: must match exactly. i.e don't forget the capital letter
  player.scripts.YOUR_NAME_HERE = function ()
  
    njs50.ui.enabled = true
  
  	player.bag = 'bag.holding'
  	player.pack = 'backpack.holding'
  	player.reagentBag = 'bag.reagents'
  	player.gearSet = 'default'
  	player.vessel = 'leather.waterskin'
  	player.caster = false
  	player.hasFoodBasket = false
    player.hasSoupBarrel = false
    
    player.language = 'ogrish'
    
    player.getAttackCommand = function(target)
      return 'kill ' .. target
    end
    
    player.autoAttack = function(target)
      send(player.getAttackCommand(target))
    end  
  
  end
  
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>gmcp-events</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>player / group code</name>
				<packageName></packageName>
				<script>njs50 = njs50 or {}

njs50.gmcp = njs50.gmcp or {}

njs50.gmcp.charReady = njs50.gmcp.charReady or false

njs50.gmcp.previous = njs50.gmcp.previous or {}




njs50.gmcp.convertRecord = function (record)
  return {
    mp_max = record.maxen,
    mp = record.en,
    moves_max = record.maxmv,
    hp = record.hp,
    hp_max = record.maxhp,
    moves = record.mv,
    race = record.race,
  }
end



njs50.gmcp.updatePlayerGroup = function()
    
  if (not gmcp.Char or not gmcp.Char.Score or not gmcp.Char.Score.name or
      not gmcp.Char.Vitals or not gmcp.Char.Vitals.maxmv) then
    -- gmcp is not ready enough to update player and group
    cecho('\n&lt;orange&gt;GMCP&lt;white&gt;: attempted to update player and group before gmcp was ready\n')
    return
  end  
  
  -- if (njs50.gmcp.pendingUpdatePlayerGroup) then
    -- cecho('\n&lt;orange&gt;GMCP&lt;white&gt;: attempted to update player and group while update was pending\n')
    -- return
  -- end
  
  -- njs50.gmcp.pendingUpdatePlayerGroup = true
  
  -- debouncing gmcp update because it gets triggered twice by Char and Group
  -- especially solo, char.moves and Group.min_moves changes each room
  -- tempTimer(0.075, function()
    -- njs50.gmcp.pendingUpdatePlayerGroup = nil
      
    local playerStats = njs50.gmcp.convertRecord(gmcp.Char.Vitals)
    
    group.leader = gmcp.Char.Score.name
    group.looter = ''
    group.lowest_moves = gmcp.Char.Vitals.mv
    
    group.memberCount = 1
    
    group.members = {[gmcp.Char.Score.name] = true}
    group.data = {[gmcp.Char.Score.name] = playerStats}
    
      
    for stat, val in pairs(playerStats) do
      player[stat] = val
    end
    
  
    if (gmcp.Group and #table.keys(gmcp.Group) &gt; 0) then
  
      group.leader = gmcp.Group.leader
      group.looter = gmcp.Group.looter
      group.lowest_moves = gmcp.Group.minmv
  
      group.memberCount = 1 + #table.keys(gmcp.Group.members)    
  
      for name, stats in pairs(gmcp.Group.members) do
        group.members[name] = true
        group.data[name] = njs50.gmcp.convertRecord(stats)
      end
    
     
    end 
    
    -- cecho('&lt;green&gt; &lt;-- gmcp update')
    raiseEvent(common.events.PARSED_GMCP_GROUP);
  -- end, 'delayed gmcp player/group update')
  
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>njs50.gmcp.charUpdate</name>
				<packageName></packageName>
				<script>



njs50.gmcp.charUpdate = function()

  -- delay any processing until enough gmcp char data has been recieved
  if (not njs50.gmcp.charReady) then
    
    if (gmcp.Char.Score and gmcp.Char.Status and gmcp.Char.Vitals and gmcp.Char.Score and gmcp.Char.Status) then
      njs50.gmcp.charReady = true
      
      -- invoke old code previously trigged via first prompt
      player.initPending = true
      common.initPlayer()
      
      njs50.gmcp.updatePlayerGroup()
    end
    
  else
  
    -- cecho('&lt;green&gt; &lt;-- char updated ')
    
    if (njs50.tableHasValueChanges(gmcp.Char.Vitals, njs50.gmcp.previous.Vitals)) then
    
      njs50.gmcp.previous.Vitals = table.deepcopy(gmcp.Char.Vitals)
      -- cecho('&lt;green&gt; &lt;-- vitals updated ')
    
      njs50.gmcp.updatePlayerGroup()   
    
    end
    

  end




end</script>
				<eventHandlerList>
					<string>gmcp.Char</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>njs50.gmcp.groupUpdate</name>
				<packageName></packageName>
				<script>
njs50.gmcp.groupUpdate = function ()

  if (njs50.tableHasValueChanges(gmcp.Group, njs50.gmcp.previous.Group)) then
    
    -- cecho('&lt;green&gt; &lt;-- group updated ')
    njs50.gmcp.previous.Group = table.deepcopy(gmcp.Group)
    
    njs50.gmcp.updatePlayerGroup()
  
  end

end</script>
				<eventHandlerList>
					<string>gmcp.Group</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>channel.update</name>
				<packageName></packageName>
				<script>channel = channel or {}

channel.seq = channel.seq or {}

local chatTabs = {
  Gossip = 'Public',
  OOC =  'Public',
  UC =  'Public',
  ATALK =  'Public',
  Yell =  'Public',
  Newbie =  'Public',
  Ctell =  'Clan',
  Tell = 'Tell',
  Cstatus = nil,
  Gtell = 'Group',
  Gstatus = nil,
  Log = 'Log',
  Other = 'Other',
}


channel.update = function()

  for chan, status in pairs(gmcp.Channels) do
  
    if (channel.seq[chan] == nil or channel.seq[chan] ~= status.sequence) then
      channel.seq[chan] = status.sequence
  
      
      if (chatTabs[chan]) then
        -- 
        local excludeAll = false
        
        if chan == 'Tell' and rex.find(status.message, [[^(do |repopped|location:|ee-only |ee |ack:|running command)]]) then
          chan = 'Log'
          excludeAll = true
        end
        
        if (chan == 'Yell' and (status.language == 'unknown' or status.language == 'primal')) then
          chan = 'Other'
          excludeAll = true        
        end    
        
        local message = '[' .. chan .. '] ' .. status.who .. ': ' .. status.message
        common.consoleMessage(chatTabs[chan], message, 'green', excludeAll)
        
      end
      
    end
    
  end
  

end</script>
				<eventHandlerList>
					<string>gmcp.Channels</string>
				</eventHandlerList>
			</Script>
			<Script isActive="no" isFolder="no">
				<name>tfe.char_fighting</name>
				<packageName></packageName>
				<script>-- combat tracking via gmcp too unreliable for non tanks
-- 
-- tfe = tfe or {}
-- 
-- tfe.char_fighting = function ()
-- 
  -- local fighting = gmcp.Char.Fighting or {}
  -- 
  -- -- display(gmcp.Char.Fighting)
-- 
  -- local count = 0
-- 
  -- for mob, state in pairs(gmcp.Char.Fighting) do
    -- count = count + 1
  -- end
  -- 
  -- combat.mobs = count
  -- 
  -- if (count == 0 and combat.active) then
    -- if (combat.finshDelayTimer ~= nil) then
      -- killTimer(combat.finshDelayTimer)
      -- combat.finshDelayTimer = nil
    -- end 
    -- combat.finishPending = true
    -- 
    -- -- rabies: when not the group leader we leave combat between one mob dying
    -- -- and auto.assist making us hit the next mob. gmcp.Char.Fighting only
    -- -- has the mob we are currently fighting, not all the mobs in this case
    -- 
    -- local combatFinishDelay = 1
    -- if (gmcp.Char.Score.name == gmcp.Group.leader) then
      -- combatFinishDelay = 0
    -- end
    -- 
    -- combat.finshDelayTimer = tempTimer(combatFinishDelay, function()
      -- combat.finish()
      -- combat.finshDelayTimer = nil
      -- combat.finishPending = nil
    -- end)
  -- elseif (count &gt; 0 and not combat.active) then
    -- if (combat.finshDelayTimer ~= nil) then
      -- killTimer(combat.finshDelayTimer)
      -- combat.finshDelayTimer = nil
    -- end 
    -- combat.start()
  -- end
-- 
-- end
-- 
</script>
				<eventHandlerList>
					<string>gmcp.Char.Fighting</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>njs50.gmcp.fightingUpdate</name>
				<packageName></packageName>
				<script>
njs50.gmcp.previous.mobs = njs50.gmcp.previous.mobs or {}
njs50.gmcp.previous.target = njs50.gmcp.previous.target or ''

-- FIGHTING_TARGET_UPDATE

njs50.gmcp.fightingUpdate = function()

  if (njs50.tableHasValueChanges(gmcp.Char.Fighting, njs50.gmcp.previous.fighting)) then
    
    -- cecho('&lt;green&gt; &lt;-- gmcp.Char.Fighting updated ')
    njs50.gmcp.previous.fighting = table.deepcopy(gmcp.Char.Fighting)
    
    raiseEvent(common.events.FIGHTING_UPDATE, gmcp.Char.Fighting)
    -- display('fite update', gmcp.Char.Fighting)
  
    local mobs = table.keys(gmcp.Char.Fighting)    
    local adds = table.n_complement(mobs, njs50.gmcp.previous.mobs)
  
    -- need to have been in combat already for these to be adds
    if (#adds &gt; 0 and #njs50.gmcp.previous.mobs &gt; 0) then
      raiseEvent(common.events.MOBS_JOINED_COMBAT, adds)   
    end
    
    njs50.gmcp.previous.mobs = mobs
    
    -- check for target changes
    local target = ''
    for mob, data in pairs(gmcp.Char.Fighting) do
      if data.target then
        target = mob
      end
    end    
    
    if target ~= njs50.gmcp.previous.target then
      raiseEvent(common.events.FIGHTING_TARGET_UPDATE, target)
      njs50.gmcp.previous.target = target
    end
    
  end


end






</script>
				<eventHandlerList>
					<string>gmcp.Char.Fighting</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>other-events</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>njs50.on_UI_loaded</name>
				<packageName></packageName>
				<script>njs50 = njs50 or {}


-- do some initialization stuff here.
njs50.on_UI_loaded = function()


  -- disable trigger groups that shouldnt' be enabled
  disableTrigger('mage-sleep-plev')
  
  local classes = {
    'druid', 'mage', 'cleric', 'paladin', 'warrior', 
    'thief', 'harbinger', 'reaver', 'legate', 'bard',
    'ranger', 'monk'
  }
  
  local thisClass = gmcp.Char.Score.class

  for idx, class in ipairs(classes) do
    if class ~= thisClass then
      disableTrigger('njs50-' .. class)
      disableAlias('njs50-' .. class)
      disableScript('njs50-' .. class)
      disableTimer('njs50-' .. class)
    end
  end

  -- enable current class
  enableTrigger('njs50-' .. thisClass)
  enableAlias('njs50-' .. thisClass)
  enableScript('njs50-' .. thisClass)
  enableTimer('njs50-' .. thisClass)

end</script>
				<eventHandlerList>
					<string>COMMON:UI_loaded</string>
					<string>COMMON:njs50-module-reload</string>
					<string>COMMON:njs50-module-updated-njs50-tfe</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>combat tracking (while gmcp is bung)</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>combat</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
combat = combat or {
  active = false,
  mobCount = 0,
  pendingMobCount = 0,
  mobs = {},
  pendingMobs = {},
  clear_timer = nil,
  sleeping_mob = false
}

combat.roomClearDelay = 5

-- starting a 4 sec timer to make sure nothing else
-- wants to get fighty before declaring the room clear
combat.startTimer = function (delayoverride)
  local delay = delayoverride or combat.roomClearDelay
  if(combat.clear_timer) then
    -- cecho('&lt;yellow&gt;&lt;-- restarting room clear timer\n')
    combat.clearTimer()
  end  
  cecho('&lt;yellow&gt;&lt;-- setting room clear timer for ' .. tostring(delay) .. 's\n')
  combat.clear_timer = tempTimer(delay, function()
    combat.clear_timer = nil
    -- cecho('&lt;yellow&gt;&lt;-- running on room clear\n')
    combat.onRoomClear()
  end, 'combat clear timer')
end

combat.onRoomClear = function ()
-- cecho('&lt;green&gt;&lt;-- room is clear ...\n')
  
  -- room isn't really clear if an attack is pending. restart timer...
  if (player.pendingAttack) then
    return combat.startTimer()
  end
  
  combat.clearTimer()
  if (murder.enabled and player.position == 'standing') then
    murder.scan('room clear')
  end
  -- cecho('&lt;green&gt;&lt;-- CLEAR (no combat for ' .. tostring(combat.roomClearDelay) .. ' seconds)!!! \n')
  raiseEvent(common.events.ROOM_CLEAR)
end


combat.clearTimer = function()
  if (combat.clear_timer) then
      -- cecho('&lt;yellow&gt;&lt;-- room clear timer cancelled ...\n')
    killTimer(combat.clear_timer)
  end
  combat.clear_timer = nil
end

combat.reset = function()
  -- cecho('&lt;yellow&gt;&lt;-- room found - reseting combat timer\n')
  combat.startTimer()
  combat.active = false
  combat.mobCount = 0
  combat.mobs = {}  
  combat.pendingMobCount = 0
  combat.pendingMobs = {}
end

combat.extendRoomCheck = function ()

  if (combat.clear_timer) then
    -- cecho('&lt;green&gt;&lt;-- EXTEND ROOM CLEAR CHECK\n')
    combat.clearTimer()
    combat.startTimer()
  end

end

combat.start = function()
  
  if (not combat.active) then
    combat.startTime = getEpoch()
    combat.active = true
    cecho(' &lt;white&gt;&lt;-- -=[ COMBAT started ]=-')
    raiseEvent(common.events.COMBAT_STARTED)
    combat.clearTimer()
  end

end

combat.finish = function ()

  if (combat.active) then
    combat.active = false
    cecho(' &lt;white&gt; -=[ combat ended ]=-')
    if (group.leader == player.name) then
      murder.scan('combat ended')
    else
      cecho('&lt;green&gt;&lt;-- skipped scan due to not being leader\n')
    end
      
    raiseEvent(common.events.COMBAT_ENDED, getEpoch() - combat.startTime)
    combat.startTimer()
  end

end


combat.roomChanged = function()
  combat.reset()
end

combat.roomClear = function()
  cecho('&lt;green&gt;&lt;-- room clear event happened\n')
  combat.clearTimer()
end

combat.mobJoined = function(mob)
  -- cecho('&lt;green&gt;&lt;-- mob add ' .. mob .. '\n')
  
  combat.mobs[mob] = combat.mobs[mob] or 0
  combat.mobs[mob] = combat.mobs[mob] + 1
  combat.mobCount = combat.mobCount + 1
  -- display(combat.mobs)
  if (combat.pendingMobs[mob] and combat.pendingMobs[mob] &gt; 0) then
    combat.pendingMobs[mob] = combat.pendingMobs[mob] - 1
    combat.pendingMobCount = combat.pendingMobCount - 1
  end
  
  -- make sure combat.mobs is correct before triggering combat start and mob joined event
  combat.start()
  raiseEvent(common.events.MOB_JOINED_COMBAT, mob)
end

combat.mobJoinPending = function(mob)
  combat.pendingMobs[mob] = combat.pendingMobs[mob] or 0
  combat.pendingMobs[mob] = combat.pendingMobs[mob] + 1
  combat.pendingMobCount = combat.pendingMobCount + 1
  raiseEvent(common.events.MOB_ENTERED_ROOM, mob)
end


combat.mobJoinNotPending = function(mob)
  combat.pendingMobs[mob] = combat.pendingMobs[mob] or 0
  if combat.pendingMobs[mob] &gt; 0 then
    combat.pendingMobs[mob] = combat.pendingMobs[mob] - 1
    combat.pendingMobCount = combat.pendingMobCount - 1
  end
  raiseEvent(common.events.MOB_LEFT_ROOM, mob)
end

combat.mobLeft = function(mob)
  -- cecho('&lt;green&gt;&lt;-- mob left ' .. mob .. '\n')
  -- it's possible a mob could die who hasn't started combat yet
  if (combat.mobs[mob]) then
    combat.mobs[mob] = combat.mobs[mob] - 1
    if (combat.mobs[mob] == 0) then
      combat.mobs[mob] = nil
    end
    combat.mobCount = combat.mobCount - 1  
    
    if (combat.mobCount == 0) then
      combat.finish()
    end
  else 
    cecho('&lt;orange&gt;COMBAT:&lt;white&gt; mob left combat that hadn\'t joined: ' .. mob .. '\n')
  end
  
  raiseEvent(common.events.MOB_LEFT_COMBAT, mob)
  
end

combat.mobBlockedExit = function(mob, direction)  
  combat.pendingMobs[mob] = combat.pendingMobs[mob] or 0
  combat.pendingMobs[mob] = combat.pendingMobs[mob] + 1
  combat.pendingMobCount = combat.pendingMobCount + 1
  raiseEvent(common.events.MOB_BLOCKED_EXIT, mob, direction)
end

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.roomChanged</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList>
					<string>tfe mapper: room found</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.roomClear</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList>
					<string>COMMON::current_room_is_clear</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>player helpers</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>make-food-drink</name>
				<packageName></packageName>
				<script>caster = caster or {}

  
caster.createWater = function(vessel, cb, fcb)
    
  local notWaterTrig
  local createdWaterTrig
  local createdWaterTimer
  
  local clearTrigs = function()
    
    if (notWaterTrig) then
      killTrigger(notWaterTrig)
      notWaterTrig = nil
    end
    
    if (createdWaterTrig) then
      killTrigger(createdWaterTrig)
      createdWaterTrig = nil
    end  
  end
  
  
  createdWaterTrig = tempRegexTrigger([[^An? ]] .. vessel ..  [[ fills to overflowing with (.*)\.$]], function()
    if (matches[2]) == 'water' then
      clearTrigs()
      cb()
    else
      send('empty all.' .. common.dotCase(vessel))
      send('cast create water ' .. common.dotCase(vessel))     
    end
  end)
  
  
  notWaterTrig = tempRegexTrigger([[^(&lt;[^&gt;]+&gt;)?You can only cast create water on a drink container\.$]], function()
    clearTrigs()
    fcb()
  end)

  send('cast create water ' .. common.dotCase(vessel))  
  
end
  
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>player.manageInventory</name>
				<packageName></packageName>
				<script>player = player or {}

player.keepInPack = player.keepInPack or {}

-- player.keepInPack = {
  -- ["a spotted cheetah skin"] = true,
  -- ["a shadowy rod"] = true,
  -- ["a feather-tipped rod"] = true,
  -- ["a pearl"] = true,
  -- ["a feathered talisman"] = true,
  -- ["a multicoloured belt of the elements"] = true,
  -- ["a cottonwood rod of presage"] = true,
  -- ["a dowsing stick"] = true,
  -- ["a soft, snow-white bear skin"] = true,
  -- ["a shadowbox"] = true
-- }

player.manageInventory = function(evt, data)
  
  local moveItems = {}
  
-- "a soft, snow-white bear skin"

  for item, qty in pairs(player.inventory) do
    
    -- ffs. "a poop might" become "an enchanted poop" if you are detecting magic
    item = common.itemSanitize(item)
    
    altItem = rex.gsub(item, [[^an? ]], 'a ')
    
    if (player.keepInPack[item] or player.keepInPack[altItem]) then
    
      -- lua common.itemShorten("a soft, snow-white bear skin")
      local itemStr = ''
      
      if (qty &gt; 1) then
        itemStr = tostring(qty) .. '*'
      end
      
      itemStr = itemStr .. common.itemShorten(item)
      
      table.insert(moveItems, itemStr)
      
    end
  
  end
    
  if (#moveItems &gt; 0) then
    send('put ' .. table.concat(moveItems, ',') .. ' in ' .. player.pack)
  end

end</script>
				<eventHandlerList>
					<string>COMMON:parsed_inventory_contents</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>status checks / prep</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common.getAffects =  function (cb)
	common.onNextEvent(common.events.PARSED_AFFECTS, function (evt, affects)
		cb(affects)
	end)
	send('affects')
end

common.onClear = function(action)
	common.onNextEvent(common.events.ROOM_CLEAR, action)
end


common.onCombat = function(action)
	common.onNextEvent(common.events.COMBAT_STARTED, action)
end




common.checkShields = function (cbGood, cbBad)


  -- Affect                                            Source
  --
  -- ------                                            ------
  -- You sense a divine protection.                    leech: a male vyan
  -- You feel righteous.                               leech: a male vyan

	local affectWatcher = nil

	local tempAffects = false
	local affectCount = 0

	local okayTempAffects = {
		['You feel sick!'] = true,
		['Your battlemind is divinely focused.'] = true,
		['You are embraced by earthen protection.'] = true,
	}

	common.getAffects( function (affects)



		for affect, source in pairs(affects) do




  		if (source == 'temporary') then
  			-- earthen protection is always tempporary
  			if not okayTempAffects[affect] then
  				cecho('&lt;white&gt;--== &lt;red&gt;expiring : ' .. affect .. ' &lt;white&gt; =-\n')
  				tempAffects = true
  			end

  		end
  		affectCount = affectCount + 1

		end

		if (tempAffects) then
			cecho('\n&lt;red&gt;WARNING: &lt;white&gt;Affects Checked!, some shields will expire!\n')
			if (cbBad) then
				cbBad(player.affects)
			end
		else
			cecho('\n&lt;green&gt;Affects Checked!, ' .. tostring(affectCount) .. ' affects are good\n')
			if (cbGood) then
				cbGood(player.affects)
			end
		end

	end)


end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>swap</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
local maxLength = 120


player = player or {}

player.swapItems = player.swapItems or {}
player.gearSets = player.gearSets or {}

common.conditions = {
  worthless = 0,
  damaged = 1,
  ["very worn"] = 2,
  worn = 3,
  ["very scratched"] = 4,
  ["very scratch"] = 4,
  scratched = 5,
  reasonable = 6,
  good = 7,
  ["very good"] = 8,
  excellent = 9,
  perfect = 10
}



common.slots = {
  "right hand",
  "left hand",
  "left hand finger",
  "right hand finger",
  "right wrist",
  "left wrist",
  "head",
  "body",
  "nearby",
  "arms",
  "hands",
  "feet",
  "legs",
  "waist",
  "neck"
}

common.layers = { 'bottom', 'under', 'base', 'over', 'top' }

common.lowestGearIgnore = {
  ["powdered wig"] = true,
  ["golden ball of light"] = true,
}


common.getWeaponCondition = function(cb)
  common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
    if not (player.gear["right hand"] and player.gear["right hand"].base) then
      cb(common.conditions['perfect'])
    else
      cb(common.conditions[player.gear["right hand"].base.condition])
    end
    
  end)
  send('|eq')

end

function getLowestGearCondition (cb)
  common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
    -- lua player.gear["right hand"].base.condition
    local lowestCondition = 11
    local lowestItem
    
    for slot, layers in pairs(player.gear) do
      for layer, item in pairs(layers) do
        if (common.conditions[item.condition] == nil) then
          cecho('\n\n&lt;red&gt;[GEAR]: &lt;white&gt; unknown gear condition: ' .. item.condition .. '\n\n')
        else
          if (not common.lowestGearIgnore[item.item] and common.conditions[item.condition] &lt; lowestCondition) then
            lowestCondition = common.conditions[item.condition]
            lowestItem = item
          end
        end
      end
    end
    -- display(lowestItem)
    -- display(player.gear)
    cb(lowestCondition)
  end)
  send('|eq')
end


function gearSets()
  cecho('\n&lt;green&gt;GEAR:&lt;white&gt; saved sets:\n\n')
  for set, deets in spairs(player.gearSets) do
    cecho(set .. '\n')
  end
end


function equipSet(set, callback)
  if (player.gearSets[set]) then

  	player.gearSet = set
  	send('gs', true)
  	equipGearSet(set, function()
  		send('ps', false)
			if callback then callback() end
    end)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. set .. '"\n')
  end
end

function equipPartial(set, callback)
  if (player.gearSets[set]) then
  	cecho('\n&lt;green&gt;GEAR: &lt;white&gt;Equip partial set: "' .. set .. '"\n')
  	send('gs', true)
  	equipGearSet(set, function()
  		send('ps', true)
			if callback then callback() end
    end, true)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. set .. '"\n')
  end
end

function resetGear(callback)


  if (player.gearSets[player.gearSet]) then

  	cecho('\n&lt;green&gt;GEAR: &lt;white&gt;resetting gear to set: "' .. player.gearSet .. '"\n')
  	send('gs', true)

		equipGearSet(player.gearSet, function()
  		send('ps', true)
			if callback then callback() end
    end)

  else
  	cecho('\n&lt;red&gt;GEAR: &lt;white&gt;No set found matching: "' .. player.gearSet .. '"\n')
  end
end


function deleteGearSet (name)
  table.save(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
  player.gearSets[name] = nil
  table.save(getMudletHomeDir() .. "/gearsets.dat", player.gearSets)
end


function saveGearSet (name)

	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
  	table.save(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
  	player.gearSets[name] = player.gear
  	table.save(getMudletHomeDir() .. "/gearsets.dat", player.gearSets)
	end)
	send('|eq')

end

function loadSavedGearSets ()
	player.gearSets = {}

	local gearFile = getMudletHomeDir() .. "/gearsets.dat"

	local is_file = io.open(gearFile)

	if (is_file ~= nil) then
		table.load(gearFile, player.gearSets)
	end

end


function loadGearSetBackup ()
	player.gearSets = {}
	table.load(getMudletHomeDir() .. "/gearsets.backup.dat", player.gearSets)
end

-- functions below here are probably internal...

function equipGearSet (name, callback, partial)

  if (not catalog or not catalog.itemsIndex or #catalog.itemsIndex == 0) then
    cecho('\n&lt;green&gt;TFECAT: &lt;white&gt;loading items from server... please hold\n\n')
    local cmd = matches[1]
    catalog.load(function()
      equipGearSet(name, callback, partial)
    end)
    return
  end

	cecho('\n&lt;green&gt;Outfit: &lt;white&gt;equip gear set: ' .. name)

  if(player.equippingSet) then
    cecho('\n&lt;red&gt;Outfit: &lt;white&gt;waiting for prev gear change to complete before equiping ' .. name)
    
    common.onNextEvent(common.events.CHANGED_EQUIPMENT, function()
      equipGearSet(name, callback, partial)
    end)
    
    send('|eq')
    
    timedTempTrigger(0.5, 1, '^You cannot do that while sleeping\.$', function ()
      send('stand &amp; |eq')
    end)
    
    return
	end


	player.equippingSet = true


	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()

  	-- echo('\ncurrent gear established...\n')

		local newSet = player.gearSets[name]

		if (newSet == nil) then

			cecho('&lt;red&gt;Outfit Error: &lt;white&gt;set does not exist')
			if callback then callback() end

		else

			-- reset current swap list
			player.swapItems = {}

  		-- remove any items that have empty slots in new set
			if (not partial) then
      	  for slot, layers in pairs(player.gear) do
 
          for layer, item in pairs(layers) do
      				if (not (newSet[slot] and newSet[slot][layer])) then
    						-- echo('\nneed to remove ' .. item.item)
    						swapItems(item.item, '', slot, layer)
    					end
      			end
        
        end
			end
      


        -- swap any items different in the new set
        for slot, layers in pairs(newSet) do
          if (type(layers) == 'table') then -- in case junk like parsed gets in the data again
            for layer, item in pairs(layers) do
            -- add any items in a layer that doesn't exist in current set
              if (not (player.gear[slot] and player.gear[slot][layer])) then
              -- echo('\nneed to add new slot ' .. item.item)
                swapItems('', item.item, slot, layer)
              elseif (player.gear[slot][layer].item ~= item.item)then
                swapItems(player.gear[slot][layer].item, item.item, slot, layer)
              end
            end
          else
            -- not sure how parsing is still in there (too lazy to investigate atm)
            if (slot ~= 'parsing') then 
              cecho('\n&lt;red&gt;GEAR ERROR: &lt;white&gt;invalid data!!! slot: ' .. slot)
            end
          end
        end
     
        -- check for 2h weapon, and remove everything in offhand
        if (newSet["right hand"] and newSet["right hand"].base) then
          local tcatItem = catalog.getSlotLayerItem("right hand" ,  "base",  newSet["right hand"].base.item)
          if (not tcatItem) then
            cecho('\n&lt;red&gt;GEAR ERROR: &lt;white&gt;unable to find main hand weapon data: ' .. newSet["right hand"].base.item)
          else
            if catalog.hasAffect(tcatItem, 'Requires two hands.') then
              if (player.gear["left hand"]) then
                for layer, item in pairs(player.gear["left hand"]) do
                  -- echo('\nneed to remove ' .. item.item)
                    swapItems(item.item, '', "left hand", layer) 
                end            
              end 
            end
          end
        end
        
        -- check for offhand weapon and remove any other offhand things
        if (newSet["left hand"] and newSet["left hand"].base) then
          local lhw = catalog.getSlotLayerItem("left hand", "base", newSet["left hand"].base.item)
          if (not lhw) then
            cecho('\n&lt;red&gt;GEAR ERROR: &lt;white&gt;unable to find offhand weapon data: ' .. newSet["left hand"].base.item)
          else
            if lhw.itemType == 'weapon' and player.gear["left hand"] then
              for layer, item in pairs(player.gear["left hand"]) do
                -- echo('\nneed to remove ' .. item.item)
                if (layer ~= 'base') then
                  swapItems(item.item, '', "left hand", layer) 
                end           
              end 
            end
          end
        end        
        
      
      
			-- make sure we aren't just switching left/right things      
			local removeRedundantSwap = function (slot, layer)
        if (player.swapItems["left " .. slot] and player.swapItems["left " .. slot][layer] and
          player.swapItems["right " .. slot] and player.swapItems["right " .. slot][layer] and
          (player.swapItems["left " .. slot][layer].from == player.swapItems["right " .. slot][layer].to) and
          (player.swapItems["left " .. slot][layer].to == player.swapItems["right " .. slot][layer].from)) then
          -- remove redundant swap
          cecho('\n&lt;green&gt;GEAR SWAP: &lt;white&gt;removed redundant swap (left/right ' .. slot .. '.' .. layer .. ')')
          player.swapItems["left " .. slot][layer] = nil
          player.swapItems["right " .. slot][layer] = nil
        end
			end

      



			removeRedundantSwap('hand finger', 'over')
			removeRedundantSwap('hand finger', 'base')
			removeRedundantSwap('hand finger', 'top')
			removeRedundantSwap('wrist', 'base')
			removeRedundantSwap('wrist', 'over')
      
        -- ["left hand"] = {
          -- base = {
            -- from = "dar.ston.dagg.desp",
            -- to = "blac.stri.leat"
          -- }
        -- },
      
      -- weapons are fucked up if we are dual weiling the same weap but want to swap left hand
      -- remove the right hand weap also in this case
      if ( player.swapItems["left hand"] and player.swapItems["left hand"].base) then
      
        if (
              player.gear["left hand"] and player.gear["left hand"].base and 
              player.gear["right hand"] and player.gear["right hand"].base and
              player.gear["right hand"].base.item == player.gear["left hand"].base.item) then
          swapItems(player.gear["right hand"].base.item, player.gear["right hand"].base.item, "right hand", "base")
        end   
      end 


      -- swap all layers on top of any layers changing due to fucked up things like Xanas bracelets
      for slot, layers in pairs(player.swapItems) do
        
        -- for whatever reason sometimes the first item isnt the lowest layer
        local firstLayer = table.keys(layers)[1]
        local flIndex = table.index_of(common.layers,firstLayer)
        
        for layer in pairs(layers) do 
          local thisIndex = table.index_of(common.layers,layer)
          if (thisIndex &lt; flIndex) then
            flIndex = thisIndex
            firstLayer = layer
          end
        end 

        
        if (firstLayer) then
          for idx = table.index_of(common.layers,firstLayer) + 1, #common.layers do
            local checkLayer = common.layers[idx]
            if ((not player.swapItems[slot] or not player.swapItems[slot][checkLayer]) and (player.gear[slot] and player.gear[slot][checkLayer])) then
              swapItems(player.gear[slot][checkLayer].item, player.gear[slot][checkLayer].item, slot, checkLayer)
            end
          end
        end
      
      end



			local cb = function ()
				callback()
			end
      
      if #table.keys(player.swapItems) == 0 then
        
        cecho('\n&lt;green&gt;GEAR SWAP: &lt;white&gt;no gear needs swapping\n')
      		player.equippingSet = nil
          
      		if cb then 
          cb() 
        end
      		
        raiseEvent(common.events.CHANGED_EQUIPMENT)
          
      else
  
        
        displaySwapItems()
  
  
    			-- lets do it...
    			performSwap(cb)
    
      end

		end -- end check if this was a valid set

  end)

	send('|eq')

end

function displaySwapItems ()
  -- display(player.swapItems)
  for k, slot in pairs(common.slots) do

    if (player.swapItems[slot]) then

  		  for k, layer in pairs(common.layers) do  
        
        if (player.swapItems[slot][layer]) then
          local swap = player.swapItems[slot][layer]
          
          if swap.from ~= swap.to then
            -- display(slot,layer,swap.to)
            cecho('\n&lt;green&gt;GEAR SWAP: &lt;white&gt;' .. slot .. '.' .. layer .. ' - ' .. swap.from .. ' -&gt; ' .. swap.to)
          end
        
        end -- if layer exists in swap        
        
      end -- loop layers
      
    end -- if
    
  end -- loop slots
  
end


-- Error: invalid item switch of items in slot left hand
-- {
  -- to = "fir.gian.scap",
  -- from = "cora.shie.reju"
-- }
-- {
  -- to = "cora.shie.reju",
  -- from = "cora.shie.reju"
-- }


function swapItems (to, from, slot, layer)

	-- cecho('&lt;green&gt;swap: &lt;white&gt;swap to ' .. to .. ' from ' .. from .. '\n')

	if (slot == nil) then
		cecho('&lt;red&gt;ERROR: &lt;white&gt;no slot provided on item swap ' .. to .. ' to ' .. from .. '\n')
	end

	local swap = {from=common.itemShorten(to), to=common.itemShorten(from)}
  
  -- cloak of greater prot / cloak of invuln will revert to cloak of protection when removed
  if (swap.to == 'cloa.grea.prot' or swap.to == 'cloa.invu') then
    swap.to = 'cloa.prot'
  end


	player.swapItems[slot] = player.swapItems[slot] or {}

	if (player.swapItems[slot][layer]) then

		if (player.swapItems[slot][layer].to == swap.from) then
			swap.from = player.swapItems[slot][layer].from
		else
			cecho('Error: invalid item switch of items in slot ' .. slot)
			display(player.swapItems[slot][layer])
			display(swap)
		end

	end

	player.swapItems[slot][layer] = swap

end


function swapCommands (removeList, wearList)
	if(#wearList &gt; 0) then
		send('get ' .. table.concat(wearList, ',') .. ' from ' .. player.bag)
	end

	if(#removeList &gt; 0) then
		send('remove ' .. table.concat(removeList, ','))
	end

	if(#wearList &gt; 0) then
		send('wear ' .. table.concat(wearList, ','))
	end

	if(#removeList &gt; 0) then
    
    if table.contains(removeList, 'cloa.invu') then
      local idx = table.index_of(removeList, 'cloa.invu')
      removeList[idx] = 'cloa.prot' 
    end  
  
		send('put ' .. table.concat(removeList, ',') .. ' in ' .. player.bag)
	end


end

function performSwap (callback)

	local cb = callback

	local removeList = {}
	local wearList = {}

	local removeLength = 0
	local wearLength = 0

	local idx


  for k, slot in pairs(common.slots) do

    if (player.swapItems[slot]) then

      items = player.swapItems[slot]

  		for k, layer in pairs(common.layers) do
  		-- for layer, swap in pairs(items) do
  			local swap = items[layer]

  			if (items[layer]) then

    			if string.len(swap.from) &gt; 0 then
    				removeList = common.tfeItemListAdd(removeList, swap.from)
    				-- this is an approximation since if it's already in the list
    				-- we are only actually adding 2 (i.e 2*item)
    				removeLength = removeLength + string.len(swap.from)
    			end

    			if string.len(swap.to) &gt; 0 then

  				  wearList = common.tfeItemListAdd(wearList, swap.to)
    				-- this is an approximation since if it's already in the list
    				-- we are only actually adding 2 (i.e 2*item)
    				wearLength = wearLength + string.len(swap.to)
    			end

  			end -- check if layer is being swapped

  		end -- end layer loop


  		if (wearLength &gt; maxLength or removeLength &gt; maxLength) then
  			-- gotta remove items in the reverse order (i.e top layer first)
  			swapCommands(common.reverseList(removeList), wearList)
  			removeList = {}
  			wearList = {}
  			removeLength = 0
  			wearLength = 0
  		end

  	end -- end slot if
  end -- slot loop

	-- display(wearList)
	-- display(removeList)

	if (wearLength &gt; 0 or removeLength &gt; 0) then
		-- gotta remove items in the reverse order (i.e top layer first)
		swapCommands(common.reverseList(removeList), wearList)
	end

	send('queue group &amp; queue eq', false)

	common.onNextEvent(common.events.PARSED_EQUIPMENT, function()
		player.equippingSet = nil
		if cb then cb() end
		raiseEvent(common.events.CHANGED_EQUIPMENT)
	end)

	player.swapItems = {}

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>check resources</name>
				<packageName></packageName>
				<script>
common.updateStatus = function(callback)
  -- just wait for the next prompt...
  -- a gmcp update will have come by then
  -- common.onNextVitalsUpdate(callback)	 
  
  -- fuck waiting. lets just go. gmcp should be updated all the time
  callback()
   
end

common.checkFull = function(callback)
	return common.checkResources(player.hp_max, player.mp_max, player.moves_max * 0.6)
end

common.onNextVitalsUpdate = function(fn)
  return njs50.tempTimedNextEvent(7, 'gmcp.Char.Vitals', fn, fn)
end

common.onOffsetReady = function(lessHp, lessMp, lessMoves, callback)

	local readyStatus = common.checkResources(player.hp_max - lessHp, player.mp_max - lessMp, player.moves_max - lessMoves)
	
  if(readyStatus) then
		callback()
	else
    common.checkFullTimer = common.onNextVitalsUpdate(function()
			common.checkFullTimer = nil
			common.onOffsetReady(lessHp, lessMp, lessMoves, callback)
    end)
	end

end


common.onManaReady = function(mana, callback)

	local readyStatus = common.checkResources(0, mana, 0)
  
	if(readyStatus) then
		callback()
	else
    common.checkFullTimer = common.onNextVitalsUpdate(function()
			common.checkFullTimer = nil
			common.onManaReady(mana, callback)
    end)
	end


end


common.checkResources = function(hp, mp, moves)

  hp = math.floor(math.min(gmcp.Char.Vitals.maxhp, hp))
  mp = math.floor(math.min(gmcp.Char.Vitals.maxen, mp))
  moves = math.floor(math.min(gmcp.Char.Vitals.maxmv, moves))

	if (gmcp.Char.Vitals.hp &gt;= hp and gmcp.Char.Vitals.en &gt;= mp and gmcp.Char.Vitals.mv &gt;= moves) then
		echo('\n\n .. READY TO KILL\n')
		return true
	else
    
    local dHP = hp - gmcp.Char.Vitals.hp
    local dEN = mp - gmcp.Char.Vitals.en
    local dMV = moves - gmcp.Char.Vitals.mv
  
		cecho('\n .. sleep more little tank: ')
    if (dHP &gt; 0) then
      cecho('&lt;red&gt;' .. tostring(dHP) .. 'hp ')
    end
    if (dEN &gt; 0) then
      cecho('&lt;green&gt;' .. tostring(dEN) .. 'e ')
    end
    if (dMV &gt; 0) then
      cecho('&lt;blue&gt;' .. tostring(dMV) .. 'mv ')
    end          
    cecho('\n')
		return false
	end

end



common.checkFull = function()
	return common.checkResources(player.hp_max, player.mp_max * 0.95, player.moves_max * 0.6)
end

-- [ 75 Pal Ogr   ] Darion              1510/1520  763/1038   306/321     16,597,229
-- [ 75 Pal Ogr   ] Darion              1440/1576   708/728   291/296     16,597,229

common.onFullish = function (hp, mp, moves, callback)

	local readyStatus = common.checkResources(hp, mp, moves)

	if(readyStatus) then
		callback()
	else 
    common.checkFullTimer = common.onNextVitalsUpdate(function()
			common.checkFullTimer = nil
			common.onFullish(hp, mp, moves, callback)
    end)
	end

end


common.onFull = function (callback)

	local readyStatus = common.checkFull()

	if(readyStatus) then
		callback()
	else 
    common.checkFullTimer = common.onNextVitalsUpdate(function()
			common.checkFullTimer = nil
			common.onFull(callback)
    end)
	end

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>gear related</name>
				<packageName></packageName>
				<script>gear = gear or {}

gear.progressPlan = function(sets)

  -- display(sets)
  
  local pp = {}
  
  for idx, set in ipairs(sets) do
  
    local gs = player.gearSets[set]
    
    if (gs) then
    
      for slot, layers in pairs(gs) do
        
        if (type(layers) == "table") then
          for layer, item in pairs(layers) do
          
            -- display(slot, layer, item.item)
            
            pp[slot] = pp[slot] or {}
            pp[slot][layer] = pp[slot][layer] or {}
            
            if (#pp[slot][layer] == 0 or pp[slot][layer][#pp[slot][layer]] ~= item.item) then
              table.insert(pp[slot][layer], item.item)
            end
            
          end
        end
      
      end
    
    end
  
  end
  
  -- display(pp)

  cecho('\n|Body Location|Layer|Item|\n')
  cecho('|:-|:-|:-|\n')

  
  local lastSlot = ''
  
  for is, slot in ipairs(catalog.common.slots) do
        
    for il, layer in ipairs(catalog.common.layers) do  
    
      if (pp[slot] and pp[slot][layer]) then
        
        local items = pp[slot][layer]
      
        for idx, item in ipairs(items) do
        
          local tcatItem = catalog.getSlotLayerItem(slot, layer, item)  
          
          if (tcatItem) then
            pp[slot][layer][idx] =  item .. ' (lvl '.. tostring(tcatItem.Level) .. ')'
          end                
          
        end
        
        cecho('|')
        if (lastSlot ~= slot) then
          cecho(slot)
          lastSlot = slot
        else
          cecho(' ')
        end
        cecho('|' .. layer .. '|')
        cecho(table.concat(pp[slot][layer], ' &gt; ') .. '|\n')  
      
      end
      
    end
    
  end
 
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>casting crap</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>healing</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

healer = healer or {
  minPrepped = 0,
	prepped = 0,
	queued = 0,
	max_heal = 25,
	avg_heal = 13,
	spell = 'cure light',
	paused = false,
  mode = 'tank',
}

local topOffThreshold = 20 --  healer.avg_heal

-- 3d5+L
-- 10d20+(25*L)

healer.spells = {
  ['cure light']    = { diceNum = 3, diceSides = 5, levelMult = 1, cost = 15 },
  ['cure serious']  = { diceNum = 4, diceSides = 10, levelMult = 4, cost = 30 },
  ['cure critical'] = { diceNum = 9, diceSides = 10, levelMult = 8, cost = 60 },
  ['heal']          = { diceNum = 10, diceSides = 12, levelMult = 15, cost = 90 },
  ['restoration']   = { diceNum = 10, diceSides = 20, levelMult = 25, cost = 120 },
  
  ['mending']       = { diceNum = 1, diceSides = 13, levelMult = 1, cost = 25 },
  ['binding']       = { diceNum = 5, diceSides = 9, levelMult = 2, cost = 40 },
  ['unify']         = { diceNum = 6, diceSides = 10, levelMult = 3, cost = 60, aoe = true },
  ['recovery']      = { diceNum = 10, diceSides = 16, levelMult = 4, cost = 80 },
  ['rally']         = { diceNum = 10, diceSides = 19, levelMult = 6, cost = 95, aoe = true },
  ['redintegrate']  = { diceNum = 10, diceSides = 23, levelMult = 10, cost = 110 },
}


healer.setMinPrepped = function(amt, chan)

  amt = tonumber(amt)

  if (amt) then
  
    healer.minPrepped = amt
    
  else 
    send(chan .. ' invalid request, use: minPrepped &lt;amount&gt;')
  end

  healer.showConfig(chan)  
  
end


healer.setHealSpell = function (spell, chan) 
  
  local data = healer.spells[spell]
  
  if (data and player.skills[spell] and player.skills[spell] &gt; 0) then
    
    -- if we have other heals prepped send a prep cleared
    local needClear = false
    for preppedSpell, count in pairs(player.prepped) do
      if healer.spells[preppedSpell] and preppedSpell ~= spell then
        needClear = true
      end
    end
    if (needClear) then
      send('prep clear')
    end
  
    healer.spell = spell
  	healer.spell_cost = data.cost
  	healer.avg_heal = (((data.diceSides+1)  / 2) * data.diceNum) + (data.levelMult * player.skills[spell])
  	healer.max_heal = data.diceSides * data.diceNum + (data.levelMult * player.skills[spell])
  else
    cecho('\n&lt;red&gt;HEALER:&lt;white&gt; invalid spell! - ' .. spell .. '\n\n')
    send(chan .. ' invalid spell requested, use: spell &lt;spell&gt;')
  end
  
  if (healer.mode ~= 'custom') then
    healer.setMode(healer.mode)
  else
    healer.showConfig(chan)
  end
  
  
  
end


healer.modes = {
  tank = true,
  group = true,
  plev = true,
  wimps = true,
  groupEmergency = true,
}

healer.modeConfig = {

  tank = {
    leader = {average = 0, max = 1, min_pct = 0.7 },
    members = {average = 1, max = 1, min_pct = 0.6 },
  },

  group = {
    leader = {average = 3, max = 0, min_pct = 0.5 },
    members = {average = 0, max = 1, min_pct = 0.6 },
  },

  plev = {
    leader = {average = 5, max = 0, min_pct = 0.30 },
    members = {average = 5, max = 0, min_pct = 0.30 },
  },
  
  groupEmergency = {
    leader = {average = 5, max = 0, min_pct = 0.65 },
    members = {average = 5, max = 0, min_pct = 0.70 },
  },  

  wimps = {
    leader = {average = 1, max = 0, min_pct = 0.80 },
    members = {average = 0, max = 1, min_pct = 0.70 },
  },

}

-- healer.healAt = nil

--  = healer.healAt or healer.modeConfig[healer.mode] or healder.modeConfig.tank

healer.setPoints = function(config)
  
  
  healer.healAt = {
    tank = {
      hp = config.leader.average * healer.avg_heal + config.leader.max * healer.max_heal,
      pct = config.leader.min_pct
    },
    party = {
      hp = config.members.average * healer.avg_heal + config.members.max * healer.max_heal,
      pct = config.members.min_pct    
    } 
  }
  

end


healer.set = function(args, chan)
  chan = chan or 'gstat'
  
  -- args = &lt;tank|party&gt; &lt;hp|pct&gt; &lt;amount&gt;
  local target, field, amount = rex.match(args, [[^(tank|party) (hp|pct) (\d+)$]])
  
  display(target, field, amount)
  
  if (target) then
  
    amount = tonumber(amount)
    
    if (field == 'pct') then
      amount = amount / 100
    end
      
    healer.healAt[target][field] = amount
    
    healer.mode = 'custom'
    
  else 
    send(chan .. ' invalid request, use: set &lt;tank|party&gt; &lt;hp|pct&gt; &lt;amount&gt;')
  end
  
  
  
  healer.showConfig(chan)
end


if (healer.healAt == nil) then
  healer.setPoints(healer.modeConfig[healer.mode] or healer.modeConfig.tank)
end


healer.help = function(chan)

  chan = chan or 'gstat'


  local spells = {}
  for spell in pairs(healer.spells) do
    if (player.skills[spell] and player.skills[spell] &gt; 0) then
      table.insert(spells, spell)
    end
  end
  
  send(chan .. ' healbot v0.2')
  send(chan .. ' ..............................................................')
  send(chan .. ' If using group tell or group status to issue commands prefix')
  send(chan .. ' all commands with the first 2+ letters of my name')
  send(chan .. ' i.e. "gstat ' .. rex.gsub(player.name, [[^(\w\w).*]], '%1'):lower() .. ' help" to get this help') 
  send(chan .. ' ..............................................................')
  
  send(chan .. ' help                                 - see this help file')
  send(chan .. ' config                               - reports current config')
  
  send(chan .. ' ..............................................................')
  
  send(chan .. ' mode &lt;mode&gt;                        - set healer mode')
  send(chan .. ' set &lt;tank|party&gt; &lt;hp|pct&gt; &lt;amount&gt; - set custom heal points')
  send(chan .. ' spell &lt;spell&gt;                      - set healing spell')
  send(chan .. ' minPrepped &lt;amount&gt;                - set min heals prepped')
    
  send(chan .. ' ..............................................................')
  
  send(chan .. ' available modes: '.. common.tableIndexesToString(healer.modes))
  send(chan .. ' available spells: '.. common.tableToString(spells))
    
  send(chan .. ' ..............................................................')
  
  send(chan .. ' summon &lt;target&gt;   - attempt to summon &lt;target&gt; or player making request')
  send(chan .. ' gsummon           - attempt to summon missing group members')
  
  send(chan .. ' ..............................................................')
  send(chan .. ' ..............................................................')
  
  
  healer.showConfig()
  
end

healer.showConfig = function(chan)
  chan = chan or 'gstat'
  
  -- send(chan .. ' healing mode: ' .. healer.mode)
  send(chan .. ' spell: ' .. healer.spell .. ', average: ' .. tostring(healer.avg_heal) .. 
               'hp, max: ' .. tostring(healer.max_heal) .. 'hp, prepping: ' .. tostring(healer.minPrepped) .. '+'
  )
  
  send(chan .. ' healing tank after losing ' .. tostring(healer.healAt.tank.hp) .. 'hp or below ' .. tostring(healer.healAt.tank.pct * 100) .. '% of max hp')
  send(chan .. ' healing party after losing ' .. tostring(healer.healAt.party.hp) .. 'hp or below ' .. tostring(healer.healAt.party.pct * 100) .. '% of max hp')
  
end

healer.setMode = function(mode, chan) 

  chan = chan or 'gstat'

  if (healer.modes[mode]) then
    healer.mode = mode
    healer.setPoints(healer.modeConfig[mode])
    cecho('\n&lt;green&gt;HEALER:&lt;white&gt; set mode to : ' .. healer.mode .. '\n\n')
    healer.showConfig(chan)
  else
    cecho('\n&lt;red&gt;HEALER:&lt;white&gt; unknown healer mode : ' .. healer.mode .. '\n\n')
    send(chan .. ' unknown healer mode: ' .. mode)
  end 
  
end


healer.topOff = function (target, callback)
  cecho('\n&lt;green&gt;HEALER: &lt;white&gt;topping off ' .. target .. '\n')
	local unit = group.data[target]
	local rcb = callback
	if ((unit.hp &lt; unit.hp_max - topOffThreshold) and (healer.getPrepped() &gt; 0)) then
		healer.cast(target)
		cecho('&lt;green&gt;HEALER: &lt;white&gt;checking ' .. target .. ' again in 3 seconds\n')
    tempTimer(3, function() healer.topOff(target, rcb) end, 'healer top off')
	else 
    cecho('&lt;green&gt;HEALER: &lt;white&gt;' .. target .. ' is healthy enough\n')
		callback()
	end
end

healer.topOffParty = function (callback)
  local rcb = callback
  
  common.updateStatus(function ()
  
    local lowest = player.name
    local dHealth = player.hp_max - player.hp
    
    -- find player with the biggest hp missing
    for playerName, v in pairs(group.members) do
      local p = group.data[playerName]
      local dh = p.hp_max - p.hp
      if (dh &gt; dHealth) then
        lowest = playerName
        dHealth = dh
      end
    end
    
    if ((dHealth &gt; healer.avg_heal) and (healer.getPrepped() &gt; 0)) then
  		healer.cast(lowest)
  		tempTimer(3, function() healer.topOffParty(rcb) end, 'healer top off 2')
  	else 
  		callback()
  	end
    display('lowest is ' .. lowest .. ' at ' .. tostring(dHealth))
    
  end)
end


healer.cast = function(target)
	if (not player.equippingSet) then
    	echo('\n\n Time for a heal!\n\n')
    	send('cast ' .. healer.spell .. ' ' .. target)
    	healer.queued = healer.queued + 1
	else
		echo('\n\nholding heals til gear is swapped!\n\n')
	end
end


-- healer.setSpell = function (spell, cost, avg_heal, max_heal) 
	-- healer.spell = spell
	-- healer.spell_cost = cost
	-- healer.avg_heal = avg_heal
	-- healer.max_heal = max_heal
-- end



healer.reduceQueued = function()
	if (healer.queued &gt; 0) then
		healer.queued = healer.queued - 1
	else 
		echo('\nERROR: attempted to reduce heal queue past zero!!!\n')		
	end
end

healer.clearQueued = function ()
	healer.queued = 0
end


healer.healthStates = {
 ['perfect health'] = 1,
 ['slightly scratched'] = 0.95,
 ['few bruises'] = 0.85,
 ['some cuts'] = 0.75,
 ['several wounds'] = 0.65,
 ['badly wounded'] = 0.55,
 ['many nasty wounds'] = 0.45,
 ['bleeding freely'] = 0.35,
 ['covered in blood'] = 0.25,
 ['leaking guts'] = 0.15,
 ['mostly dead'] = 0.1,
 ['stunned'] = 0,
 ['incapacitated'] = 0,
 ['mortally wounded'] = 0,
 ['dead'] = 0
}



healer.getPrepped = function ()
  if (gmcp.Char.Score.class == 'paladin') then
    return math.floor(gmcp.Char.Vitals.en / healer.spell_cost)
  end
  
	return (player.prepped[healer.spell] or 0) - healer.queued
end


healer.check_player_health = function (player)
	
	if (player == group.leader) then	
		healer.check_health()
		return
	end
	
	
	if ( group.data[player] ) then

  local status = group.data[player]

  	local ehpl = status.hp + ( healer.queued * healer.avg_heal )
  	local heal_threshold_player = status.hp_max - healer.healAt.party.hp -- healer.avg_heal + 
		
		local heal_threshold_player_min = status.hp_max * healer.healAt.party.pct
		
		if ( heal_threshold_player &lt; heal_threshold_player_min) then
			heal_threshold_player = heal_threshold_player_min
		end
  	
  	cecho(' |&lt;orange&gt;' .. player .. '&lt;reset&gt;| ' .. tostring(ehpl) .. 'ehp, h@' .. tostring(heal_threshold_player) )
		
  	if (ehpl &lt; heal_threshold_player and healer.getPrepped() &gt; 0) then
			healer.cast(player)
  	end
	
	end
	
end


-- this is the tank check function
healer.check_health = function() 

	-- can't check until after initial setup has completed
	if (group.leader and group.data[group.leader] ) then
  
    local status = group.data[group.leader]
  	
  	local ehp = status.hp + ( healer.queued * healer.avg_heal )
    
  	local heal_threshold = status.hp_max - healer.healAt.tank.hp -- healer.avg_heal + 
		local heal_threshold_min = status.hp_max * healer.healAt.tank.pct
		
		if ( heal_threshold &lt; heal_threshold_min) then
			heal_threshold = heal_threshold_min
		end	
		
		cecho(' |&lt;green&gt;' .. group.leader .. '&lt;reset&gt;| ' .. tostring(ehp) .. 'ehp h@' .. tostring(heal_threshold) )
		
  	-- echo(' &lt;- ' .. tostring(ehp) .. 'ehp, heal@ ' .. tostring(heal_threshold) .. 
			-- 'hp, prep: ' .. tostring(healer.getPrepped()) .. ', queued: ' .. healer.queued )
  	
  	if (ehp &lt; heal_threshold and healer.getPrepped() &gt; 0) then
  		healer.cast(group.leader)
  	end

	end



end

healer.checkGroup = function()
	-- cecho('\n&lt;green&gt;HEALER: &lt;white&gt;Group was scanned\n')
	for member,v in pairs(group.members) do
		healer.check_player_health(member)
	end
end


healer.destroy = function ()

	if(healer.promptHandler) then
		killAnonymousEventHandler(healer.promptHandler)
	end

	if(healer.roomChangeHandler) then
		killAnonymousEventHandler(healer.roomChangeHandler)
	end
	
	if(healer.checkGroupHandler) then
		killAnonymousEventHandler(healer.checkGroupHandler)
	end

end


healer.init = function ()

	healer.destroy()
	
  -- healer.promptHandler = registerAnonymousEventHandler(common.events.PARSED_PROMPT, healer.check_health)
  healer.roomChangeHandler = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, healer.clearQueued)
	healer.checkGroupHandler = registerAnonymousEventHandler(common.events.PARSED_GMCP_GROUP, healer.checkGroup)

end

if (player.healer) then
  healer.init()
end




healer.prepHeals = function(amount, callback)
  
	local lcb = callback
	local prepped = healer.getPrepped() or 0
	
	if ( prepped &gt;= amount) then
		
		-- already prepped
		echo('\n\nAlready had enough spells prepped!!\n')
		if (lcb) then
			lcb()
		end	
		
	else

		-- need to prep, may need to get mana first...
		
		local prepSpell = function() 
			
		  send('stand')
			expandAlias('prep start')
			common.prep(healer.spell, amount, function () 
				expandAlias('prep end')
				expandAlias('st')
				
				common.onNextEvent(common.events.PARSED_PREPARED, function()
  				if (lcb) then
    				lcb()
  				end
				end)
				
				send('|prep')
				
    	end)
		end
		
		local manaRequired = (amount - prepped) * healer.spell_cost

		if (player.mp &lt; manaRequired) then

    	expandAlias('sl')	
      common.onManaReady(manaRequired, function () 
				prepSpell()
      end)
		
		else
			prepSpell()
		end


	end
	

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>prep</name>
				<packageName></packageName>
				<script>-- i think this is all moved to tfe-cleric?

-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
prep = prep or {}
common = common or {}

player.reserve_mp = player.reserve_mp or 0



function setPrepMode (mode)
	prepMode = mode
end



common.getManaAndCast = function(mana, spell, target, allowSleep, callback)
 
 	-- if casting is currently disabled do this later...
 	if(player.prepping) then	
		cecho('\n\n&lt;red&gt;PREP: &lt;white&gt;casting is currently disabled, delaying cast of ' .. spell .. '\n\n')
		send('+mutter &amp; remove orb.supplication &amp; stand')
  	player.prepping = false
			
		common.getManaAndCast(mana, spell, target, allowSleep, function ()
			player.prepping = true
			send('stand &amp; wear orb.supplication')
			if (prep.spell) then	
				send('prep ' .. prep.spell)
			end
			callback()
		end)
  			
				
		return
	end
 
 
	common.updateStatus( function ()
	
		local self = group.data[player.name]
		
		if (self.mp_max &lt; mana) then
			cecho('\n&lt;green&gt;PREP: &lt;white&gt;Need &gt; ' .. tostring(mana) .. ' max mana to cast ' .. spell .. '\n')
			
			if (allowSleep) then 
				send('stand')
			end
			
			healer.cast('self')
			player.prepPendingTimer = tempTimer(2, function ()
				player.prepPendingTimer = nil
				common.getManaAndCast(mana, spell, target, allowSleep, callback)
			end)
			
		else
			-- got enoough max mana, now check for available mana...
			if (self.mp &lt; mana) then
				cecho('\n&lt;green&gt;PREP: &lt;white&gt;Need &gt; ' .. tostring(mana) .. ' mana to cast ' .. spell .. '\n')
  			if (allowSleep) then 
  				send('sleep')
  			end
				player.prepPendingTimer = tempTimer(10, function ()
					player.prepPendingTimer = nil
  				common.getManaAndCast(mana, spell, target, allowSleep, callback)
  			end, 'waiting for mana')
				
			else
			
				if (allowSleep) then 
    				send('stand')
    			end
				
				local targetNotFound = false
				
				if (target) then
					local regexp =  '^Nothing found matching "' .. rex.gsub(target, [[\.]], ' ') .. '"\\.'
					-- cecho('\n&lt;yellow&gt;PREP: &lt;white&gt;regex for nothing found is: ' .. regexp .. '\n')
					common.timedTempTrigger(9, 1, regexp, function ()
						-- cecho('\n&lt;yellow&gt;PREP: &lt;white&gt;regex for nothing found was triggered\n')
  					targetNotFound = true
  				end)
				end	
	
        -- don't retry if we don't know the spell 
        local knownSpell = true  
        timedTempTrigger(2, 1, [[^You don't know the spell ]] .. spell ..[[\.$]], function () 
      		knownSpell = false
        end)			
        	
				common.timedTempTrigger(2, 1, [[^You cannot do that while sleeping\.]], function ()
					common.timedTempTrigger(3, 1, [[\+\+\+ You cast ]] .. spell .. [[ \+\+\+]], function ()
						send('sleep')
					end, function ()
						send('sleep')
					end)
					send('stand &amp; cast ' .. spell .. ' ' .. target)
				end)

				
				-- on spell cast call the callback. otherwise retry in 10 seconds
				common.timedTempTrigger(10, 1, [[\+\+\+ You cast ]] .. spell .. [[ \+\+\+]], callback, function ()
					cecho('\n&lt;orange&gt;PREP: &lt;white&gt;failed to cast ' .. spell .. '\n')
					
					if (targetNotFound) then
						cecho('&lt;red&gt;PREP: &lt;white&gt;target was not found ' .. target .. '\n')
					elseif (not knownSpell) then
            cecho('&lt;red&gt;PREP: &lt;white&gt;what sort of muppet doesn\'t know ' .. spell .. '\n')
            send('gt I lack the basic skill required to cast ' .. spell .. ' and should be ashamed') 
          else
						-- cecho('\n&lt;yellow&gt;PREP: &lt;white&gt;target didnt fail ' .. target .. '\n')
						common.getManaAndCast(mana, spell, target, allowSleep, callback)
					end
					
				end)
				
				send('cast ' .. spell .. ' ' .. target)
			
				-- Nothing found matching "dark crystal goblet".
			
			end
			
			
		
		end
		
	
	end)
	
	
end

common.killPrep = function(triggersOnly)
	
	if (prep.retryTimer) then
		killTimer(prep.retryTimer)
    prep.retryTimer = nil
	end  
  
  if (prep.prepPrepDestruct) then
    prep.prepPrepDestruct()
    prep.prepPrepDestruct = nil
  end
	
  
	if (not triggersOnly) then
		cecho('\n&lt;orange&gt;PREP: &lt;white&gt; canceled any existing prepping and ended prep mode')
		send('+sigh')
		
		prep.spell = nil

		if (prep.prepCompleteCallback) then
    	prep.prepCompleteCallback()
    	prep.prepCompleteCallback = nil
    end

	else
		cecho('\n&lt;orange&gt;PREP: &lt;white&gt; canceled any existing prep triggers/timers ')
	end
	
end


common.getPrepAmount = function(spell_cost, reserve_mp)
  reserve_mp = reserve_mp or 0
  return math.floor((gmcp.Char.Vitals.en - reserve_mp) / spell_cost)
end


common.prep = function(spell, prep_amount, callback)
	
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;prepping ' .. spell .. ' with free mana (' .. tostring(player.mp) .. ')')
  
	prep.spell = spell
  
	prep.prepCompleteCallback = callback or function() end
	
  local prepped = (player.prepped[spell] or 0)
  	  
	-- check if we are already prepped... (or don't need to prep due to no spell)
	if (spell ~= '' and prepped &lt; prep_amount) then
 	
    prep.prepPrepDestruct = njs50.cast(spell, {
      mode = 'prepare', 
      callback = function() 
        prep.prepPrepDestruct = nil
        
        if (prepped &gt;= prep_amount) then
          prep.prepCompleteCallback()
          prep.prepCompleteCallback = nil
        else
          -- prep another..
          common.prep(spell, prep_amount, callback)
        end
      end,
      failCallback = function(err)
        prep.prepPrepDestruct = nil
        send('gstat ' .. err .. ', retrying in 15')
        cecho('\n&lt;red&gt;PREP: &lt;white&gt;prep fail: ' .. err .. ', retrying in 15\n\n')
        prep.retryTimer = tempTimer(15, function()
          common.prep(spell, prep_amount, callback)
        end, 'prep retry')
      end,
    })
  

		
	else -- already prepped!
		echo(' &lt;-- already prepped')
		if (prep.prepCompleteCallback) then
			prep.spell = nil
			prep.prepCompleteCallback()
      prep.prepCompleteCallback = nil
		end
	end
	
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>casting / respell</name>
				<packageName></packageName>
				<script>-- first check if we need to re-up BM
njs50 = njs50 or {}

njs50.cast = function (spell, options)
  
  -- target, callback, failCallback
  options = options or {}
  
  options.mode = options.mode or 'cast'
  
  local legitModes = {
    cast = true,
    prepare = true,
    perform = true
  }
  
  if (not legitModes[options.mode]) then
    throw('invalid mode for njs50.cast: ' .. options.mode)
    return
  end
  
  if rex.match(spell, [[^rite of]]) then
    options.mode = 'perform'
  end
  
  local target = options.target
  local callback = options.callback
  local failCallback = options.failCallback

-- You don't know the spell hardiness.
-- Unknown spell.
-- You need a brown duck feather to cast float.
-- The room doesn't contain any beings matching "nutjob".
-- +++ You cast bless +++
  
  -- handle being webbed!
  -- You can't cast spells while entangled.
  -- You break out of the web holding you.
  
  -- handle missing target
  -- Nothing found matching "gem bright".
  
  
  -- prepare messages:
  -- &gt;&gt; Your restoration preparation is disrupted. &lt;&lt;
  -- You have prepared restoration.
  
  -- castFailedSilenced = You can't prepare spells while silenced.
  
  -- notStanding = Perhaps you should stand first.
  
  -- You cannot cast healing rain while fighting. 
  

  
  -- You abort performing rite of destruction.
  
  local spellUnprepped, spellUnknown, castFailedSleep, castFailedCombat
  
  local castFailed, castFailedBank, reagentFail, missingTarget, notStanding, castFailedSilenced
  
  local castSuccess, shortMana, msg
  
  local cleanTriggers = function()
  
    if (spellUnprepped) then
    
      killTrigger(spellUnprepped)
      killTrigger(spellUnknown)
      killTrigger(castFailedSleep)
      killTrigger(castFailed)
      killTrigger(castFailedBank)
      killTrigger(reagentFail)
      killTrigger(notStanding)
      killTrigger(castFailedSilenced)
      killTrigger(castFailedCombat)
      
      if (missingTarget) then
        killTrigger(missingTarget)
      end
     
      killTrigger(castSuccess)
      -- killTrigger(shortMana)
    end
  end
 
  local leachSub = {
    ['protection/chaos'] = 'Prot Vs Chaos',
    ['protection/good'] = 'Prot Vs Good',
    ['protection/law'] = 'Prot Vs Law',
    ['protection/evil'] = 'Prot Vs Evil',
  }
  
  
  local cmd = '|' .. options.mode .. ' ' .. spell
  
  if (target and target ~= '') then
    cmd = cmd .. ' ' .. target
  end
  
  if (options.queueSpellImprove) then
    if (player.skills[spell] &lt; 10) then
      
      if (leachSub[spell]) then
        spell = leachSub[spell]
      end
      
      cmd = cmd .. ' &amp; wait 1 &amp; queue leech ' .. spell
    
      improves.queueSpell(cmd)
      
      tempTimer(0, function()
        if (callback) then callback() end
      end)
      
    else
    
      cecho('\n&lt;green&gt;RESPELL:&lt;white&gt; improve mode, skipping ' .. cmd .. '\n')
      tempTimer(0, function()
        if (callback) then callback() end
      end)
    end
  else
  
    if (target and target ~= '') then
      
      local nt = rex.gsub(target, [[\.]], " ")
      nt = rex.gsub(nt, [[([+|.])]], "\\%1") -- escape regexp chars
      missingTarget = tempRegexTrigger([[^Nothing found matching "]] .. nt .. [["\.$]], function()
        msg = 'failed due to missing target - ' .. target .. '?'
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end 
      end, 1)
    
    end
    
    
    -- different messages for performing, bleh
    if (options.mode == 'perform') then


      -- The current battle has you occupied.
      castFailedCombat = tempRegexTrigger([[^The current battle has you occupied\.$]], function()
        msg = 'failed due to combat - ' .. spell .. '?'
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end 
      end, 1)

      -- You don't know how to perform rite of imprecation.
      spellUnknown = tempRegexTrigger([[^(Unknown performance|You don't know how to perform ]] .. spell .. [[)\.$]], function()
        msg = 'failed due to unkown spell - ' .. spell .. '?'
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end 
      end, 1)    
      
      -- &gt;&gt; Your rite of destruction performance is disrupted. &lt;&lt;     
      castFailed = tempRegexTrigger([[^&gt;&gt; Your ]] .. spell .. [[ performance is disrupted. &lt;&lt;$]], function ()
        msg = 'performing ' .. spell .. ' was disrupted'
        send('stand')
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end    
      end, 1)   
     
      castSuccess = tempRegexTrigger([[^(\+\+\+ You perform ]] .. spell .. [[ \+\+\+)$]], function ()
        cecho('\n&lt;green&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;spell - ' .. spell .. '!\n\n')
        cleanTriggers()
        if (callback) then callback() end
      end, 1)  
          
       
    else
 
     
      -- You cannot cast healing rain while fighting. 
      castFailedCombat = tempRegexTrigger([[^You cannot cast ]] .. spell .. [[ while fighting\.$]], function()
        msg = 'failed due to combat - ' .. spell .. '?'
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end 
      end, 1)
 
       
      spellUnknown = tempRegexTrigger([[^(Unknown spell|You don't know the spell ]] .. spell .. [[)\.$]], function()
        msg = 'failed due to unkown spell - ' .. spell .. '?'
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end 
      end, 1)   
      
      castFailed = tempRegexTrigger([[^&gt;&gt; Your ]] .. spell .. [[ (casting|preparation) is disrupted. &lt;&lt;$]], function ()
        if (options.mode == 'prepare') then
          msg = 'casting ' .. spell .. ' was disrupted'
        else
          msg = 'preparing ' .. spell .. ' was disrupted'
        end
        send('stand')
        cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
        cleanTriggers()
        if (failCallback) then failCallback(msg) end    
      end, 1)          
      
      
      if (options.mode == 'prepare') then
  
        castSuccess = tempRegexTrigger([[^(You have prepared ]] .. spell .. [[\.|You now have \d+ incantations of ]] .. spell .. [[ prepared\.)$]], function ()
          cecho('\n&lt;green&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;spell - ' .. spell .. '!\n\n')
          cleanTriggers()
          -- delay cb execution to allow prep count to be updated
          if (callback) then tempTimer(0, function()          
            callback()
          end, 'delayed execution') end
        end, 1)      
          
      else
        
        castSuccess = tempRegexTrigger([[^(\+\+\+ You cast ]] .. spell .. [[ \+\+\+)$]], function ()
          cecho('\n&lt;green&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;spell - ' .. spell .. '!\n\n')
          cleanTriggers()
          if (callback) then callback() end
        end, 1)    
        
      end     
          
    end

    -- You don't have tornado prepared.
    spellUnprepped = tempRegexTrigger([[^You don't have ]] .. spell .. [[ prepared\.$]], function()
      msg = 'failed due to unprepped spell - ' .. spell .. '?'
      cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end 
    end, 1)

    
    castFailedSleep = tempRegexTrigger([[^You cannot do that while sleeping$]], function ()
      msg = 'failed to do something while sleeping - ' .. spell .. '?'
      cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end        
    end, 1)  
    

    
    castFailedBank = tempRegexTrigger([[^As you cast ]] .. spell .. [[, you feel the energy drain from you and nothing happens\.$]], function ()
      msg = 'casting ' .. spell .. ' failed due to no magic room'
      cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end    
    end, 1)
    
    -- You can't cast spells while silenced.
    -- You can't prepare spells while silenced.
    castFailedSilenced = tempRegexTrigger([[^You can't (cast|prepare) spells while silenced\.$]], function ()
      msg = matches[2] .. ' ' .. spell .. ' failed due to being silenced'
      cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end    
    end, 1)
    
      
    -- As you cast float
    
    -- watch for this on timerout trig then recast? You stand up.
    notStanding = tempRegexTrigger([[^Perhaps you should stand first\.$]], function ()
      msg = 'failed to do something while sleeping - ' .. spell .. '?'
      cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end  
    end, 1)
    
    
    
    reagentFail = tempRegexTrigger([[^You need (.*) to (cast|prepare|perform) ]] .. spell .. [[\.$]], function ()
      msg = 'missing ' .. matches[2] .. ' to ' .. matches[3] .. ' ' .. spell
      cecho('\n&lt;red&gt;' .. string.upper(options.mode) .. ': &lt;white&gt;' .. msg .. '\n\n')
      cleanTriggers()
      if (failCallback) then failCallback(msg) end
    end, 1)
    
    -- this is caught by the missing reagent pattern above
    -- You need 75 energy points to cast summon.
    -- shortMana = tempRegexTrigger([[^You need \d+ energy points to cast ]] .. spell .. [[\.$]], function ()
      -- msg = 'not enough mana to cast ' .. spell
      -- cecho('\n&lt;red&gt;CAST: &lt;white&gt;' .. msg .. '\n\n')
      -- cleanTriggers()
      -- if (failCallback) then failCallback(msg) end
    -- end, 1)
    
    -- You now have 2 incantations of restoration prepared.
    -- You have prepared restoration.

  
  
  
  
    send(cmd)
  end
  
  -- return a self destruct function
  return cleanTriggers

end

-- buffs = {
  -- sustenance = 'You are being sustained.',
  -- bless = 'You feel righteous.',
-- }

njs50.cancelPendingRespell = function()
  player.pendingRespell = nil
end


njs50.defaultRespell = function(cb)
   njs50.respell(player.buffs, {
    target = 'gstat', 
    callback = function()
      if (cb) then cb() end
    end
  })
end

njs50.respell = function (buffs, options)

  options = options or {}

  local target = options.target or 'gstat'
  local cb = options.callback
  local fcb = options.failCallback
  local queueSpellImprove = options.queueSpellImprove
  
  if not fcb then
    fcb = function()
      send('queue ' .. target .. ' respell failed, trying again in 15s')
      tempTimer(15, function()
        njs50.respell(buffs, options)
      end, 'retry respell')
    end
  end
  
  
  if (lw) then
  
    if (target and target ~= '') then
      send('queue ' .. target .. ' respell is already queued')
    end
    
  else
    
    local co
    
    player.pendingRespell = true
    
    common.getAffects( function (affects)
      
      local respellFailed = false
      local failMessage = ''
  
      local recast = {}
      
      local isHiding = table.contains(gmcp.Char.Status.flags, 'hiding')
  
      for spell, affectText in pairs(buffs) do 
              
        if (not affects[affectText]) then
          table.insert(recast, spell)
        end
        
      end
            
      co = coroutine.create(function()
      
        if #recast &gt; 0 and player.gearSets and player.gearSets.respell then
          
          if isHiding then
            player.unhide = true
            send('unhide')
          end
          
          equipPartial('respell', function()
            coroutine.resume(co)
          end)
          coroutine.yield()
        end
      
        for idx, spell in ipairs(recast) do 
              
          if (not respellFailed and not affects[affectText]) then
            njs50.cast(spell, {
              queueSpellImprove = queueSpellImprove,
              callback = function ()
                if (options.cancelLeechForImproves and player.skills[spell] &lt; 10) then
                  send('|leech ' .. spell)
                end
                local ok, errorMsg = coroutine.resume(co)
                if not ok then
                  error("Error in co-routine respell: " .. errorMsg)
                end
              end,
              failCallback = function(msg)
                respellFailed = true
                failMessage = msg
                local ok, errorMsg = coroutine.resume(co)
                if not ok then
                  error("Error in co-routine respell: " .. errorMsg)
                end
              end
            })
            coroutine.yield()
            -- display('recast', spell)
          end 
  
        end
        
        player.pendingRespell = nil
        
        if #recast &gt; 0 and player.gearSets and player.gearSets.respell then
          resetGear(function()
            if isHiding then
              player.unhide = nil
              send('hide')
            end          
            coroutine.resume(co)
          end)
          coroutine.yield()
        end
        
        if (respellFailed) then
           
          cecho('\n&lt;red&gt;RESPELL: &lt;white&gt;failed! - ' .. failMessage .. '\n\n')
          
          if (target and target ~= '') then
            send('queue ' .. target .. ' ' .. failMessage .. ' (' .. player.name .. ')')
          end
          
          if fcb then fcb() end
               
        else
        
          cecho('\n&lt;green&gt;RESPELL: &lt;white&gt;completed!\n\n')
          if (group.memberCount &gt; 1 and target and target ~= '') then
            send('queue ' .. target .. ' respell done (' .. player.name .. ')')
          end
          
          njs50.onNextEvent(common.events.PARSED_INVENTORY, function()
            if (cb) then tempTimer(0, cb) end
          end)
          send('inventory')
  
        end
        
      end)  
    
      local ok, errorMsg = coroutine.resume(co)
      if not ok then
        error("Error in co-routine respell: " .. errorMsg)
      end
      
    end)
    
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Damage Meter</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>damage meter</name>
				<packageName></packageName>
				<script>damageMeter = damageMeter or {}

damageMeter.start = function ()

  if (damageMeter.combatEndWatcher) then
    killAnonymousEventHandler(damageMeter.combatEndWatcher)
    damageMeter.combatEndWatcher = nil
  end
  
  damageMeter.combatEndWatcher = registerAnonymousEventHandler(common.events.COMBAT_ENDED, damageMeter.combatTimer)


  damageMeter.reset()
  damageMeter.startTime = getEpoch()
  damageMeter.recording = true
  damageMeter.combatTime = 0
end

damageMeter.stop = function ()
  damageMeter.stopTime = getEpoch()
  damageMeter.recording = false
end

local updateDamageRecord = function(record, amount) -- , type
  record.count = record.count or 0
  record.count = record.count + 1
  record.amount = record.amount or 0
  record.amount = record.amount + amount
  -- record.spells = record.spells or {}
  
  -- if (type) then
    -- record.type = type
  -- end
  -- i don't think we need to keep this...
  -- record.amounts = record.amounts or {}
  -- table.insert(record.amounts, amount)
end

damageMeter.record = function (dealer, amount, target, type, spell)

  -- echo(' &lt;- ' .. type .. ' ' .. dealer .. ' : ' .. tostring(amount))
  -- deleteLine()
  
  -- if (type == 'no-damage') then
    -- cecho('\n\n&lt;green&gt;[DAMAGE METER] &lt;white&gt;non damage hit ' .. spell .. '\n\n')
  -- end
  
  if (damageMeter.recording) then
  
    damageMeter.byMember[dealer] = damageMeter.byMember[dealer] or {}
  
    local record = damageMeter.byMember[dealer]
  
    -- record.spell = record.spell or {}
    record.type = record.type or {}

    record.type[type] = record.type[type] or {}
    record.type[type].spells = record.type[type].spells or {}
    record.type[type].spells[spell] = record.type[type].spells[spell] or {}
    
    -- record.spell[spell] = record.spell[spell] or {}
  
    updateDamageRecord(record.type[type], amount)
    updateDamageRecord(record.type[type].spells[spell], amount)
    
    -- updateDamageRecord(record.spell[spell], amount, type)
  
  end

end

damageMeter.reset = function ()
  damageMeter.recording = false
  damageMeter.stopTime = nil
  damageMeter.byMember = {}
  -- damageMember.byTarget = {}
end

damageMeter.report = function(target, chan)

  chan = chan or 'cecho'

  if (target and group.members[target]) then
    damageMeter.reportPlayer(target, chan)
    return
  end
  
  
  local time = damageMeter.combatTime or 1
  local elapsedTime = (damageMeter.stopTime or getEpoch()) - damageMeter.startTime
  
  
  common.sendToChan(chan, '\n&lt;green&gt;Damage')
  common.sendToChan(chan, '&lt;white&gt;Combat Time: ' .. common.formatElapsedTime(time))
  common.sendToChan(chan, '&lt;white&gt;Elapsed Time: ' .. common.formatElapsedTime(elapsedTime) .. '\n')
  
  
  for member, cats in pairs(damageMeter.byMember) do
    
    local total = 0
    
    for dt, stats in pairs(cats.type) do
      total = total + stats.amount
    end
    
    local dps = math.floor(100 * total / time) / 100
    
    common.sendToChan(chan,
      demonnic:cfText(
        member, 
        {
          alignment = "left", 
          width = 15, 
          spacer = ".", 
          inside = true, 
          textColor = "&lt;green&gt;"
        }
      ) ..
      demonnic:fText(
        tostring(dps), 
        {
          alignment = "right", 
          width = 10, 
          spacer = ".", 
          textColor = "&lt;white&gt;"
        }
      ) ..
      ' dps'
    ) 
  end
  
  if (target and target == 'all') then
    for player, data in pairs(damageMeter.byMember) do
      damageMeter.reportPlayer(player, chan)
    end
  end
  
end

damageMeter.reportPlayer = function(player, chan)

  local time = damageMeter.combatTime or 1
  local elapsedTime = (damageMeter.stopTime or getEpoch()) - damageMeter.startTime
  
  local total = 0
    
  for dt, stats in pairs(damageMeter.byMember[player].type) do
    total = total + stats.amount
  end
  
  
  common.sendToChan(chan, '\n&lt;green&gt;Damage by ' .. player)
  common.sendToChan(chan, '&lt;white&gt;Combat Time: ' .. common.formatElapsedTime(time))
  common.sendToChan(chan, '&lt;white&gt;Elapsed Time: ' .. common.formatElapsedTime(elapsedTime))
  common.sendToChan(chan, '&lt;white&gt;Damage output: ' .. tostring(math.floor(100 * total / time) / 100) .. ' dps\n')
  
  
  if (damageMeter.byMember[player].type.spell) then
    damageMeter.reportByType(chan, 'spell', damageMeter.byMember[player].type.spell, player)
  end
  
  if (damageMeter.byMember[player].type.melee) then
    damageMeter.reportByType(chan, 'melee damage', damageMeter.byMember[player].type.melee, player)
  end
  
  if (damageMeter.byMember[player].type.proc) then
    damageMeter.reportByType(chan, 'procs', damageMeter.byMember[player].type.proc, player)
  end
  
  if (damageMeter.byMember[player].type['no-damage']) then
    damageMeter.reportByType(chan, 'non damage', damageMeter.byMember[player].type['no-damage'], player)
  end


  if (damageMeter.byMember[player].type['avoidance']) then
    damageMeter.reportByType(chan, 'avoidance', damageMeter.byMember[player].type['avoidance'], player)
  end
  
  if (damageMeter.byMember[player].type.reflect) then
    damageMeter.reportByType(chan, 'reflect', damageMeter.byMember[player].type.reflect, player)
  end


end

damageMeter.reportByType = function(chan, type, rollup, player)

  local data = rollup.spells

  -- 
  testMaker = demonnic.TableMaker:new({
    edgeCharacter = '|'
  })
  
  local meleeHits = 1
  local avoidanceHits = 1
  
  if (damageMeter.byMember[player].type.melee) then
    meleeHits = damageMeter.byMember[player].type.melee.count or 1
  end
  
  if (damageMeter.byMember[player].type.avoidance) then
    avoidanceHits = damageMeter.byMember[player].type.avoidance.count or 1
  end  
  
 
  local time = damageMeter.combatTime or 1

  local dataKeys = table.keys(data)
  
  if (type == 'non damage') then
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "% melee", width = 20, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].count &gt; data[b].count end)
  elseif (type == 'avoidance') then
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "average", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "% attacks", width = 20, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].count &gt; data[b].count end)    
  else
    testMaker:addColumn({name = type, width = 25, textColor = "&lt;green&gt;"})
    testMaker:addColumn({name = "average", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "count", width = 10, textColor = "&lt;white&gt;"})
    testMaker:addColumn({name = "dps", width = 10, textColor = "&lt;purple&gt;"})
    table.sort(dataKeys, function(a,b) return data[a].amount &gt; data[b].amount end)
  end
  
  for idx, spell in ipairs(dataKeys) do
  
    local stats = data[spell]
    
    local avg = math.floor(10 * stats.amount / stats.count) / 10
    local dps = math.floor(100 * stats.amount / time) / 100    
    local pctMelee = math.floor(10000 * stats.count / meleeHits)  / 100
    
    
    local calcSpecialPct = function(otherSpell, otherType)
      local chargeCt = damageMeter.byMember[player].type[otherType].spells[otherSpell].count or 0
      chargeCt = chargeCt + stats.count
      return math.floor(10000 * stats.count / chargeCt) / 100    
    end
    
    
    
    if (type == 'non damage') then
      if (spell == 'fall down') then 
        pctMelee = calcSpecialPct('charge', 'melee')
        testMaker:addRow({'charge: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})
      elseif (spell == 'charge_miss') then 
        pctMelee = calcSpecialPct('charge', 'melee')
        testMaker:addRow({spell, tostring(stats.count), tostring(pctMelee) .. '%'})        
      elseif (spell == 'revealing') then 
        pctMelee = calcSpecialPct('reveals nothing', 'no-damage')
        testMaker:addRow({'stones: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})     
      elseif (spell == 'reveals nothing') then 
        pctMelee = calcSpecialPct('revealing', 'no-damage')
        testMaker:addRow({'stones: ' .. spell, tostring(stats.count), tostring(pctMelee) .. '%'})               
      else 
        testMaker:addRow({spell, tostring(stats.count), tostring(pctMelee) .. '%'})
      end
      
    elseif (type == 'avoidance') then  
      pctMelee = math.floor(10000 * stats.count / avoidanceHits)  / 100
      testMaker:addRow({spell, tostring(avg), tostring(stats.count), tostring(pctMelee) .. '%'})
    elseif (type == 'reflect') then

    local avg = math.floor(10 * stats.amount / stats.count) / 10
    local dps = math.floor(100 * stats.amount / time) / 100    
        
      testMaker:addRow({spell, tostring(avg), tostring(stats.count), tostring(dps)})      
      
    else
      testMaker:addRow({spell, tostring(avg), tostring(stats.count), tostring(dps)})
    end
    
  end
      
  if (type ~= 'non damage' and type ~= 'avoidance') then
    testMaker:addRow({
      'total', 
      tostring(math.floor(10 * rollup.amount / rollup.count) / 10), 
      tostring(rollup.count), tostring(math.floor(100 * rollup.amount / time) / 100)
    })
  end
  
  common.sendToChan(chan, testMaker:assemble())

end

damageMeter.combatTimer = function(evt, duration) 
  damageMeter.combatTime = damageMeter.combatTime + duration
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>damageMeter.hit</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

damageMeter = damageMeter or {}

damageMeter.hit = function(evt, attackData)
  if (damageMeter.recording) then
    damageMeter.record(attackData.subject, attackData.damage, attackData.mob, attackData.damageType, attackData.move)
  end
end</script>
				<eventHandlerList>
					<string>COMMON::combat_attack</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.hit</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

combat = combat or {}

combat.display = combat.display or {}

combat.moveSub = {
  ['Your electric spark' ] = 'ion',
  ['Your thorn shield' ] = 'ts',
  ['Your fire shield' ] = 'fs',
  ['Your ice shield' ] = 'ice',
  ['electric spark' ] = 'ion',
  ['thorn shield' ] = 'ts',
  ['fire shield' ] = 'fs',
  ['ice shield' ] = 'ice',
  ['Your charged chop'] = 'flashstrike',
  
}

combat.hit = function(evt, attackData)

  if (njs50.ui.useCombatTab) then
  
    if (not njs50.ui.renderCombatBlock) then
      njs50.ui.combatBlock = {}
      njs50.ui.renderCombatBlock = tempTimer(0, function()
        njs50.ui.renderCombatBlock = nil        
        for subj, moves in pairs(njs50.ui.combatBlock) do          
          cecho('&lt;green&gt;' .. subj .. '&lt;white&gt;: ' .. table.concat(moves, ', ') .. '\n')
        end
        
      end, 'render combat block')
    end
  
    common.chatConsole:append('Combat', true)
    deleteLine()
    
    -- display(attackData)
    
    njs50.ui.combatBlock[attackData.subject] = njs50.ui.combatBlock[attackData.subject] or {}
    
    local str = combat.moveSub[attackData.move] or attackData.move
    
    if attackData.damageType == 'no-damage' then
      str = '&lt;orange&gt;' .. str .. '&lt;white&gt;'
    end
    
    
    if attackData.damageType == 'weapon-proc' then
      str = '&lt;purple&gt;' .. str .. '&lt;white&gt;'
    end    
    
    if (attackData.damage and attackData.damage &gt; 0) then
      str = str .. ':' 
      if (attackData.move == 'hit' or attackData.damageType == 'reflect') then
        str = str .. '&lt;red&gt;' .. attackData.damage .. '&lt;white&gt;'
      else
        str = str .. '&lt;green&gt;' .. attackData.damage .. '&lt;white&gt;'
      end
    end
    
    
    table.insert(njs50.ui.combatBlock[attackData.subject], str)
    
    
  end
  
end</script>
				<eventHandlerList>
					<string>COMMON::combat_attack</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>auto assist</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>auto_assist</name>
				<packageName></packageName>
				<script>combat = combat or {}
player = player or {}

combat.assistOffCooldown = true

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.auto_assist_on_attack</name>
				<packageName></packageName>
				<script>

combat.auto_assist_on_attack = function (evt, attackData)
  
  if ( group.leader and 
     player.name ~= group.leader and 
     attackData.subject == group.leader and 
     combat.assistOffCooldown == true and 
     combat.active ~= true
  ) then
    
    combat.assistOffCooldown = false    
    -- enable assist again after 1 second (prevent excessive spam before gmcp combat starts)
    tempTimer(1, function () 
      combat.assistOffCooldown = true
    end)

    local target = common.dotCase(common.toMurderString(attackData.mob))
    
    player.autoAttack(target)
    
  end
  
end
</script>
				<eventHandlerList>
					<string>COMMON::combat_attack</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>combat.auto_assist_on_room_change</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
combat.auto_assist_on_room_change = function ()
  cecho('&lt;green&gt;&lt;-- room changed')
  combat.assistOffCooldown = true
  
end</script>
				<eventHandlerList>
					<string>tfe mapper: room found</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>bitches for clan</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>clan.checkBitches</name>
				<packageName></packageName>
				<script>clan = clan or {}

clan.acceptableMasters = clan.acceptableMasters or {
  Gnoggh = true,
  Taldoran = true,
  Trongle = true,
  Marsuvious = true,
  Mojune = true,
  Mohoonay = true,
  Myrth = true,
  Darion = true,
  Darius = true,
  Grehild = true,
  Bimgore = true,
  Eluard = true,
  Raksha = true,
  Gnodrick = true,
  Shazzul = true,
  Tohnife = true,
  Amanita = true,
  Uduvrin = true,
  Gnodrick = true,
  Quorrel = true,
  Drulethan = true,
  Umarra = true,
  Gnomigs = true,
  Trea = true,
  Chundrick = true,
  Brazden = true,
  Bede = true,
  Darrarki = true,
  Lacopa = true,
}

clan.checkBitches = function(evt, who)

  -- display(who.Befriended[player.name].clan)
  
  if (who.Befriended[player.name] and who.Befriended[player.name].clan ~= ' -- ') then
    
    clan.online = who.clan[who.Befriended[player.name].clan]
  
    for name, playa in pairs(clan.online) do
      if (not clan.acceptableMasters[name]) then
        clan.acceptableMasters[name] = true
        cecho('&lt;green&gt;CLAN:&lt;white&gt; bitches granted to ' .. name .. ' due to clan member\n')
      end
    end
  
  end
  

end</script>
				<eventHandlerList>
					<string>COMMON::parsed_who</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>auto reconnect</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>autoconnect</name>
				<packageName></packageName>
				<script>autoconnect = autoconnect or {}

autoconnect.enabled = autoconnect.enabled or false
autoconnect.destination = autoconnect.destination or 'med'

autoconnect.connectionEvent = function()
  cecho('\n&lt;green&gt;AUTOCONNECT: &lt;white&gt;connected to server\n')
  autoconnect.connected = true
  
end

autoconnect.disconnectEvent = function()
  cecho('\n&lt;red&gt;AUTOCONNECT: &lt;white&gt;disconnected from server\n')
  autoconnect.connected = false
  autoconnect.checkConnection()
end

autoconnect.checkConnection = function()

  if autoconnect.enabled and not autoconnect.connected then
    cecho('\n&lt;orange&gt;AUTOCONNECT: &lt;white&gt;reconnecting...\n')
    autoconnect.reconnect()
  end

end

autoconnect.reconnect = function()

  reconnect()
  tempTimer(15, autoconnect.checkConnection, 'checking connection after 15s')

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>autoconnect.connectionEvent</name>
				<packageName></packageName>
				<script>
</script>
				<eventHandlerList>
					<string>sysConnectionEvent</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>autoconnect.disconnectEvent</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList>
					<string>sysDisconnectionEvent</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>random junk</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>imp-tools</name>
				<packageName></packageName>
				<script>murder = murder or {}

murder.attackCommand = 'kill'
murder.weapon = 'blunt.dagger'
murder.smokeTilWis = 12

murder.fightSet = 'imps-tank' -- imps-tank (or imps)

murder.smokeSet = 'imps-no-wis'

murder.improveHelper = murder.improveHelper or 'Lacopa'

murder.fleeForSoup = function()
  
  disableTimer('rescue-imps')
  murder.doAck('Grehild', 
    '+stand &amp; queue flee west &amp; queue flee west &amp; ' ..
    'queue flee west &amp;  queue flee west &amp; queue west &amp; queue west &amp; queue east &amp; ' ..
    'queue drink soup &amp; queue drink soup &amp; queue drink soup', 
    function()
      
      murder.doAck('Mojune', 'queue stand', function()
        send('west &amp; drink soup &amp; drink soup &amp; drink soup')
          murder.doAck('Mojune', 'drink soup &amp; drink soup &amp; drink soup', function()
            send('east')
            murder.doAck('Grehild', 'east &amp; bash mojune', function()
              enableTimer('rescue-imps')
            end)
          end)
      end)    
    end
  )
    
end

murder.sendGrehildForSoup = function()
  
  murder.doAck('Grehild', 
    '+stand &amp; queue flee west &amp; queue flee west &amp; ' ..
    'queue flee west &amp;  queue flee west &amp; queue west &amp; queue west &amp; queue east &amp; ' ..
    'queue drink soup &amp; queue drink soup &amp; queue drink soup', 
    function()
      
      send('west &amp; drink soup &amp; drink soup &amp; drink soup &amp; drink soup &amp; drink soup')
      
      expandAlias('respell')
  
      murder.doAck('Grehild', 'east &amp; bash mojune', function()
        send('east')
      end)
          
    end
  )
    
end


murder.checkWis = function(cb)
  timedTempTrigger(10, 1, [[^\s*Str: .* Wis:\s*(\d+)]], function ()
    cb(tonumber(matches[2]))
  end, function()
    cecho('\n\n\n&lt;red&gt;PARSER:&lt;white&gt; failed to check wisdom!!!\n\n\n')
  end)
  send('score')
end


murder.checkPracs = function(cb)
  timedTempTrigger(60, 1, [[^\s*Practice Pnts:\s*(\d+)]], function ()
    cb(tonumber(matches[2]))
  end, function()
    cecho('\n\n\n&lt;red&gt;PARSER:&lt;white&gt; failed to check pracs!!!\n\n\n')
  end)
  send('|score')
end

murder.checkDamroll = function(cb)
  timedTempTrigger(10, 1, [[\s\s+Damroll:\s*\+(\d+\.\d+)]], function ()
    cecho('\n\n&lt;green&gt;PARSER:&lt;white&gt; damroll is: ' .. matches[2] .. '\n')
    cb(tonumber(matches[2]))
  end, function()
    cecho('\n\n\n&lt;red&gt;PARSER:&lt;white&gt; failed to check damroll!!!\n\n\n')
  end)
  send('score')
end


murder.smokingEnabled = true


murder.smokeUp = function(sansWisSet, readySet, targetWis, callback)

 equipSet(sansWisSet, function()
    murder.checkWis(function(currentWisdom)
      if (murder.smokingEnabled) then
        for i = currentWisdom + 1, targetWis do
          send('pipe')
        end
      end
      equipSet(readySet, function()
        cecho('\n\n&lt;green&gt;IMPROVE BOT: &lt;white&gt;smoked up and ready to restart\n\n')
        callback()
      end)
    
    end)
  end)

end

-- currently hardcoded to tin ladle
murder.repairMainHand = function(callback)
   
   
   
   common.getWeaponCondition(function(weaponConditon)
   
      if (weaponConditon &lt; common.conditions.good) then
        -- time to repair weapon
        cecho('\n\n&lt;orange&gt;IMPROVE BOT: &lt;white&gt;time to repair ' .. murder.weapon .. '!!!\n\n')
        tfe.gotoRoom(144, function() 
          send('with youth.potion &amp; queue remove ' .. murder.weapon .. ' &amp; queue dip ' .. murder.weapon .. ' youth &amp; queue deposit youth.potion &amp; queue deposit all.coin &amp; queue with 10000')
          tfe.gotoRoom(131, function()
            send('repair ' .. murder.weapon .. ' &amp; wear ' .. murder.weapon)
            tfe.gotoRoom(170, function() 
              callback()
            end)
          end)
        end)
      
      else
      
        -- good to continue
        callback()
    
      end
            
  end)

end



murder.improveAttackFlee = function(callback)

  murder.doAck(murder.improveHelper, 
    '+stand &amp; flee west &amp; flee west &amp; ' ..
    'flee west &amp; flee west &amp; west &amp; west &amp; east &amp; ' ..
    'drink soup &amp; drink soup &amp; drink soup', 
    function()

      send('order all stand &amp; remove blanket,all.shield &amp; west &amp; drink soup &amp; drink soup &amp; drink soup')
      -- send('remove all.shield &amp; west &amp; drink soup &amp; drink soup &amp; drink soup')
      
      murder.checkPracs(function(pracs)
      
        if (pracs &gt; 450) then
          cecho('\n\nto many pracs!\n\n')
          expandAlias('quit')
          return
        else  
          cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
        end
        
        
        murder.repairMainHand(function()
        
          cecho('\n\n&lt;green&gt;IMPROVE BOT: &lt;white&gt;weapon is good to go\n\n')
          
          getLowestGearCondition(function(condition) 
          
            if (condition &lt; common.conditions['worn']) then
            
              send('tell ' .. murder.improveHelper .. ' bot stopped due to needing repair...')
              
            else
   
              -- this is where we could smoke some more tobacco.
              murder.smokeUp(murder.smokeSet, murder.fightSet, murder.smokeTilWis, function() -- 22 -&gt; 29 wis
                cecho('\n\n&lt;green&gt;IMPROVE BOT: &lt;white&gt;smoked up and good to go!\n\n')
                
                murder.doAck(murder.improveHelper, 'stand &amp; wraps &amp; east', function()
                  -- send('remove all.shield')
                  if (callback) then
                    callback()
                  else
                    send('east &amp; rem all.shield &amp; wear holy.shielding,all.shield &amp; ' .. murder.attackCommand .. ' mohoonay &amp; wear blanket')
                    -- send('east &amp; kill mojune')
                  end
                
                end)
                
              end)
              
            end
          end)
          
        end)
        
      end)

    end
  )


end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>leveling tools</name>
				<packageName></packageName>
				<script>tools = tools or {}

tools.weapCheck = function(failcb)
  common.getWeaponCondition(function(weaponConditon)
    -- display(weaponConditon)
    if (weaponConditon &lt; common.conditions["very worn"]) then
      cecho('\n\n&lt;green&gt;CHECK&lt;white&gt;: weapon needs fixing' .. tostring(weaponConditon) .. '\n\n')
      if (failcb) then failcb() end
    else
      cecho('\n\n&lt;green&gt;CHECK&lt;white&gt;: weapon okay still ' .. tostring(weaponConditon) .. '\n\n')
    end
  end)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>improves</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

improves = improves or {}

improves.castQueue = improves.castQueue or {}

improves.fillerSpell = 'filler'

improves.castFillerLastTick = true

improves.queueSpell = function(spell)
  if (not table.contains(improves.castQueue, spell)) then
	 table.insert(improves.castQueue, spell)
  end
end


improves.setFiller = function (spell)
	improves.fillerSpell  = spell
end

improves.resetFiller = function ()
	improves.fillerSpell = 'filler'
end




improves.castSpell = function (cb, finishedCB)
  
  cb = cb or function() end
  
	if (#improves.castQueue == 0) then
    
    cecho('\n\n -= improve filler =-\n\n')
    if type(improves.fillerSpell) == 'string' then 
  	  expandAlias(improves.fillerSpell)
      cb()
    elseif type(improves.fillerSpell) == 'function' then   
      improves.fillerSpell(cb, finishedCB)
    end
    
    improves.castFillerLastTick = true

	else

		if (improves.castFillerLastTick) then

			improves.castFillerLastTick = false
			cecho('\n\n -= holding filler for real spell next tick =-\n\n')
      cb()

		else

			local spell = table.remove(improves.castQueue, 1)
			improves.castFillerLastTick = true
			cecho('\n\n -= ' .. spell .. ' =-\n\n')
			send(spell)
      cb()

		end

	end

end

improves.defaultMageList = {
  'shock',
  'burning hands',
  'chilling touch',
  'corrosive touch',
  'fireball',
  'freeze',
  'lightning bolt',
  -- 'sleep',
  'acid blast',
  -- 'mists of sleep',
  'chain lightning',
  'ice storm',
  'flame strike',
  'acid storm',
  'arc lightning',
  'ice lance',
  'conflagration'
}

improves.druidAoeList = {
  'impede',
  'storm',
  'aqueous spirit',
  'xerotes',
}


improves.spellList = improves.spellList or improves.defaultMageList

improves.setImproveList = function (improveList)
  improves.spellList = improveList
end

improves.improveLeech = function (spell)
  if (player.skills[spell] &lt; 10) then
    improves.queueSpell('cast ' .. spell .. ' &amp; queue leech ' .. spell)
  else
    cecho('\n\n&lt;green&gt; ' .. spell .. ' is maxxed, hooray!\n')
  end
end

improves.getImproveSpellName = function ()

  if (#improves.spellList == 0) then
    return ''
  end

  player.impAttempt = player.impAttempt or 0

  player.impAttempt = (player.impAttempt % #improves.spellList) + 1

  local spell = improves.spellList[player.impAttempt]

  if (player.skills == nil) then
    send('abil all')
  else
    -- remove this maxxed out or unlearned spell and return the next one in the list
    if (player.skills[spell] == nil or player.skills[spell] &gt;= 10 or player.skills[spell] == 0) then
      cecho('\n&lt;yellow&gt;removing ' .. spell .. ' from impprove list\n')
      table.remove(improves.spellList, player.impAttempt)
      return improves.getImproveSpellName()
    end
  end

  return spell

end

improves.getImproveSpell = function ()
  
  local spell = improves.getImproveSpellName()

  if (spell == '') then
    return ''
  end


  return 'cast ' .. spell

end



improves.improveNonCombat = function(improveThings, options)
  
  options.cb = options.cb or function() end
  options.doneCallback = options.doneCallback or function() end
  
  options.hpItem = options.hpItem or 'serp.ring'
  options.bandage = options.bandage or 'a simple bandage'
  
  -- local improveThings = {
    -- 
    -- -- this one is a bit shit because you can't keep doing it in the same room
    -- -- dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant', level = 7},
    -- 
    -- bandage = { bandage = true, cmd = 'bandage self', reagent = 'a simple bandage', level = 10 },
    -- compress = { bandage = true, cmd = 'compress self', reagent = 'a clump of herbs', level = 10 },
    -- poultice = { bandage = true, cmd = 'poultice self', reagent = 'a thick aloe leaf', level = 10 },
    -- salve = { bandage = true, cmd = 'poultice self', level = 7 },
    -- ['healing mist'] = { heal = true, cmd = 'cast healing mist', level = 7 },
    -- ['healing rain'] = { heal = true, cmd = 'cast healing rain', level = 10 },
    -- 
    -- impede = { cmd = 'cast impede', level = 10},
    -- 
    -- fireflies = { cmd = 'remove gold.ball &amp; | cast fireflies &amp; | remove fireflies &amp; | wear gold.ball', level = 10},
    -- 
    -- squall = { cmd = 'prep squall &amp; |cast squall', level = 10},
    -- storm = { cmd = 'prep storm &amp; |cast storm', level = 10},
    -- blizzard = { cmd = 'prep blizzard &amp; |cast blizzard', level = 7},
    -- tornado = { cmd = 'prep tornado &amp; |cast tornado', level = 7},
    -- tempest = { cmd = 'prep tempest &amp; |cast tempest', level = 10},
    -- 
    -- anemogenesis = { cmd = 'cast anemogenesis', level = 10},
    -- xerotes = { cmd = 'cast xerotes', level = 10},
  -- }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      
      if (data.bandage) then
  
        common.getReagents(data.reagent, 1, function()
          common.getReagents(options.bandage, 1, function()
            send('|remove ' .. options.hpItem .. ' &amp; |wear ' .. options.hpItem .. ' &amp; |sit')
            send('|' .. data.cmd .. ' &amp; |wait 4 &amp; |stand')
            options.cb()
          end, function()
            cecho('\n\nOut of ' .. options.bandage .. '!!!\n\n')
          end)
        end, function()
          cecho('\n\nOut of ' .. data.reagent .. '!!!\n\n')
        end)
  
      elseif (data.heal) then
      
        send('|prep ' .. thing)  
        send('|remove ' .. options.hpItem .. ' &amp; |wear ' .. options.hpItem .. ' &amp; |cast ' .. thing)
        options.cb()
      
      else
        send('|' .. data.cmd)
        options.cb()
      end
  
      player.lastImproveSkill = thing
      
      
      return
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    improves.improveNonCombat(improveThings, options)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    options.cb()
    options.doneCallback()
  end
  
end

improves.improveCombat = function(improveThings, target)
  
  -- 
  -- local improveThings = {
    -- 
    -- -- need to keep moving while doing this. bleh
    -- dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant &amp; |cast gale', level = 7},
    -- 
    -- -- darkness
    -- nocturne = { cmd = 'cast nocturne', level = 7},
    -- gloom = { cmd = 'cast gloom', level = 10},
    -- shadowstrike = { cmd = 'cast shadowstrike', level = 7},
    -- ['veil of darkness'] = { cmd = 'cast veil of darkness', level = 10},
    -- 
    -- -- for healing
    -- ['aqueous surge'] = { cmd = 'cast aqueous surge', level = 7},
    -- ['aqueous spirit'] = { cmd = 'cast aqueous spirit', level = 7},
    -- 
    -- -- wind
    -- gust = { cmd = 'cast gust', level = 7},
    -- ['wind shear'] = { cmd = 'cast wind shear', level = 7},
    -- gale = { cmd = 'cast gale', level = 10},
    -- whirlwind = { cmd = 'cast whirlwind', level = 10},
    -- 
    -- -- util
    -- undergrowth = { cmd = 'cast undergrowth', level = 10},
    -- 
    -- -- drying (for xerotes)
    -- dry = { cmd = 'cast dry', level = 10},
    -- parch = { cmd = 'cast parch', level = 7},
    -- desiccate = { cmd = 'cast desiccate', level = 7},
    -- 
    -- -- aoe (optional)
    -- blizzard = { cmd = 'prep blizzard &amp; |cast blizzard &amp; |sigh', level = 7},
    -- 
  -- }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      player.lastImproveSkill = thing
      
      local cmd = rex.gsub(data.cmd, '%t', target)
      
      return cmd
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    return improves.improveCombat(improveThings, target)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    return ''
  end
  
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>conversions from old code</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

mapper = mapper or {}
murder = murder or {}

murder.tankState = murder.tankState or 'here'

mapper.gotoRoom = function(rnum, callback)
  tfe.gotoRoom(rnum, {callback = callback})
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>murder bot</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>murder</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

murder = murder or {}

murder.defaults = {
  enabled=false,
  speedwalking = false,
  paused = false,
  noBacktracking = nil,
  waitForSplit = true,
  exits={},
  targets = {},
  ignoreTargets = {},
  nonHostileTargets = {},
  nastyTargets = {},
  waypoints = {},
  currentWaypoint = 0,
  events = {
   PATH_COMPLETE = 'MURDER:path_completed',
   PENDING_MOVE_COMPLETE = 'MURDER:pending_move_completed',
  },
  move_pending = nil,
  idleCheckTimer = nil,
  roomChangeHandler = nil,
  killWatcher = nil,
  stepAction = nil,
  notifyMobBeforeMove = false,
  
  waitForSplitAmount = nil,
  
}

murder.init = function () 
  if (murder.enabled ~= true) then
    cecho('\n\n&lt;red&gt;MUDER: &lt;white&gt;initialised\n\n')
    for k,v in pairs(murder.defaults) do
      murder[k] = v
    end
  else
    cecho('\n\n&lt;red&gt;MUDER: &lt;white&gt;skipped init due to being enabled\n\n')
  end
end

murder.init()

player.gettingFull = false
murder.castingLocked = nil


murder.setLocalNextRoom = function(exit)

  -- only hit things in the current room and only if there is only one thing
  -- also can't be a pending hit already
  if (exit and exit.firstTarget) then
  
    local ccMobs = ''
  
    if (exit.targetCount &gt;= 1) then
      for idx = #exit.allTargets, 1, -1 do
        ccMobs = ccMobs .. exit.allTargets[idx]
        if (idx ~= 1) then ccMobs = ccMobs .. ',' end
      end
    end

    player.nextRoom = {
      targetCount = exit.targetCount,
      aoe = exit.nonTargetCount == 0,
      nasty = exit.nastyTarget,
      target = exit.firstTarget,
      ccMobs = ccMobs,
    }

  end
  
end 

murder.autoScan = function ()
  
  if (murder.autoScanWatcher) then
    killAnonymousEventHandler(murder.autoScanWatcher)
    murder.autoScanWatcher = nil
  end
  
  murder.autoScanWatcher = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, function ()
    murder.sawAction = false
  end)

end

murder.autoScan()

murder.wait_message = 'gstat waiting for split'


murder.onRoomClear = function (cb)

  local onclear 
  
  onclear = common.onNextEvent(common.events.ROOM_CLEAR, function()
    onclear = nil
    cb()
  end)
  
  -- clean up in case we moved before room was clear
  common.onNextEvent(common.events.ROOM_CHANGED, function()
    if (onclear) then
      onclear()
      onclear = nil
    end
  end)
  
end 
  


murder.idleScanner = function ()

  if (murder.idleScannerResetLockout == nil) then
    
    tempTimer(2, function()
      murder.idleScannerResetLockout = nil
    end, 'murder idle timer reset lockout')
     
    murder.idleScannerResetLockout = true
    murder.clearIdleScanTimer()
    
    if (murder.enabled) then
      cecho('\n&lt;green&gt;MURDER: &lt;white&gt;started idle scan timer!\n')
      murder.idleTimer = tempTimer(10, function ()
        cecho('\n&lt;orange&gt;MURDER: &lt;white&gt;scannign due to idle for 10s!\n')
        murder.scan('idle scanner')
        murder.idleScanner()
      end, 'murder idle timer')
    end
    
  end

end

murder.clearIdleScanTimer = function()
  if (murder.idleTimer) then
    cecho('\n&lt;green&gt;MURDER: &lt;white&gt;cleared existing idle scan timer!\n')
    killTimer(murder.idleTimer)
    murder.idleTimer = nil
  end
end

murder.extendIdleScanner = function()
  if (murder.idleTimer ~= nil) then
    murder.idleScanner()
  end
end





local defaultKillCommand = function(exit)
  
  if (exit and exit.firstTarget) then
    
    if (player.getAttackCommand) then
      return player.getAttackCommand(exit.firstTarget)
    end 
    
    return 'kill ' .. exit.firstTarget
    
  else
    return ''
  end

end

murder.smiteCommand = function(exit)
  
  if (exit and exit.firstTarget) then
  
    if (player.getSmiteCommmand) then
      return player.getSmiteCommmand(exit.firstTarget)
    elseif (player.getAttackCommand) then
      return player.getAttackCommand(exit.firstTarget)
    else
      return 'kil ' .. exit.firstTarget
    end 
    
  else
    return ''
  end

end


murder.defaultKillCommand = murder.defaultKillCommand or defaultKillCommand

murder.sleepKillCommand = function(exit)
  
  local sleepCmd = ''
  
  if (exit) then
  
    -- display(exit)
    
    -- setup next target so we can skip auto cast on combat
    if (exit.firstTarget) then
      player.sleepTarget = exit.firstTarget:lower()
      cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;set sleep target from sleep kill command (' .. player.sleepTarget .. ')\n\n')
    end
    
    -- only consider mists if everything is a target and more than 2 mobs
    if (exit.nonTargetCount == 0 and exit.targetCount &gt; 1) then
    
      sleepCmd = 'cast mists'
      if (murder.preSleeping) then
        sleepCmd = sleepCmd .. ' &amp; queue scan'
      end   
      return sleepCmd
    end
    
    for k,v in pairs(exit.allTargets) do
      sleepCmd = sleepCmd .. 'cast sleep ' .. v .. ' &amp; '
    end
    
    -- add a scan to trigger next move when we arnen't killing things
    if (murder.preSleeping) then
      sleepCmd = sleepCmd .. 'queue scan &amp; '
    end
    
    return sleepCmd .. ' level' -- ' cast sleep'
    
  else
    return ''
  end

end





murder.execute = function(step,  callback)

  cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;executing step!!\n\n')
  
  -- clear any pending moves if they exist already
  murder.clearPendingMove()
  
  -- farmer.options
  
  -- set the names of targets to murder
  -- combine step targets with targets from options
  murder.setTargets(
    step.targets or farmer.options.targets or {},
    step.nonHostileTargets or farmer.options.nonHostileTargets or {}, 
    step.ignoreTargets or farmer.options.ignoreTargets or {}, 
    step.nastyTargets or farmer.options.nastyTargets or {}
  )
  
  murder.setWaypoints(step.waypoints) 
  
  
  
  murder.stepAction = step.stepAction or farmer.options.stepAction
  
  murder.notifyMobBeforeMove = farmer.options.notifyMobBeforeMove
  
  -- prevent true overriding false
  if (step.notifyMobBeforeMove ~= nil) then 
    murder.notifyMobBeforeMove = step.notifyMobBeforeMove 
  end
  
  murder.callback = callback
  
  murder.getKillCommand = step.getKillCommand or farmer.options.getKillCommand or murder.defaultKillCommand
  
  murder.waitForSplitAmount = step.waitForSplitAmount or farmer.options.waitForSplitAmount
  
  murder.stepOptions = step.options or {}
  
  
  
  cecho('\n\n&lt;green&gt;MURDER: &lt;white&gt;muder step started\n\n')
  murder.registerHandlers()
  
  murder.exploring = false
  tfe.move_queued = false
  
  murder.resetState()
  
  murder.enabled = true 
  murder.paused = false
  murder.holdHere = false
  murder.step_action_pending = nil
  
  murder.noBacktracking = step.noBacktracking or farmer.options.noBacktracking
  
  murder.waitForSplit = step.waitForSplit
  if (murder.waitForSplit == nil) then 
    murder.waitForSplit = farmer.options.waitForSplit 
  end
  if (murder.waitForSplit == nil) then 
    murder.waitForSplit = true
  end
  
  
  murder.stepOptions = murder.stepOptions or {}
  
  if (murder.stepOptions.preSleeping) then 
    murder.preSleeping = true
    send('gstat going to pre sleep these suckers yo!')
  else
    murder.preSleeping = false
  end
  
  murder.resetIdleTimer()	
  murder.idleScanner()
  
  cecho('\n&lt;blue&gt;MURDER: next invoked (from murder.execute)!\n')
  tempTimer(0, function() murder.scan('murder.execute') end)

end


murder.setWaypoints = function (waypoints)
  cecho('\n&lt;green&gt;MURDER: &lt;white&gt;setting waypoints (' .. table.concat(waypoints, ', ') .. ')\n')

  tfe.configureWalkPath(waypoints)
  murder.clearPendingMove()	
  
end
  
murder.clearPendingMove = function ()
  if (murder.move_pending) then
    cecho('\n&lt;green&gt;MURDER: &lt;white&gt;Pending move cleared!')
    murder.move_pending()
    murder.move_pending = nil
    raiseEvent(murder.events.PENDING_MOVE_COMPLETE)
  end
end
  
murder.killHandlers = function ()
  
  if (murder.roomChangeHandler) then
    killAnonymousEventHandler(murder.roomChangeHandler)
    murder.roomChangeHandler = nil
  end

    
  if (murder.combatEventWatcher) then
    killAnonymousEventHandler(murder.combatEventWatcher)
    murder.combatEventWatcher = nil
  end
  
  -- how is this different to roomChangeHandler???
  if (murder.roomChangeWatcher) then
    killAnonymousEventHandler(murder.roomChangeWatcher)
    murder.roomChangeWatcher = nil
  end

end

murder.registerHandlers = function()
  
  murder.killHandlers()
  
  murder.roomChangeHandler = registerAnonymousEventHandler(common.events.SCAN_PROCESSED, function ()
    cecho('\n&lt;blue&gt;MURDER: &lt;white&gt;next was invoked (by scan)!\n')
    murder.resetIdleTimer()
    murder.nextStep()
  end)
  
  -- reset idle timer if there is fighting
  murder.combatEventWatcher = registerAnonymousEventHandler(common.events.COMBAT_ATTACK, murder.extendIdleScanner)
  
  -- reset idle timer on room change
  murder.roomChangeWatcher = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, murder.extendIdleScanner)

end



function murder.hold()
  cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;muder holding here\n\n')
  murder.holdHere = true
  murder.clearShortSpeedWalkTimer()
end


function murder.unhold()
  cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;muder cancelling hold\n\n')
  murder.holdHere = false
  murder.startShortSpeedWalkTimer()
  murder.scan('stopping hold')
end


function murder.stop ()
  cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;muder path stopped\n\n')
  
  murder.enabled = false
  
  murder.noBacktracking = nil
  
  murder.preSleeping = false
  murder.exploring = false
  
  murder.setTargets({},{},{}, {})	
  murder.callback = nil
  
  murder.cancelIdleTimer()
  murder.clearPendingMove()
  
  murder.killHandlers ()
  
  murder.clearIdleScanTimer()

end

function murder.explore()
  murder.fixCommas = {}
  murder.mobElements = {}
  murder.xpoints = {}
  murder.stop()
  murder.exploring = true
  murder.notifyMobBeforeMove = true
  murder.getKillCommand = murder.defaultKillCommand
end


function murder.resetIdleTimer ()

  murder.cancelIdleTimer()
  
  murder.idleCheckTimer = tempTimer(60, function() 
    cecho('\n\n\n&lt;red&gt;WARNING:: &lt;white&gt;IDLE FOR 60 seconds!!!\n\n\n')
    murder.resetState()
    murder.clearPendingMove()
    combat.reset()
    cecho('\n&lt;blue&gt;MURDER: &lt;white&gt;scanning to invoke next step (idle timer)!\n')
    murder.scan('long idle timer')
  end, 'murder idle check timer') 

end

function murder.cancelIdleTimer ()
  if (murder.idleCheckTimer) then
    killTimer(murder.idleCheckTimer)
    murder.idleCheckTimer = nil
  end 
end



function murder.advanceWaypoint ()
  
  murder.advancePending = nil
  
  cecho('\n\n&lt;green&gt;MURDER: &lt;yellow&gt;advance waypoint invoked...\n\n')
  
  -- kill any outstanding timers:
  murder.clearShortSpeedWalkTimer()
  murder.cancelIdleTimer()
  
  -- display(murder.waypoints, murder.currentWaypointIdx)
  cecho('\n\n&lt;green&gt;MURDER: &lt;yellow&gt;MURDER PATH COMPLETE\n\n')
  
  murder.hold()
  
  if (murder.callback) then
    murder.callback()
  end

end

function murder.updatePath ()
  
  cecho('\n&lt;blue&gt;MURDER:&lt;white&gt; updating current steps murder route\n')
  
  if (not tfe.rerouteSpeedwalk()) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;unable to update path.\n')
    expandAlias('farm stop')
  end
  
end



murder.cmdTypes = {
  MOVE = 'movement',
  ATTACK = 'attack',
  WAIT_SPLIT = 'wait for split'
}

local shortSpeedWalkTimerId
local combatRestartSpeedWalkTimer
local pendingExitOpen

function murder.startShortSpeedWalkTimer ()
  
  if murder.holdHere then
    cecho('&lt;red&gt; &lt;- attempted restart short speed walk timer while holding')
    return
  end
  
  
  -- clear any existing timer
  murder.clearShortSpeedWalkTimer()
  
  if (murder.enabled) then
    -- give us 5 seconds to move...
    shortSpeedWalkTimerId = tempTimer(5, function ()
      cecho('\n&lt;yellow:blue&gt;MURDER: &lt;white:black&gt;10 seconds without move!!! - updating path...\n')
      murder.updatePath()
      murder.clearPendingMove()
      murder.scan('short speedwalk timer')
    end, 'short speed walk timer')
  end
  
  combatRestartSpeedWalkTimer = common.onNextEvent(common.events.COMBAT_ATTACK, function()
    cecho('&lt;green&gt; &lt;- restart speed walk timeout ')
    combatRestartSpeedWalkTimer = nil
    murder.startShortSpeedWalkTimer()
  end)

end

function murder.clearShortSpeedWalkTimer ()
  
  if (shortSpeedWalkTimerId ~= nil) then
    killTimer(shortSpeedWalkTimerId)
    shortSpeedWalkTimerId = nil
  end
  
  if (pendingExitOpen ~= nil) then
    pendingExitOpen()
    pendingExitOpen = nil
  end
  
  if (combatRestartSpeedWalkTimer ~= nil) then
    combatRestartSpeedWalkTimer()
    combatRestartSpeedWalkTimer = nil
  end
  
  
end


function murder.move (cmd, reverse, delayCommand)
  
  -- send move command
  
  if murder.holdHere then
  
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;attempted to move while holding here (wtf?)\n')
    
  elseif (not murder.move_pending) then
    
    murder.startShortSpeedWalkTimer()
    
    murder.move_pending = common.onNextEvent(tfe.events.ROOM_CHANGED, function (evt)
      -- cecho('&lt;yellow&gt; &lt;- room changed, awaiting on scan ')
      cecho('&lt;yellow&gt; &lt;- room changed, clearing timers/pending moves etc')
      tfe.advanceStepPosition(reverse)
      murder.clearShortSpeedWalkTimer()
      murder.clearPendingMove()
    end)
    
    if (delayCommand and delayCommand &gt; 0) then
      
      tempTimer(delayCommand, function()
        expandAlias(cmd)
      end)
      
    else
      expandAlias(cmd)
    end
  
  else -- else murder.move_pending already exists
  
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;attempted to move while move was already pending (wtf?)\n')
  
  end
  
end

function murder.reroute ()
  cecho('\n&lt;blue&gt;MURDER: &lt;white&gt;next invoked (reroute)!\n')
  murder.updatePath()
  murder.clearPendingMove()
  murder.scan('reroute of murder path')
  cecho('&lt;green&gt;&lt;-- scan from reroute\n')
end


function murder.resume (skipScan)
  murder.paused = false
  send('gstat murdering will resume')

  if (skipScan ~= true) then
    murder.scan('murder resume')
  end
  
end

function murder.pause ()
  murder.paused = true
  send('gstat murdering will be suspendend after current tasks')
end


function murder.nextStep(actionPerformed) 

  if (murder.silenced) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;waiting for silenced party member to be fixed\n')
    return   
  end


  if (pendingExitOpen) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;waiting for an exit to open\n')
    return 
  end

  if (murder.sleepDancing) then
     cecho('\n&lt;red&gt;MURDER: &lt;white&gt;waiting for the sleep dance to finish\n')
    return 
  end
    
  if (murder.advancePending) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;waiting murder to advance (pending step action)\n')
    return
  end

  if (farmer.advancePending) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;waiting farmer to advance (pending action)\n')
    return
  end
  
  if (murder.exitForSleepKill == true) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;waiting for slept mob to die before resuming actions\n')
    return
  end
  
  if (murder.move_pending ~= nil) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;attempted to perform next step while move was already pending (wtf?)\n')
    return
  end
  
  
  if (murder.step_action_pending ~= nil) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;attempted to perform next step while step action was pending (wtf?)\n')
    return
  end  
  
  if (player.pendingAttack) then
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;attempted to perform next step while an attack was pending (wtf?)\n')
    return 
  end


  -- if there is a step action perform it before we do anything else
  if (murder.stepAction and not actionPerformed) then
    
    cecho('\n -=[ performing step action ]=-\n')
    
    if (murder.stepAction and type(murder.stepAction) == 'string') then
    
      send(murder.stepAction)
      murder.nextStep(true)
    
    elseif (murder.stepAction and type(murder.stepAction) == 'function') then
      murder.cancelIdleTimer()
      murder.clearShortSpeedWalkTimer()
      murder.step_action_pending = true
      
      murder.stepAction(function()
        murder.sawAction = false
        murder.step_action_pending = nil
        murder.resetIdleTimer()
        murder.nextStep(true)
      end)
    else    
      cecho('\n&lt;red&gt;MURDER: &lt;white&gt;unknown type of step action: ' .. type(murder.stepAction))    
    end
    
    return
  end
  



  local exitHasTargets = function (dir)
  
    local thisExit = murder.exits[dir]
    
    if (thisExit and (thisExit.targetCount &gt; 0 or thisExit.nonHostileTargetCount &gt; 0)) then
      return true
    end
    
    return false
    
  end
  
  
  murder.resetIdleTimer()
  
  if (murder.enabled and not murder.paused and not murder.holdHere) then
  
  cecho('\n\n -=[ murderer wants to act ]=-\n\n')
  
  -- if there is something we need to kill in the current roomLocked
  if (not murder.preSleeping and exitHasTargets('here')) then
    -- there is something in this room to sort out... do it
    local cmd, attackPending = murder.getKillCommand(murder.exits.here, murder.exits, 'here')

    if ((cmd and cmd ~= '') or attackPending) then
      cecho('\n&lt;orange&gt;MURDER: &lt;white&gt;kill mob in the current room')
      expandAlias(cmd)
      return
    end
    
  end
  
  
  
  -- pause to get moves if someone is low on moves
  if (group.lowest_moves &lt;= 10) then
    send('gstat someone be low on moves, waiting for 10...')
    murder.paused = true
    -- cecho('\n&lt;yellow&gt;MUDER: &lt;white&gt;need to get moves\n')
    
    tempTimer(10, function()
      murder.paused = false
      murder.scan('waiting on moves')
    end)
    return -- low on moves. no moves to be done this time...
  end -- not low on moves
    
    
    
    
  -- check the previous room to see if something has moved into it...
  -- it's nice to keep our escape clear...
  -- don't do it if we're in the middle of sleep killing something tho
  local dirback = tfe.getNextDirection(true)
  
  if (not murder.preSleeping and not murder.noBacktracking and dirback and dirback ~= '' and 
    exitHasTargets(dirback)  and  murder.exitForSleepKill ~= true) then
        
    cecho('\n&lt;red&gt;MURDER: &lt;white&gt;mob(s) in previous room ' .. dirback)
    
    local exit = murder.exits[dirback]
    local cmd = tfe.getNextStep(true) .. ' &amp; ' .. murder.getKillCommand(exit, murder.exits, dirback)
    
    if (murder.stepAction and type(murder.stepAction) == 'string') then
      cmd = cmd .. ' &amp; ' .. murder.stepAction
    end
    
    local next = function()
    
    if (murder.notifyMobBeforeMove ) then
      if (not murder.notifyBeforeMoveLockout) then
        murder.notifyBeforeMoveLockout = true
        murder.sendNextTarget(exit)
        
        tempTimer(1.5, function ()
        murder.notifyBeforeMoveLockout = nil
        end)
        murder.move(cmd, true, 1.5)

      else
        cecho('\n&lt;red&gt;MURDER: &lt;white&gt;move already in the queue (delay pending notify)\n\n')
      end
        
    else 
      send('gstat going back to get '.. exit.firstTarget)
      murder.move(cmd, true)
      send('|unhide')
    end
    
  end

  -- perform step action before moving if there is one...
  if (murder.stepAction and type(murder.stepAction) == 'function') then
  
    murder.cancelIdleTimer()
    murder.clearShortSpeedWalkTimer()
    murder.step_action_pending = true
    
    murder.stepAction(function ()
      murder.step_action_pending = nil
      murder.resetIdleTimer()
      next()
    end)
    
    else
      next()
    end
    
    return
  end
  
    
  local dir = tfe.getNextStep()
    
    
  -- if we're at the end of this waypoint then advance... (perform step action first if it exists)
  if (dir == nil or dir == '') then
  
    cecho('\n&lt;orange&gt;MURDER: &lt;white&gt;No move commands left for this step!\n')
    murder.advancePending = true
    
    if (murder.stepAction and type(murder.stepAction) == 'string') then
      send(murder.stepAction)
      murder.advanceWaypoint()
    elseif (murder.stepAction and type(murder.stepAction) == 'function') then
      murder.step_action_pending = true
      murder.clearShortSpeedWalkTimer()
      
      murder.stepAction(function()
        murder.step_action_pending = nil
        murder.advanceWaypoint()
      end)
    else
      murder.advanceWaypoint()
    end
    
    return
    
  end

  local moveDirection = tfe.getNextDirection()

  
  -- /****** WE ARE MOVING (forwards) IF WE GOT HERE ********/ --
  
  local exit = murder.exits[moveDirection]
    
  -- if the next exit isn't open abandon this and open it before trying again (need a new scan)
  if tfe.isExitClosed(moveDirection) then
    
    display('waiting for ' .. moveDirection .. ' to open')
    -- display(njs50.gmcp.previous.exitInfo)

    tfe.openExit(moveDirection, function()
      murder.scan('exit opened')
    end)   
    
    return
    
  end
    
  
  
  -- if we are speedwalking... (or nothing in the next room)
  if (not exit) then
    
    local cmd = dir
       
    local next = function ()
      murder.move(cmd)
    end
    
    if (murder.stepAction and type(murder.stepAction) == 'string') then
      cmd = cmd .. ' &amp; ' .. murder.stepAction
      next()
    elseif (murder.stepAction and type(murder.stepAction) == 'function') then
      murder.step_action_pending = true
      murder.clearShortSpeedWalkTimer()
      murder.stepAction(function()
        murder.step_action_pending = nil
        next()
      end)
    else
      next()
    end
    
    return
  end
  
  
  -- setup something to scan if we are idle for too long
  murder.idleScanner()
  
  
  -- check if we need to wait for mobs to split
  if (murder.waitForSplit == true and murder.waitForSplitAmount and exit.targetCount &gt;= murder.waitForSplitAmount) then
  
    cecho('\n&lt;green&gt;Murder: &lt;white&gt;waiting on split\n')
    
    murder.paused = true
    
    if (murder.notifyMobBeforeMove) then
      if (exit.distinctTargets &gt; 1) then
        send('gstat next could be either of those things')
      else
        murder.sendNextTarget(exit)
      end
    end
    
    tempTimer(3, function()
      murder.paused = false
      murder.scan('waiting on split')
    end)
    
    send(murder.wait_message)
    
    return
  
  else

  
    local cmd  = dir .. ' &amp; ' .. murder.getKillCommand(exit, murder.exits, moveDirection)
    
    
    local moveCmd = function ()
      murder.paused = false
      if (murder.notifyMobBeforeMove ) then
      
        if (not murder.notifyBeforeMoveLockout) then
          murder.notifyBeforeMoveLockout = true
          murder.sendNextTarget(exit)
          tempTimer(1.5, function ()
            murder.notifyBeforeMoveLockout = nil
          end)
          murder.move(cmd, false, 1.5)
        else
          cecho('\n&lt;red&gt;MURDER: &lt;white&gt;move already in the queue (delay pending notify)\n\n')
        end
      
      else 
        murder.move(cmd)
      end
    
    end


  if (murder.stepAction and type(murder.stepAction) == 'string') then
    cmd = cmd .. ' &amp; ' .. murder.stepAction
    moveCmd()
  elseif (murder.stepAction and type(murder.stepAction) == 'function') then
    murder.step_action_pending = true
    murder.clearShortSpeedWalkTimer()
    murder.stepAction(function()
      murder.step_action_pending = nil
      moveCmd()
    end)
  else
    moveCmd()
  end
  
  end
  
  else
  
  if (murder.holdHere) then
  echo('\n\n -=[ murderer holding here ]=-\n\n')
  elseif(murder.paused) then
  echo('\n\n -=[ murderer paused ]=-\n\n')
  else
  echo('\n\n -=[ murderer disabled ]=-\n\n')
  end
  
  end -- end if murder is enabled
  

end

murder.sendNextTarget = function(exit)
  
  local cmd = 'gstat next room has '
  
  local count = exit.targetCount + exit.nonHostileTargetCount
  
  if count &lt;= 1 then
    cmd = cmd .. tostring(count) .. ' target, '
  else
    cmd = cmd .. tostring(count) .. ' targets, '
  end
  
  if(exit.nonTargetCount == 0) then
    cmd = cmd .. 'aoe-safe,' 
  else
    cmd = cmd .. 'no-aoe,' 
  end 
  

  if (exit.nastyTarget) then
    cmd = cmd .. ' destroy: ' .. exit.firstTarget
  else
    cmd = cmd .. ' attack: ' .. exit.firstTarget
  end
  
  if (count &gt;= 1) then
    cmd = cmd .. ', cc-order: '
    for idx = #exit.allTargets, 1, -1 do
      cmd = cmd .. exit.allTargets[idx]
      if (idx ~= 1) then cmd = cmd .. ',' end
    end
  end
  
  send(cmd)
  
end

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>farmer</name>
				<packageName></packageName>
				<script>
farmer = farmer or {}


farmer.configure = function (runName, steps, completeCallback, options)
  
  options = options or {}

  -- convert old dropJunk param to options (so lazy)
  if (type(options) == 'string') then
    options = {dropJunk = options}
  end
  
  options.shortName = runName
  options.longName = options.longName or runName
  options.ignoreNoXpMobsUnder = options.ignoreNoXpMobsUnder or 1

	options.targets = options.targets or {}
	options.nonHostileTargets = options.nonHostileTargets or {}
	options.ignoreTargets = options.ignoreTargets or {}
  options.nastyTargets = options.nastyTargets or {}

	cecho('\n &lt;yellow&gt;FARMER:&lt;white&gt; updated config for ' .. runName .. '\n')
	farmer.runs = farmer.runs or {}
	farmer.runs[runName] = {
		steps = steps,
		completeCallback = completeCallback,
		dropJunk = options.dropJunk,
    options = options
	}
end


farmer.onStepComplete = function(thisStep)
  -- send next move when the next prompt appears

  farmer.advancePending = true

  if (thisStep.action) then
    
    -- echo('\n\n &lt;-- speed walk done: running action .. ' .. thisStep.action)
    
    
    if(type(thisStep.action) == 'string') then
      expandAlias(thisStep.action)
      cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;advancing step in 5s (basic action)... ')
      -- display(thisStep)
      tempTimer(5, farmer.advance, 'farmer onStepComplete advance')
    else
      
      --  if action is a function we won't advance until 
      -- the callback is called
      if(type(thisStep.action) == 'function') then
        
        cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;running action function\n')
        local nextMurderStep = function ()
          cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;action callback complete, advancing step...\n')
          farmer.advance()
        end
        
        -- need to get this into next cycle to prevent action being able to trigger on the current line
        -- this was problematic when a pfree happened in stepAction then pfull in action as the pfree "ready"
        -- was taken as "pfull" ready.
        tempTimer(0, function()        
          thisStep.action(nextMurderStep)
        end)
        
      else -- unknown action type
        
        cecho('\n&lt;red&gt;FARMER: &lt;white&gt;unkown action type!!\n')
      
      end -- if action was a function
    
    end -- else if action was string
    
  else
    
    cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;advancing step (no action)... \n')
    farmer.advance()
    
  end


end

farmer.getStep = function(name)
  for idx, step in pairs(farmer.steps) do
    if step.name and step.name == name then
      return step, idx
    end
  end
  
end

farmer.advance = function (stepName)
  
  local thisStep 
  farmer.advancePending = false
  
  if (stepName) then
    thisStep, farmer.currentStepIdx = farmer.getStep(stepName)
  else
    	farmer.currentStepIdx = farmer.currentStepIdx + 1
    	thisStep = farmer.steps[farmer.currentStepIdx]
	end
  
	if (thisStep) then
		
  	   cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;starting step ' .. (thisStep.name or tostring(farmer.currentStepIdx)) .. '\n')		
		
		if (thisStep.location) then -- standard walk step

    	  -- start heading to the next location...
      murder.stepAction = thisStep.stepAction
      tfe.gotoRoom(thisStep.location, function () 	
        cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;path complete, running action...\n')
        farmer.onStepComplete(thisStep)
      end)
		
    elseif (thisStep.turbo) then 	
		  display(thisStep)
      tfe.turboWalkToRoom(thisStep.turbo, {
        callback = function () 	
          cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;turbo path complete, running action...\n')
          farmer.onStepComplete(thisStep)
        end,
        stepAction = thisStep.stepAction or farmer.options.stepAction
      })
		
		elseif (thisStep.waypoints) then -- if this is a murder path
			murder.execute(thisStep, function ()  		
				farmer.onStepComplete(thisStep)
			end)
		end
		
	else
    
    if stepName then
      cecho('\n&lt;red&gt;FARMER: &lt;white&gt;attempted to advance to invalid step (' .. stepName .. ')\n')
    else
  
    		echo('\n\nFields are tended! laps: ' .. tostring(farmer.lapCounter)  .. 
    			' : ' .. tostring(farmer.killcount) .. '\n\n')
    
    		if (farmer.completeCallback) then
    			farmer.completeCallback()
    		end
    end
		
	end
		
end

farmer.incKillCount = function ()
	farmer.killcount = (farmer.killcount or 0) + 1
end


farmer.restart = function ()
  
  farmer.endLap();
  murder.advancePending = nil
  farmer.advancePending = nil  

  if (not farmer.dontRestart) then
  	farmer.currentStepIdx = 0
  	farmer.advance()
  else
    cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;restart skipped (the end!)\n')
    farmer.stop()
  end
	
end

farmer.start = function (runName, param)
	
	local specialCommands = { 
	
		stop = function ()
			farmer.stop()
			murder.stop()	
		end,
    
    stopAfter = function ()
      
      if (param ~= 'cancel') then
        
        farmer.dontRestart = true
        cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;stopping after current lap...\n')
      
      else
        farmer.dontRestart = nil
        cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;cancelling stop after current lap...\n')      
      end
      
      
    end,
		
		pause = function ()
			murder.pause()
		end,
	
		resume = function ()
			murder.resume()
		end,
	
		explore = function ()
			murder.explore()
		end,
		
		reset = function ()
      murder.silenced = nil
      player.pendingAttack = nil
      player.equippingSet = nil
      player.gettingFull = nil
      healer.clearQueued()
		end,
    
    afk = function()
      if (param == 'true' or param == 'on') then
        cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;enabling AFK mode...\n')
        farmer.afkMode = true
      else
        cecho('\n&lt;yellow&gt;FARMER: &lt;white&gt;disabling AFK mode...\n')
        farmer.afkMode = nil
      end
    end,
		
	}
  -- display(runName)

	if (farmer.runs[runName]) then
  	
    -- send('opt autoscan 0')
    
    specialCommands.reset()
    
    farmer.resetFarmStats()
    farmer.resetLapStats()
    farmer.dontRestart = nil
    farmer.onStop = nil
		
    murder.advancePending = nil
    farmer.advancePending = nil
    
		farmer.steps = farmer.runs[runName].steps
		farmer.dropJunk = farmer.runs[runName].dropJunk
    	farmer.completeCallback = farmer.runs[runName].completeCallback
    farmer.options = farmer.runs[runName].options
    	farmer.currentStepIdx = 0
    	farmer.advance()

    
	else

	
		if (specialCommands[runName]) then
			specialCommands[runName]()
		else
			echo('\n\n\nERRRRROR: no such farm\n\n')
		end
	
	end
		
end

farmer.resetFarmStats = function ()
	farmer.lapCounter = 0
	farmer.killcount = 0
	farmer.startTime = getEpoch()
	farmer.lapTimes = {}
	farmer.repopWaitTime = 0
  farmer.cumulativeInfo = {}
end

farmer.resetLapStats = function ()

  farmer.lapRepopWaitTime = 0
  farmer.lapStartTime = getEpoch()
  farmer.lapInfo = {}
  
end

farmer.endLap = function ()

  local laptime = getEpoch() - farmer.lapStartTime
  
  table.insert(farmer.lapTimes, laptime)
  
  farmer.repopWaitTime = farmer.repopWaitTime + farmer.lapRepopWaitTime
	farmer.lapCounter = (farmer.lapCounter or 0) + 1
      
  for k, v in pairs(farmer.lapInfo) do
    farmer.cumulativeInfo[k] = farmer.cumulativeInfo[k] or {}
    table.insert(farmer.cumulativeInfo[k], v)
  end
	
	cecho('\n&lt;green&gt;FARMER: &lt;white&gt;lap restarted after: ' .. common.formatElapsedTime(laptime) ..  
		', repop wait was: ' .. common.formatElapsedTime(farmer.lapRepopWaitTime) .. '\n')
    
  display(farmer.lapInfo)
  
  farmer.resetLapStats()
  
end


farmer.stop = function ()
  if (farmer.startTime) then
	 cecho('\n&lt;red&gt;FARMER:&lt;white&gt; stopped running. runtime: ' .. common.formatElapsedTime(getEpoch() - farmer.startTime) .. '\n')
	end
  farmer.steps = {}
	farmer.completeCallback = nil
	farmer.dropJunk = nil
  if (farmer.onStop) then
    farmer.onStop()
  end
end

farmer.status = function(chan)
  
  if (not chan or chan == '') then
    chan = 'emote :'
  end
   
  chan = chan .. ' '
  
  if not farmer or not farmer.steps or #farmer.steps == 0 then
    if (group.leader ~= player.name) then 
      send(chan .. 'status: following ' .. group.leader)
    else
      send(chan .. 'status: not currently farming or following')
    end
    
  else
  
    send(chan .. 'Currently running: ' .. farmer.options.longName)
       
    local totalTime = getEpoch() - farmer.startTime
    local lapTime = getEpoch() - farmer.lapStartTime
            
    if (totalTime ~= nil and farmer.lapCounter &gt; 0) then
    	send(chan .. 'Average run time: ' .. common.formatElapsedTime(totalTime / farmer.lapCounter))
    end
    
    if (lapTime ~= nil) then
    	send(chan .. 'Elapsed time this run:  ' .. common.formatElapsedTime(lapTime))
    end

    send(chan .. 'To have me end after this run: tell ' .. player.name .. ' cease and desist')
    
  end

  send(chan .. 'Current location: ' .. gmcp.Room.Info.area .. ', ' .. tostring(gmcp.Room.Info.num) .. ' ' .. gmcp.Room.Info.name)

end

farmer.endAfterWithNotify = function(chan)

  local totalTime = getEpoch() - farmer.startTime
  local lapTime = getEpoch() - farmer.lapStartTime

  if (not chan or chan == '') then
    chan = 'emote :'
  end
  
  chan = chan .. ' '

  if #farmer.steps == 0 then
    send(chan .. 'status: not currently farming')
  else
  
    if (farmer.dontRestart) then 
      send(chan .. 'already ending after this run')
    else
      send(chan .. 'stopping after run completes, will notify when done')
      farmer.onStop = function () 
        send(chan .. 'finished running ' .. farmer.options.longName)
        send(chan .. 'to restart tell ' .. player.name .. ' do farm ' .. farmer.options.shortName)
        if (farmer.options.onStopByTrigger) then
          farmer.options.onStopByTrigger()
        end
      end
    end
    
    farmer.start('stopAfter')

    if (totalTime ~= nil and farmer.lapCounter &gt; 0) then
    	send(chan .. 'eastimated time: ' .. common.formatElapsedTime((totalTime / farmer.lapCounter) - lapTime))
    end
    
  end
     
     
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>scanner</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

murder = murder or {}

murder.critters = {
  rabbit = true,
  deer = true,
  fawn = true,
  -- ["red.robin"] = true,
  pigeon = true,
  ["mountain.goat"] = true,
  ["gray.squirrel"] = true,
  Ghosty = true,
}


murder.setTargets = function (targets, nonHostileTargets, ignoreTargets, nastyTargets)

	-- display('targets added...')
	-- display(targets)
	
	murder.targets = targets or {}
	murder.nonHostileTargets = nonHostileTargets or {}
	murder.ignoreTargets = ignoreTargets or {}
  murder.nastyTargets = nastyTargets or {}
		
end



murder.resetExits = function () 
	-- echo('\nMurder targets cleared\n')
	murder.exits = {}
end


murder.addExitTarget = function (exit, target, numTargets, numNonHostileTargets, nonTargets, distinctTargets, allTargets, nastyTarget)	
	if exit == '[Here]' then 
		exit = 'here' 
	end
	-- echo('\nMurder target added?: ' .. exit .. ' : ' .. target)
	murder.exits[exit] = { 
		firstTarget = target, 
		distinctTargets = distinctTargets,
		targetCount = numTargets, 
		nonHostileTargetCount = numNonHostileTargets or 0, 
		nonTargetCount = nonTargets or 0,
    allTargets = allTargets or {},
    nastyTarget = nastyTarget,
	}
	
end

murder.mountRaces = {
  unknown = true,
  insect = true,
  dragon = true,
}


murder.locateMissingMembers = function()
  
  -- nb: will ignore mounts (assuming their race is in the list of known mount races: murder.mountRaces)
  
  local rollcall = common.newRollCall(true)
  
  local recoverList = {}

  for direction, exit in pairs(njs50.scanner.exits) do
    
    for idx, mob in ipairs(exit) do
      
      if (group.members[mob.raw]) then
      
        rollcall[mob.raw] = true
        
        if direction ~= '[Here]' and not murder.mountRaces[group.data[mob.raw].race] then
          recoverList[direction] = recoverList[direction] or {}
          table.insert(recoverList[direction], mob.raw)       
        end
        
      end      
      
    end
    
  
  end
  
  for name, isLocated in pairs(rollcall) do
    if not isLocated and not murder.mountRaces[group.data[name].race] then
      recoverList.lost = recoverList.lost or {}
      table.insert(recoverList.lost, name)
    end
  end
 
  return recoverList
  
end

murder.regroup = function()
  
  local regroupTimeout = 20
     
  if (murder.gettingLostSheep) then 
    cecho('\n&lt;orange&gt;REGROUP:&lt;white&gt; already regrouping!!! ') 
    return
  end

  if (murder.enabled) then
    murder.gettingLostSheep = true
    murder.pause()
    murder.hold()
  else
    cecho('\n&lt;green&gt;REGROUP:&lt;white&gt; skipped as bot is not enabled') 
    return
  end

  cecho('\n&lt;red&gt;REGROUP:&lt;white&gt; initiating regroup') 
  
  local regroupFailedTimer = tempTimer(regroupTimeout, function()
    cecho('\n&lt;red&gt;REGROUP:&lt;white&gt; regroup failed!!! ') 
    murder.gettingLostSheep = nil
  end, 'regroup failed')


  local allHere = function()
    cecho('\n&lt;green&gt;REGROUP:&lt;white&gt; all present and accounted for')
    murder.gettingLostSheep = nil
    murder.unhold()  
    murder.resume()
    killTimer(regroupFailedTimer)    
  end
  



  -- send('gstat up')
  
  
  murder.allDo('st &amp; unhide', function()
  
    common.onNextEvent(njs50.scanner.events.SCAN_PROCESSED, function()
    
      local missingList = murder.locateMissingMembers()
    
      display(missingList)

      local superLost = missingList.lost
      missingList.lost = nil

      if #table.keys(missingList) &gt; 0 then
      
        local ackPending = 0
      
        for exit, vics in pairs(missingList) do
          
          for idx, vic in ipairs(vics) do
            
            cecho('\n&lt;green&gt;REGROUP:&lt;white&gt; recovering ' .. vic .. ' from ' .. exit .. '\n')
            ackPending = ackPending + 1
            murder.doAnywayAck(vic, tfe.consts.reverse_dirs[exit], function()
              ackPending = ackPending - 1
              if ackPending == 0 then
                -- restart the regroup to see if everyone is here now...
                murder.gettingLostSheep = nil
                killTimer(regroupFailedTimer)
                tempTimer(regroupTimeout, murder.regroup, 'regroup after rejoin')
              end
            end, 10000)
            
          end
        
        end
        
                 

        -- 
     -- 
           -- 
        -- -- attempt to recover from first room
        -- local exit = table.keys(missingList)[1]
        -- local vics = missingList[exit]
        -- 
        -- -- display(missingList, exit, vics)
           -- 
        
        -- common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
          -- common.onClear(function()
            -- common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
              -- murder.gettingLostSheep = nil
              -- killTimer(regroupFailedTimer)
              -- murder.regroup()
            -- end)
            -- send(tfe.consts.reverse_dirs[exit])
          -- end)
        -- end)
        -- send(exit)

        cecho('\n&lt;yellow&gt;SCANNER:&lt;white&gt; party member MIA but recoverable!!! ')
        
        
      elseif superLost then
         
        cecho('\n&lt;red&gt;SCANNER:&lt;white&gt; ' .. table.concat(superLost, ', ') .. ' MIA and unrecoverable!!!\n')
        tempTimer(5, function()
          -- restart the regroup to see if everyone is here now...
          murder.gettingLostSheep = nil
          killTimer(regroupFailedTimer)
          tempTimer(regroupTimeout, murder.regroup, 'regroup very lost')        
        end, 'seeing if missing regroup resolves itself')
      else
        allHere()  
      end
      
      
      -- 
      -- murder.gettingLostSheep = nil
      -- 
      -- if (murder.gettingLostSheepPause) then
        -- tempTimer(10, function()
          -- murder.gettingLostSheepPause = nil
          -- murder.resume()
        -- end, 'waiting for lost sheep')
      -- end
      -- 
      -- 
      -- local pendingRecoveries = 0
      -- local rollcall = common.newRollCall(true)
      -- 
      -- for direction, mobs in pairs(njs50.scanner.exits) do
        -- for idx, mob in pairs(mobs) do
        -- 
          -- local isMember = group.members[mob.raw] and (not murder.mountRaces[group.data[mob.raw].race])
        -- 
          -- if (direction == '[Here]' and isMember) then
            -- rollcall[mob.raw] = true
          -- end
        -- 
          -- if (direction ~= '[Here]' and isMember) then
            -- 
            -- rollcall[mob.raw] = true
            -- 
            -- send('gstat recovering ' .. mob.raw .. ' from ' .. direction)
            -- pendingRecoveries = pendingRecoveries + 1
            -- 
            -- murder.doAck(mob.raw, tfe.consts.reverse_dirs[direction], function()
              -- pendingRecoveries = pendingRecoveries - 1
              -- 
              -- if (pendingRecoveries == 0) then
                -- send('scan')
              -- end
              -- 
            -- end, 5000)
-- 
          -- end -- mobs in other rooms
          -- 
        -- end -- mobs
      -- 
      -- end -- scanner exits
      -- 
      -- -- we have members with no recovery plan?
      -- if (not common.rollCheck(rollcall) and pendingRecoveries == 0) then
        -- 
        -- local gsum = false
      -- 
        -- for member, recoveryPlan in pairs(rollcall) do
          -- if not recoveryPlan then
            -- send('gstat DANGER: no recovery plan for ' .. member)
            -- gsum = true
          -- end
        -- end
        -- 
        -- if (gsum and group.members.Grehild) then
          -- send('gstat attempting group summon w/Grehild - waiting 15')
          -- send('tell grehild do gsummon')
          -- murder.gettingLostSheep = true
          -- murder.pause()
          -- tempTimer(15, function()
            -- murder.gettingLostSheepPause = nil
            -- murder.resume()            
          -- end)
        -- end
      -- 
      -- end
    

    end) -- next scan
    
    send('scan')  
        
  end) 


end


murder.processScan = function ()

  murder.resetExits()
  
  local getPriority = function(tp)
    if type(tp) == 'number' then
      return tp
    end
    return 1
  end
  
  local isDark = function()
    
    if (
      njs50.scanner.exits and 
      njs50.scanner.exits['[Here]'] and 
      njs50.scanner.exits['[Here]'][1].raw == 'darkness'
    ) then
      cecho('... spooky ...')
      return true
    end
    return false
  end
  
  
  -- only look for things to kill if we are actively looking to murder something
  if (murder.enabled or murder.exploring or murder.paused) then	
  
    local rollcall = common.newRollCall(true)
  
    for direction, mobs in pairs(njs50.scanner.exits) do
      
      local targetCount = 0
      local nonTargetCount = 0
      local nonHostileTargetCount = 0
      local ignoredTargetCount = 0
      local firstTarget = nil 
      local allTargets = {} 
      local rubes = {}
      local targetPriority = 0
      local targetScore = 0
      
            
      -- filter out any group members (and mark them off rollcall)
      mobs = table.n_filter(mobs, function(mob) 
        local isMember = group.members[mob.raw]
        if (direction == '[Here]' and isMember) then
          rollcall[mob.raw] = true
        end
        return not isMember 
      end)      
      
 
      mobs = table.n_filter(mobs, function(mob) return not murder.critters[mob.killString] end)

      
      -- display(mobs)
      -- loop over mobs
      for idx, mob in pairs(mobs) do
      
      
  			local ms = mob.killString
  			local count = mob.count
        
        rubes[ms] = count
        
        -- keep track of the target count (targets)
        if murder.nastyTargets and murder.nastyTargets[ms] then

          if type(murder.nastyTargets[ms]) == 'boolean' then
            murder.nastyTargets[ms] = 1
          end
        
        	 targetCount = targetCount + count
          targetScore = targetScore + (murder.nastyTargets[ms] * count)
          
        elseif murder.targets and murder.targets[ms] then
        
          if type(murder.targets[ms]) == 'boolean' then
            murder.targets[ms] = 1
          end
        
        	 targetCount = targetCount + count
          targetScore = targetScore + (murder.targets[ms] * count)
        
        -- non hostile targets  
        elseif (murder.nonHostileTargets and murder.nonHostileTargets[ms]) then

          if type(murder.nonHostileTargets[ms]) == 'boolean' then
            murder.nonHostileTargets[ms] = 1
          end
                    
        		nonHostileTargetCount = nonHostileTargetCount + count
           targetScore = targetScore + (murder.nonHostileTargets[ms] * count)
            
        -- any remaining non ignored targets    
        elseif (not (murder.ignoreTargets[ms] or murder.critters[ms])) then
        
           -- non targets (or not yet found targets)
        	  if (murder.exploring) then
            targetCount = targetCount + count
          	  cecho('\n&lt;green&gt;EXPLORER: &lt;white&gt;new target aquired - ' .. ms)
          		murder.targets[ms] = true
          else
            -- cecho('&lt;orange&gt;MURDER:&lt;white&gt; adding non target ' .. ms .. '\n')
            nonTargetCount = nonTargetCount + count
          end
        
        else
          
          ignoredTargetCount = ignoredTargetCount + count
          -- ignored target! (do nothing)
        end
    
    
      end -- end loop over mobs
      

      local distinctTargets = 0
      local nastyTarget = false

      if (murder.nastyTargets)	then
        	for target, tp in pairs(murder.nastyTargets) do
        	-- echo('\n target is: ' .. target)
        		if rubes[target] then
            local dotTarg = common.dotCase(target)
            nastyTarget = true
        			distinctTargets = distinctTargets + 1
        			if (getPriority(tp) &gt; targetPriority) then
        			   firstTarget = dotTarg
                targetPriority = getPriority(tp)
        			end
        			for i=1, rubes[target] do
              table.insert(allTargets, tostring(i) .. '.' ..dotTarg)
            end
        		end
        	end
      end
      
      if (murder.targets)	then
        	for target, tp in pairs(murder.targets) do
        	-- echo('\n target is: ' .. target)
        		if rubes[target] then
            local dotTarg = common.dotCase(target)
        			distinctTargets = distinctTargets + 1
        			if (getPriority(tp) &gt; targetPriority) then
        				firstTarget = dotTarg
               targetPriority = getPriority(tp)
        			end
        			for i=1, rubes[target] do
              table.insert(allTargets, tostring(i) .. '.' ..dotTarg)
            end
        		end
        	end
      end
      
      
       -- and non hostile targets...
      
      -- gotta do these loops here to allow target priority		
      		
      if (murder.nonHostileTargets)	then
      	for target, tp in pairs(murder.nonHostileTargets) do
      	-- echo('\n target is: ' .. target)
          if rubes[target] then
            local dotTarg = common.dotCase(target)     		
        		  if (getPriority(tp) &gt; targetPriority) then
        				firstTarget = dotTarg
               targetPriority = getPriority(tp)
        			end
            distinctTargets = distinctTargets + 1
            for i=1, rubes[target] do
              table.insert(allTargets, tostring(i) .. '.' ..dotTarg)
            end
      	  end
      	end
      end				
      
      
      if (firstTarget) then
      	 murder.addExitTarget(
          direction, 
          firstTarget, 
          -- targetCount,  using target score instead of count
          math.ceil(targetScore),
          nonHostileTargetCount, 
          nonTargetCount, 
          distinctTargets, 
          allTargets, 
          nastyTarget
        )
      end

    end -- end loop over directsion
    
    
    tfe.roomInfo.murder_scanned = true
    
    -- we can check the roll call now scan is processed
    if ( murder.enabled and 
         not murder.holdHere == true and
         not murder.noRegroup and
         not isDark() and 
         murder.exitForSleepKill ~= true and 
         not common.rollCheck(rollcall)
        ) then
      -- return so as not to       
      return murder.regroup()
    end   
    

    cecho('&lt;green&gt;&lt;-- scan processed\n')
    raiseEvent(common.events.SCAN_PROCESSED)
    if (murder.exits.here == nil or murder.exits.here.targetCount == 0) then
      raiseEvent(common.events.ROOM_CLEAR)
    end 

    
  end -- if scanner is enabled
  
end

if (murder.scanWatcher) then
  killAnonymousEventHandler(murder.scanWatcher)
  murder.scanWatcher = nil
end

murder.scanWatcher = registerAnonymousEventHandler(njs50.scanner.events.SCAN_PROCESSED, murder.processScan)
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>team</name>
				<packageName></packageName>
				<script>-- this is obsolete now w/plev-v2?
common.includeInRollCalls = {
  Mojune = true,
  Mohoonay = true,
  Myrth = true,
  Grehild = true,
  Darion = true,
  Darius = true,
  Bimgore = true,
	-- Marial = true,
	-- Grackle = true,
  -- Raksha = true,
  -- Gnodrick = true,
  Grexil = true,
}


common.healGroup = function(groupHealer, cb)
  tempRegexTrigger('^' .. groupHealer .. ' reports group status: "group healed"$', cb, 1)
  send('gstat ' .. groupHealer .. ' heal group')
end


common.comeToMe = function (callback)

  local roll = common.newRollCall(true)
  

  if (#table.keys(roll) == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping regroup due to only one party member\n\n')
    callback()
    return
  end


	local mcb = callback
	

	tempTimer(2, function ()

		local atTrig

		local preFetchState = mapper.paused

		mapper.paused = true

  	atTrig = tempRegexTrigger([[^.+ reports group status[^:]*: "(\w+) is now at (\d+)"]], function ()
  		if (tostring(tfe.roomInfo.num) == matches[3]) then

				roll[matches[2]] = true

				if (common.rollCheck(roll)) then
					mapper.paused = preFetchState
					send('gstat all here - moving...')
  				killTrigger(atTrig)
  				mcb()
				end

			else
				send('mutter')
				send('gstat ' .. matches[2] .. ' go to ' .. tostring(tfe.roomInfo.num))
			end

  	end)

		send('gstat meet at ' .. tostring(tfe.roomInfo.num))


	end, 'comeToMe')

end

common.collectFollowers = function (callback)

	if (not murder.paused) then
		murder.pause()
	end


	local roll = common.newRollCall(true)

	send('stand &amp; remove blanket')

	local outStandingResponses = group.memberCount - 1

	local onAllResponded = function ()

  	for key, value in pairs(roll) do
  		if (value ~= true) then
  			cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;' .. key .. ' is lost at ' .. tostring(value) .. '\n')
				tfe.gotoRoom(value, function()
          tempTimer(3, function()
					   common.collectFollowers(callback)
          end, 'finding next follower?')
				end)
				return
  		end
  	end

		-- if we got to here then everyone is here already
		cecho('\n\n&lt;green&gt;MURDER: &lt;white&gt;everyone is collected now!\n')
		if (murder.paused) then
  		murder.resume()
  	end
		callback()

	end


	tempRegexTrigger([[^.+ reports group status[^:]*: "(\w+) is at (\d+)"]], function ()

		local vnum = tonumber(matches[3])

		if (tfe.roomInfo.num == vnum) then
			roll[matches[2]] = true
		else
			roll[matches[2]] = vnum
		end

		outStandingResponses = outStandingResponses - 1

		if (outStandingResponses == 0) then
			onAllResponded()
		end

	end, outStandingResponses)

	send('gstat where are you?')

end


common.fixConditions = function (callback)

	if (not murder.paused) then
		murder.pause()
	end

	local roll = common.newRollCall(false)

	local healthyCheckId = tempRegexTrigger([[^.+ reports? group status: "healthy - (\w+)"]], function ()
		local vic = matches[2]
		if (vic == 'You') then vic = player.name end
		roll[matches[2]] = true
	end)

	send('gstatus condition report')

	tempTimer(5, function ()

		killTrigger(healthyCheckId)

		if common.rollCheck(roll) then
			send('gstatus all healthy')
			if (murder.paused) then
    		murder.resume()
    	end
  		if callback then callback() end
		else
			send('gstatus not yet healthy enough... retrying')
			tempTimer(10, function()
				common.fixConditions(callback)
			end, 'waiting for cures before checking conditions')
		end

	end)

end


common.newRollCall = function (excludeSelf)

	local roll = {}

	for name, value in pairs(group.members) do
    if (common.includeInRollCalls[name]) then
		  roll[name] = false
    end
    -- pets get a free pass
    if (group.data[name].race == 'unknown') then
		  roll[name] = true
    end
	end

	if (excludeSelf) then
		roll[player.name] = true
	end

	return roll

end

common.rollCheck = function(roll)

	for key, value in pairs(roll) do
		if (not value) then
			return false
		end
	end
	return true

end



common.sendPlayer = function (player, rnum, callback)

	local ncb = callback
	tempRegexTrigger([[^.+ reports group status[^:]*: "]] .. player .. [[ is now at ]] .. tostring(rnum) .. [["]], function ()
		ncb()
	end, 1)

	send('gstat ' .. player .. ' go to ' .. tostring(rnum))

end


common.sendDruid = function (player, rnum, callback)

  if (tfe.locations[rnum]) then
    rnum = tfe.locations[rnum]
  end

	local ncb = callback
	tempRegexTrigger([[^.+ reports group status[^:]*: "]] .. player .. [[ is now at ]] .. tostring(rnum) .. [["]], function ()
		ncb()
	end, 1)

	send('gstat ' .. player .. ' landwalk to ' .. tostring(rnum))

end


common.groupOnReady = function (cb)

	local grcb = cb

	local rct

	local roll = common.newRollCall(false)


	local readyCheck = function ()
		if (common.rollCheck(roll)) then -- group members
			killTrigger(rct)
  		if (grcb) then
  			grcb()
  		end
		end
	end
  
  -- display(roll)

	rct = tempRegexTrigger([[^.* reports? group status[^:]*: "ready \((.*)\)"]], function ()
		roll[matches[2]] = true
		readyCheck()
	end)

end

common.groupPrepIfUnder = function (options)

  local cb = options.callback or function() end

  local cmd = 'gstat report if '

  local cleanUp, ttt, rcTrig
  
  if (options.mana) then
    cmd = cmd .. 'mana &lt; ' .. tostring(options.mana) .. '%, '
  end
   
  if (options.heals) then
    cmd = cmd .. 'heals &lt; ' .. tostring(options.heals) .. 'hp, '
  end 

  if (options.storms) then
    cmd = cmd .. 'storms &lt; ' .. tostring(options.storms) .. ', '
  end 
  
  cmd = cmd:gsub(', $', '')
  
  

  
  local prepFn = function()
    cleanUp()
    common.groupOnReady(function ()
    		send('gstat mudering continues')
    		cb()
    	end)   
   
    if (options.prepType == 'full') then
      send('gstat pfull')
    elseif (options.prepType == 'free') then
      send('gstat pfree')
    else
      send('gstat get ready')
    end  
      
  end
  
  local contFn = function()
    cleanUp()
    send('gstat mudering continues')
    cb()
  end
  
  
  ttt = njs50.timedTempTrigger(10, 1, [[^[^"]+ reports? group status: "need prep"$]], function()
    ttt = nil
    prepFn()
  end, function()
    ttt = nil
    contFn()
  end)
  
  local roll = common.newRollCall()
  
  rcTrig = tempRegexTrigger([[^(.*) reports? group status: "prepared enough"$]], function()
    local vic = matches[2]
    if vic == 'You' then vic = player.name end
    roll[vic] = true
    
    if (common.rollCheck(roll)) then
      contFn()
    end
    
  end)
  
  
  cleanUp = function()
    if (ttt) then
      killTimer(ttt.timerId)
      killTrigger(ttt.triggerId)
    end
    killTrigger(rcTrig)
  end  

  
	send(cmd)

end

common.groupPrepFree = function (cb)

	local pfcb = cb

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping group prep full due to only one party member\n\n')
    player.prepFull(pfcb)
    return
  end

	common.groupOnReady(function ()
		send('gstat going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gstat pfree')

end


common.groupPrepFull = function (cb)

	local pfcb = cb

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping group prep full due to only one party member\n\n')
    player.prepFull(pfcb)
    return
  end

	common.groupOnReady(function ()
		send('gstat going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gstat get full')

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>instrumenting</name>
				<packageName></packageName>
				<script>farmer.time = farmer.time or {}

farmer.time.namedStart = function(name)
  farmer.time.named = farmer.time.named or {}
  farmer.time.named[name] = getEpoch()
end

farmer.time.namedStop = function(name, callback)

  if (not farmer.time.named[name]) then
    cecho('\n\n&lt;red&gt;MURDER:&lt;white&gt; named timer stoped but wasn\'t started - ' .. name .. '\n\n') 
  end

  farmer.time.namedTimes = farmer.time.namedTimes or {}
  farmer.time.namedTimes[name] = farmer.time.namedTimes[name] or 0
  
  farmer.time.namedTimes[name] = farmer.time.namedTimes[name] + getEpoch() - farmer.time.named[name]
  
  farmer.lapInfo = farmer.lapInfo or {}
  farmer.lapInfo[name] = math.ceil(farmer.time.namedTimes[name])  
  
  if (callback) then
    callback()
  end
end

farmer.time.reset = function(name)
  farmer.time.namedTimes = farmer.time.namedTimes or {}
  for val, name in pairs(table.keys(farmer.time.namedTimes)) do
    farmer.time.namedTimes[name] = 0
  end
end


farmer.time.snoozeStart = function()
  farmer.time.namedStart('snooze_time')
end

farmer.time.snoozeStop = function()
  farmer.time.namedStop('snooze_time')
end

</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>bot scripts</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>player.beach.imps</name>
				<packageName></packageName>
				<script>




farmer.afterCommonLoaded(function ()

local useTobacco = false


local getImproveCommand = function(exit)
  
  if (improves.sawAction) then
    cecho('\n&lt;green&gt;IMPS:&lt;white&gt; waiting for action timer to cool down\n')
    return ''
  end
  
  -- check if any of our buffs need to be queued for improves
  njs50.respell(player.buffs, {queueSpellImprove = true})
  
  
  -- if no imp queued then do the murdery type move
  if (#improves.castQueue == 0) then
    
    if (exit and exit.firstTarget) then
      return improves.improveCombat(player.improveThings, exit.firstTarget)
    else
    	 return ''
    end
    
  else
    
    if (improves.castFillerLastTick ~= false) then
      improves.castFillerLastTick = false
      
      improves.sawAction = true
      if (improves.actionRelease) then
        killTimer(improves.actionRelease)
      end      
      improves.actionRelease = tempTimer(40, function()
        -- send('stand &amp; |scan')
        improves.actionRelease = nil
        improves.sawAction = nil
        improves.releaseAt = nil
      end, 'combat, sawAction reset') 
        
      if (useTobacco) then     
        murder.smokeUp('imps-no-wis','imps-regen', 3, function()
          improves.castSpell()
          send('wait 3')
        end)
      else
        improves.castSpell()
        send('wait 3')
      end
      return ''
    end
    
  end  
  
  

  
end

local options = {

  longName = 'beach.imps',

  targets = {
    ["sea.gull"] = 1,
    ["small.green.crab"] = 1,
    ["large.fish"] = 1,
    ["lobster"] = 1,
    ["pelican"] = 1,
  },

  getKillCommand = getImproveCommand,

  onStopByTrigger = function ()
    send('stop was commanded - begin self destruct sequence')
  end,

}

local steps = {

  {
    waypoints = {21039}, -- repop
    action = function (cb)
      send('group -l Lacopa')
      -- common.comeToMe(function ()
        -- common.groupPrepFull(function ()
          improves.sawAction = false
          -- njs50bot.sleepUntilFull(function()
            -- cb()
            common.checkRepopByDrop(22000, [[^\S+ \w+ coins? lies?]], cb, 5)
          -- end)
        -- end)
      -- end)
    end,
  },
  { 
    waypoints = { 22000 },
    action = "drop silver.coin"
  },
  {
    waypoints = {22040, 22009, 22030, 22033, 22002, 22000, 22031}
  },

  {
    waypoints = {21039}, -- repop
  },

}

local completeCallback = function ()
  send('gstat beach.imps is done...')
  -- expandAlias('sort beach.imps junk')
  tempTimer(5, function ()
    farmer.restart()
  end)
end

farmer.configure('player.beach.imps', steps, completeCallback, options)

end)</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>area specific</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>western expanses</name>
				<packageName></packageName>
				<script>murder.area = murder.area or {}
 

murder.area.we = murder.area.we or {}

murder.area.we.search_meteor = function(cb)
  
  equipPartial('digging', function ()
    send('dig crater &amp; |get all &amp; |drop all.corpse &amp; |get all crater')
    resetGear(function()
      send('gstat crater searched')
      if (cb) then cb() end
    end)
  end) 
  
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>njs50-mage</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>generic mage stuff</name>
				<packageName></packageName>
				<script>mage = mage or {}

mage.events = {}

mage.events.EAGLE_EYE = 'MAGE:eagle_eye_performed'</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>mage-sleep-plev</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>power leveling</name>
					<packageName></packageName>
					<script>-- local damState = {
 -- ['perfect health'] = 1,
 -- ['slightly scratched'] = 0.95,
 -- ['few bruises'] = 0.85,
 -- ['some cuts'] = 0.75,
 -- ['several wounds'] = 0.65,
 -- ['badly wounded'] = 0.55,
 -- ['many nasty wounds'] = 0.45,
 -- ['bleeding freely'] = 0.35,
 -- ['covered in blood'] = 0.25,
 -- ['leaking guts'] = 0.15,
 -- ['mostly dead'] = 0.1,
 -- ['stunned'] = 0,
 -- ['incapacitated'] = 0,
 -- ['mortally wounded'] = 0,
 -- ['DEAD!'] = 0
-- }

plev = plev or {}

plev.danceThreshold = 0.15

plev.noAckThreshold = 0.25

plev.wakeCommand = 'kill'

plev.useMount = false

-- murder.setWaker('Darion')
-- murder.setWaker('Mojune')

murder.tapWaitAck = 3.5
-- murder.tapWaitAck = 3.0

-- murder.setWaker(nil)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>murder tools</name>
					<packageName></packageName>
					<script>
mojune = mojune or {}

murder.ackIdx = murder.ackIdx or 0

plev = plev or {}

plev.mobHits = plev.mobHits or 0



murder.getLastTargetInRoomMatching = function(target)

  local highestIdx = 1
  
  local here = murder.exits.here
  if (here) then    
    for _, t in pairs(here.allTargets) do
      local match = rex.match(t, [[^(\d+)\.]] .. target .. [[$]])
      if (match) then      
        highestIdx = match      
      end  
    end 
  end
  
  return tostring(highestIdx) .. '.' .. target

end


murder.groupGetFull = function(cb)
  
  local finishIfFull 
  
  finishIfFull = function(cb)
  
    for nub, deets in pairs(gmcp.Group.members) do
      if (
        group.data[nub].hp &lt;= group.data[nub].hp_max * 0.9 or
        group.data[nub].moves &lt;= group.data[nub].moves_max * 0.9 or
        group.data[nub].mp &lt;= group.data[nub].mp_max * 0.9
      ) then
       send('group')
       cecho(nub .. ' still needs more rest\n')
        tempTimer(10, function()
          finishIfFull(cb)
        end, 'letting nubs sleep')
        
       return
          
     end     
              
    end
    
    murder.groupDoAnywayAck('stand', function()
      cb()
    end)
  
  
  end
    
  murder.groupDoAnywayAck('sleep', function()

    finishIfFull(cb)
    
  end)
  
end



murder.setWaker = function(player)

  if (player and group.members[player]) then
    send('gstat allocating waking duties to ' .. player)
    murder.waker = player
  else
    send('gstat allocating waking duties to everyone')
    murder.waker = nil
  end

end


murder.groupDo = function(cmd, excludeList)
  excludeList = excludeList or {}
  
  for member in pairs(group.members) do
    
    -- exclude pets
    if (murder.mountRaces[group.data[member].race]) then
      excludeList[member] = true
    end  
  
    if (member ~= player.name and not excludeList[member]) then
      send('tell ' .. member .. ' do ' .. cmd)
    end
    
  end

end


murder.failedDoAck = function()
  local key = 'failed ack'
  farmer.lapInfo = farmer.lapInfo or {}
  farmer.lapInfo[key] = farmer.lapInfo[key] or 0
  farmer.lapInfo[key] = farmer.lapInfo[key] + 1
end

murder.groupDoAnywayAck = function(cmd, cb, timeout, excludeList)
  murder.groupDoAck(cmd, cb, cb, timeout, excludeList)
end

murder.allDo = function(cmd, cb)
  murder.groupDoAnywayAck(cmd, function()
    expandAlias(cmd)
    if (cb) then cb() end
  end)
end

murder.groupEquipGearSet = function(set, cb)
  murder.groupDoAnywayAck('gear ' .. set, function()
    equipSet(set, cb)
  end)
end


murder.groupEquipPartialGearSet = function(set, cb)
  murder.groupDoAnywayAck('gear-partial ' .. set, function()
    equipPartial(set, cb)
  end)
end


murder.groupResetGearSet = function(cb)
  murder.groupDoAnywayAck('gear-reset', function()
    resetGear(cb)
  end)
end


murder.groupDoAck = function(cmd, cb, fcb, timeout, excludeList)
  excludeList = excludeList or {}

  timeout = timeout or 10
  
  local groupRoll = {}
  
  for pName, pData in pairs(gmcp.Group.members) do 
    
    -- exclude pets
    if (murder.mountRaces[pData.race]) then
      excludeList[pName] = true
    end
  
    if (not excludeList[pName] and pName ~= player.name) then
      groupRoll[pName] = false
    end
  end
  
  -- if there isn't a group we are good!
  if (#table.keys(groupRoll) == 0)  then
    if (cb) then cb() end
    return
  end
  
  -- common.rollCheck(groupRoll)
  local failed = false

  for member in pairs(group.members) do
    if (member ~= player.name and not excludeList[member]) then
     
      murder.doAck(
        member,
        cmd, 
        function()
          if (not failed) then
            groupRoll[member] = true
            if common.rollCheck(groupRoll) then
              cecho('\n\n&lt;green&gt;GROUP DO: &lt;white&gt;acknowledged: ' .. cmd .. '\n\n')
              if (cb) then cb() end
            end
          else
            cecho('\n\n&lt;red&gt;GROUP DO: &lt;white&gt;acknowledgement from ' .. member .. ' for "' .. cmd .. '" (failed group do)\n\n')
          end
        end, 
        function()
          cecho('\n\n&lt;red&gt;GROUP DO: &lt;white&gt;failed to get acknowledgement from ' .. member .. ' for ' .. cmd .. '\n\n')
          -- only run fail callback once
          if (not failed) then
            failed = true
            murder.failedDoAck()
            if (fcb) then fcb() end
          end
        end,
        timeout
      )
      
    end
  end

end



murder.doAck = function(target, cmd, callback, failCB, timeout) 
  
  timeout = timeout or 10
  
  murder.ackIdx = murder.ackIdx + 1
  
  local thisAck = murder.ackIdx
  
  local sendTimer = getEpoch() * 1000
  
  local cmds = cmd:split(' &amp; ')
  
  local cb = function()
    cecho('\n&lt;green&gt;DO: &lt;white&gt;acknowledged ' .. tostring(thisAck) .. ' after ' .. tostring((getEpoch() * 1000 - sendTimer)) .. 'ms\n')
    if (callback) then
      callback()
    end
  end
  
  local fcb = function()
    cecho('\n&lt;green&gt;DO: &lt;white&gt;failed to acknowledge ' .. tostring(thisAck) .. ' after ' .. tostring(timeout * 1000) .. 'ms\n')
    send('gstat ' .. target .. ' failed failed to acknowledge ' .. tostring(thisAck) .. ' after ' .. tostring(timeout * 1000) .. 'ms\n')
    if (failCB) then
      failCB()
    end
  end
    
  
  for idx, thisCmd in ipairs(cmds) do
    if thisCmd ~= '' then
      send('tell ' .. target .. ' do ' .. thisCmd)
    end
  end
  
  common.timedTempTrigger(timeout, 1, [[^(&lt;[^&gt;]*&gt;)?]] .. target .. [[ tells you[^:]*: "ack: ]] .. tostring(thisAck) .. [["$]], cb, fcb)
  send('tell ' .. target .. ' do queue tell ' .. player.name .. ' ack: ' .. tostring(thisAck))


end

murder.doAnywayAck = function(target, cmd, callback, timeout)
  murder.doAck(target, cmd, callback, callback, timeout)
end

murder.mobSlept = function(target)
  
  fromRetry = fromRetry or false

  cecho(' &lt;-- sleeps since hit ' .. tostring(plev.mobHits) .. '\n')

  if (player.sleepRetryTimer) then 
    killTimer(player.sleepRetryTimer)
    player.sleepRetryTimer = nil
  end  
      
      
  if (player.tapLocked and not (player.tapTryCount and player.tapTryCount &gt;= 11) ) then
    
    -- ignore if a mob has been slept more than once while we are still waiting for the tap lock to go
    if (not murder.pendingReturnParry) then
      cecho('&lt;red&gt;MURDER: &lt;white&gt; ingoring additional sleep while waiting for tap lock to be resolved\n')
      return
    end
    
    player.tapTryCount = player.tapTryCount or 0
    player.tapTryCount = player.tapTryCount + 1    
    
    cecho('&lt;red&gt;MURDER: &lt;white&gt; waiting for previous taplock to complete (pending parry), trying again in 1s, attempt: ' .. tostring(player.tapTryCount) .. '\n')
    
    player.sleepRetryTimer = tempTimer(1, function()
      player.sleepRetryTimer = nil
      murder.mobSlept(target)
    end)

    
    return
    
  end
  

  -- if the mob isn't dead after we slept it 10 times since last validated hit we will toggle parry
  if (plev.mobHits &gt; 6 ) then
    local key = 'opt parry bung'
    farmer.lapInfo = farmer.lapInfo or {}
    farmer.lapInfo[key] = farmer.lapInfo[key] or 0
    farmer.lapInfo[key] = farmer.lapInfo[key] + 1
    murder.groupDoAnywayAck('opt parry', function()
      plev.mobHits = 0
      murder.mobSlept(target)
    end)
    return
  end


  if (murder.preSleeping) then
  
    cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;cleared sleep target (presleeping)\n\n')
    player.sleepTarget = nil
  
  elseif (player.sleepMurderLockout) then
  
    cecho(' &lt;-- Mob is currently locked by previous mob slept less than 750ms ago\n')
  
  elseif (group.members[target]) then --  or not (murder.targets[target] or murder.nonHostileTargets[target])
  
    cecho(' &lt;-- Mob is not scheduled for execution\n')
  
  else
    
    player.sleepMurderLockout = true
    tempTimer(0.5, function()
      player.sleepMurderLockout = nil
    end)
    
    cecho(' &lt;-- Mob is at: ' .. tostring(plev.currentMobState *100) .. '% hp?\n')
    
    if (plev.currentMob ~= target:lower()) then
      plev.currentMob = target:lower()
      cecho('\n^^ new target was assigned\n')
    end
    
    -- continue sleeping ...
    if (plev.currentMobState &gt; plev.noAckThreshold) then
    
      cecho('\n\n&lt;orange&gt;MUDER: &lt;white&gt;no ack needed\n\n')
      
      if (murder.waker and group.members[murder.waker]) then
      
        if (plev.wakeCommand == 'backstab' and group.memberCount &gt; 2) then
          if (plev.useMount) then
            send('tell ' .. murder.waker .. ' do dismount')
          end
          send('tell ' .. murder.waker .. ' do ' .. plev.wakeCommand  .. ' ' .. target)
          local exclude = {}
          exclude[murder.waker] = true;
          tempTimer(0.35, function()
            murder.groupDo('kill ' .. plev.currentMob, exclude)
          end)
        else
          if (plev.useMount) then
            send('tell ' .. murder.waker .. ' do dismount')
          end
          send('tell ' .. murder.waker .. ' do ' .. plev.wakeCommand  .. ' ' .. target)
        end   
        
      else
        murder.groupDo('kill ' .. plev.currentMob)
      end
      
      plev.mobHits = plev.mobHits + 1
      murder.mobTaps = 0
      if (probe) then
        probe.lastMob = plev.currentMob
      end
      player.sleepTarget = plev.currentMob
      cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;set sleep target from mob slept no ack (' .. plev.currentMob .. ')\n\n')
    
    elseif (plev.currentMobState &gt; plev.danceThreshold) then
      
      if (probe) then
        probe.lastMob = plev.currentMob
      end
      
      cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;set sleep target from mob slept ack (' .. plev.currentMob .. ')\n\n')
      player.sleepTarget = plev.currentMob
      
      if (player.tapLocked and not (player.tapTryCount and player.tapTryCount &gt;= 5)) then
      
        player.tapTryCount = player.tapTryCount or 0
        player.tapTryCount = player.tapTryCount + 1
        cecho('&lt;red&gt;MURDER: &lt;white&gt; waiting for pending tap to be cleared, attempt: ' .. tostring(player.tapTryCount) .. '\n')
      
      else
        
        cecho('\n\n&lt;orange&gt;MUDER: &lt;white&gt;hit on ack\n\n')
        player.tapLocked = true
        player.tapTryCount = nil
        murder.groupDoAnywayAck('', function()
          player.tapLocked = nil
          player.tapTryCount = nil
          if (plev.currentMobState &gt; plev.danceThreshold) then
            murder.groupDo('kill ' .. plev.currentMob)
            murder.mobTaps = 0
            plev.mobHits = plev.mobHits + 1
          else
            -- state has changed since we requested ack. reassess...
            return murder.mobSlept(target)
          end
        end)
        
      end
      
     -- starting hacking.. 
    elseif (plev.currentMobState &gt; 0 and plev.currentMobState &lt;= plev.danceThreshold) then

    
      player.tapLocked = true
      player.tapTryCount = nil
      murder.mobTaps = murder.mobTaps + 1
      cecho('&lt;green&gt;MURDER: &lt;white&gt; starting to tap mob: ' .. plev.currentMob .. '\n')
      murder.tapTarget(plev.currentMob, tfe.consts.reverse_dirs[tfe.lastMoveDirection], function()
        player.tapLocked = nil
        player.tapTryCount = nil
      end)

        
    else   
      cecho('&lt;red&gt;MURDER: &lt;white&gt; looks like mob died/incap while waiting to tap?: ' .. plev.currentMob .. '\n')
      player.tapLocked = nil
      player.tapTryCount = nil
      plev.currentMobState = 1       
    end
    
  end

end

murder.resetState = function()

  cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;murder state fully reset!!!!\n\n')
  player.tapLocked = nil
  player.tapTryCount = nil
  murder.sleepDancing = nil
  
  murder.exitForSleepKill = nil
  player.sleepTarget = nil
  murder.mobTaps = 0
  plev.mobHits = 0
  
  plev.currentMobState = 1
  plev.currentMob = ''

  if (mage and mage.pendingEE) then
    mage.pendingEE = nil
  end

  murder.cancelTap()
    
  -- murder.scan('murder state reset')
  
end


murder.tapMobDied = function(sawItdie, mob)
  
  local key
  
  if (sawItdie) then
  
    -- it's possible for the "tank" to kill a paralysed mob before   
  
    murder.exitForSleepKill = nil
    murder.tapState = 'premature-murder'
    murder.sleepDancing = nil 
    
    send('gstat saw it die: ' .. mob .. ' - ' .. tostring(murder.mobTaps) .. ' taps')
    
    -- hold until everything is in sync in case of previously queued scans etc
    -- murder.holdHere = true
    
    cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;cleared sleep target (death seen)\n\n')
    key = 'no xp mobs'


  else
  
    send('gstat heard it die - ' .. tostring(murder.mobTaps) .. ' taps') 
    cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;cleared sleep target (death heard)\n\n')
    key = 'xp mobs'
    
  end  
  

  farmer.lapInfo = farmer.lapInfo or {}
  farmer.lapInfo[key] = farmer.lapInfo[key] or 0
  farmer.lapInfo[key] = farmer.lapInfo[key] + 1  
  
  player.sleepTarget = nil
  player.tapLocked = nil
  player.tapTryCount = nil
  plev.currentMobState = 1
  plev.currentMob = ''
  plev.mobHits = 0
  
  murder.lastKillTime = getEpoch()


  murder.resetIdleTimer()
  

  -- if (murder.tapRoomWatcher == nil) then
    -- murder.scan('dead in next room')
  -- end  
  
  
end

murder.tapTargetMissing = function()
  -- murder.scan('missing mob')
  cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;cleared sleep target (mob missing)\n\n')
  player.sleepTarget = nil
  plev.currentMobState = 1
  plev.currentMob = ''
  plev.mobHits = 0
end

murder.cancelTap = function()
  if (murder.tapRoomWatcher) then
    murder.tapRoomWatcher()
    murder.tapRoomWatcher = nil
  end
end

murder.tapWaitAck = murder.tapWaitAck or 2.75

murder.tapTarget = function(target, exitDirection, callback)
  
  if (murder.exitForSleepKill) then
    cecho('\n\n&lt;red&gt;MUDER: &lt;white&gt;already on a mission to kill a sleeping thing\n\n')
    return
  end
  
  if (not tfe.roomInfo.exits[exitDirection]) then
    cecho('\n\n&lt;red&gt;MUDER: &lt;white&gt;attempted to exit in a non existant direction! ' .. exitDirection .. '\n\n')
    return
  end


  cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;setting up tap target ' .. exitDirection .. ' (' .. target .. ')\n\n')

  murder.sleepDancing = true

  player.sleepTarget = target
  murder.exitForSleepKill = true

  local sitCmd = 'sit'
  
  if (plev.useMount) then
    sitCmd = 'dismount &amp; sit'
  end

  murder.tapState = 'sitting'
  murder.groupDoAnywayAck(sitCmd, function() 
    
    -- if the mob died while we were waiting for player to sit...
    if (murder.tapState == 'premature-murder') then
      cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;mob died while we were waiting for player to sit!!\n\n')    
      murder.groupDoAnywayAck('stand', function()
        murder.sleepDancing = nil
        murder.scan('sleep dance finished')
        callback()
      end)      
      return
    end


    murder.tapState = 'leaving'
    murder.tapRoomWatcher = common.onNextEvent(tfe.events.ROOM_CHANGED, function() 
    
      cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;exited room after sleeping mob\n\n')    
    
      local returnFn = function() 
        
        -- this tap watcher will need to be cancelled if the mob died with us in the room
        murder.tapState = 'returning'
        murder.tapRoomWatcher = common.onNextEvent(tfe.events.ROOM_CHANGED, function()
          
          cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;cleared sleep target after returning to room\n\n')
          player.sleepTarget = nil
          murder.tapRoomWatcher = nil
          murder.pendingReturnParry = true
          
          cecho('\n\n&lt;yellow&gt;MUDER: &lt;white&gt;returned to room with previously sleeping mob to resleep\n\n')
          murder.exitForSleepKill = nil
          murder.groupDoAnywayAck('opt parry', function() 
            murder.pendingReturnParry = nil
            if (callback) then
              murder.sleepDancing = nil
              murder.scan('sleep dance finished')
              callback()
            end
          end)
        end)
        
        send(tfe.consts.reverse_dirs[exitDirection] .. ' &amp; cast sleep ' .. target)
      
      end
      
      -- if the mob died while we were waiting for the room to change
      -- then on getting to the new room we need to cancel the whole
      -- taplock business
      
      if (murder.tapState == 'premature-murder') then
        
        cecho('\n\n&lt;red&gt;MUDER: &lt;white&gt;mob died while our leave room was queued!!\n\n')    
        -- state was all reset on seeing the mob die
        -- however we are still in the wrong room
        -- reroute should happen automatically      
      
      elseif (murder.waker and group.members[murder.waker]) then
     
        
        murder.tapState = 'standing'
        murder.groupDoAnywayAck('stand', function()
         
          local exclude = {}
          exclude[murder.waker] = true;
          
          cecho('\n&lt;green&gt;MUDER:&lt;white&gt; ' .. murder.waker .. ' should wake them up now\n\n')          

  
          murder.tapState = 'parrying'
          murder.groupDoAnywayAck('opt parry', function() 
            if (plev.useMount) then
              send('tell ' .. murder.waker .. ' do dismount')
            end
            send('tell ' .. murder.waker .. ' do ' .. plev.wakeCommand  .. ' ' .. target)
            send('tell ' .. murder.waker .. ' do opt parry')
            if (plev.useMount) then
              send('tell ' .. murder.waker .. ' do mount')
            end
          
            murder.tapState = 'waking'
            murder.doAnywayAck(murder.waker, '', returnFn, murder.tapWaitAck)
          
          end, 10, exclude)


        end, 10)
     

 
      else 
      
        murder.tapState = 'standing'
        murder.groupDoAnywayAck('stand', function()  
        
          if (plev.useMount) then
            murder.groupDoAnywayAck('mount &amp; kill ' .. target .. ' &amp; opt parry', returnFn, murder.tapWaitAck)
          else
            murder.groupDoAnywayAck('kill ' .. target .. ' &amp; opt parry', returnFn, murder.tapWaitAck)
          end
        end, 10)
        
      end
      
      plev.mobHits = plev.mobHits + 1
      
       
    end)
  

    send(exitDirection) 
  
  end)
    
  
end





murder.parryOff = function(unit, callback)
  -- murder.doAck(unit, 'option parry', callback)
end






mojune.suspendMurder = function (callback) 

  if (group.memberCount == 1) then
    callback()
  else
  
  	local ncb = callback or function () end
  	tempRegexTrigger([[^.* reports group status[^:]*: "holding off on the murdering"]], ncb, 1)
  	send('gstat murder time paused')
  end
	
end


mojune.resumeMurder = function (callback) 

  if (group.memberCount == 1) then
    
    callback()
    
  else
  
  	local ncb = callback or function () end
  	tempRegexTrigger([[^.* reports group status[^:]*: "resuming the murdering"]], ncb, 1)
  	send('gstat murder time resumed')
	
  end
	
end

			</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>plev.combat_hit</name>
					<packageName></packageName>
					<script>-- Darion's strike devastates [24] a stone giant's left leg.  [ leaking guts ]
-- Darion's strike * EVISCERATES * [116] a stone giant's stomach!  [ DEAD! ]


plev = plev or {}

plev.currentMob = plev.currentMob or ''
plev.currentMobState = plev.currentMobState or 1

-- rabies: 

plev.combat_hit = function(evt, attackData)
  
  local target = common.dotCase(common.toMurderString(attackData.mob))

  if (murder.targets[target] or murder.nonHostileTargets[target]) then
    
    if (attackData.mobState and common.damState[attackData.mobState]) then
    
      plev.currentMob = murder.getLastTargetInRoomMatching(target)
      
      plev.currentMobState = common.damState[attackData.mobState] or 0
      plev.mobHits = 0
      cecho(' &lt;-- Mob is at: ' .. tostring(plev.currentMobState *100) .. '% hp\n')
      
    end
      
  end
  
  
end

</script>
					<eventHandlerList>
						<string>COMMON::combat_attack</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>plev.mob_arrived</name>
					<packageName></packageName>
					<script>murder.scan('mob entered room - update scan data')</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="no" isFolder="yes">
				<name>auto-spell-select</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>probe</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
probe = probe or {}

probe.enabledSpells = {
  fire = true,
  acid = false,
  elec = true,
  cold = true,
  sleep = true,
}

probe.elementOverrides = {
	-- ['skeletal.knight'] = 'chain',
	-- ['skeletal.warrior'] = 'chain',
	-- -- ['skeletal.guardian'] = 'chain',
	-- ['lesser.skeletal.warrior'] = 'chain',
	-- ['skeletal.warrior'] = 'chain',
	-- ['skeleton'] = 'chain',
	-- ['carrion'] = 'fire',
  ['steed.ice'] = 'fire',
  -- ['direwolf'] = 'fire',
  -- ['forlorn.ghost'] = 'elec',
  -- ['shadowspawn'] = 'elec',
  -- ['crystalline.dragon'] = 'cold',
  ['darion'] = 'kicker',
  ['grehild'] = 'kicker',
  -- ['orla.xana'] = 'fire',
  -- ['xana.guard'] = 'fire',
  -- ['variegated.limpet'] = 'fire',
  -- ['giant.python'] = 'cold',
  ['someone'] = 'cold',
}

probe.singleCastSpells = {
  sleep = true,
  probe = true,
}

-- currnetly supporting standard | sleep... maybe fear/para later
-- defaulting to sleep for my sanity 
probe.mode = probe.mode or 'sleep' 

probe.events = {
	MOB_PROBED = 'probe:completed_probe'
}

probe.db = db:create("probeDB",
  {
    mob = {
    name = "",
		dotName = "",
		pluralDotName = "",
    area_id = "",
    magic = 0,
    	fire = 0,
    	cold = 0,
    	elec = 0,
    	acid = 0,
			canSleep = 0,
			canFear = 0,
			canPara = 0,
      _index = { "name" },
      _unique = { "name" },
      _violations = "REPLACE"
    }
  }
)

probe.getMobData = function (mob) 

  local dbName = mob:lower()
  
  local dbEntry = db:fetch(
		probe.db.mob, 
		db:OR(
			db:eq(probe.db.mob.name, dbName),
			db:OR(
				db:eq(probe.db.mob.dotName, dbName),
				db:AND(
					db:not_eq(probe.db.mob.pluralDotName, ''),
					db:eq(probe.db.mob.pluralDotName, dbName)
				)
			)
		)
	)
  
  if (#dbEntry) then
    return dbEntry[1]
	else
		return nil
  end
  
end





probe.getBestElement = function (mobData)
	
	-- manual overrides
	if (probe.elementOverrides[mobData.dotName]) then
		return probe.elementOverrides[mobData.dotName]
	end
	
	-- if we're in sleep mode then our best option is to sleep!
	if (probe.enabledSpells.sleep and probe.mode == 'sleep' and mobData.canSleep == 1) then
		return 'sleeper'
	end
	

  local priority = { fire = 1, cold = 2, elec = 3, acid = 4 }
	
	local eleOrder = {"acid", "elec", "fire", "cold"}
	
	table.sort(eleOrder, function (a, b)
		
		local ra = mobData[a]
		local rb = mobData[b]
		local pa = priority[a]
		local pb = priority[b]
		
		return (ra &lt; rb or (ra == rb and pa &lt; pb))

	end)
  
  for k, v in ipairs(eleOrder) do
    if (probe.enabledSpells[v]) then
      
      if (v == 'elec' and (gmcp.Char.Status.position == 'swimming' or gmcp.Char.Status.position == 'drowning')) then
        cecho('\n\n&lt;red&gt;SPELL SELECT: &lt;white&gt;NOT USIING ELEC DUE TO SWIMMING!!!!\n\n')
      else
        return v
      end
      
    end
  end

end

-- in case algorithm changes...
probe.updateDBlongtNames = function()

  local res = db:fetch_sql(probe.db.mob, 
  	"select * from mob"
  )
  
	for k, v in pairs(res) do
		v.name = rex.gsub(v.name, [[[.]+$]], '')
		db:update(probe.db.mob, v)
	end
	
end

-- in case algorithm changes...
probe.updateDBshortNames = function()

  local res = db:fetch_sql(probe.db.mob, 
  	"select * from mob"
  )
  
	for k, v in pairs(res) do
		v.dotName = common.dotCase(common.toMurderString(v.name))
		db:update(probe.db.mob, v)
	end
	
end



-- if the mob has some fucked up name that doesn't shorten consistently
probe.setMobPluralDotName = function (mob, pluralDotName)
	
	local data = probe.getMobData(mob)
	
	if (data) then
		data.pluralDotName = pluralDotName
		db:update(probe.db.mob, data)
	else
		cecho('&lt;red&gt;PROBE: &lt;white&gt;failed to find mob to update dotname: ' .. mob)
	end

end

-- if the mob has some fucked up name that doesn't shorten consistently
probe.deleteMob = function (mob)
	
	local data = probe.getMobData(mob)
	
	if (data) then
		db:delete(probe.db.mob, data)
	else
		cecho('&lt;red&gt;PROBE: &lt;white&gt;failed to find mob to delete: ' .. mob)
	end

end

probe.lastMob = ''


probe.canSleep = function(mobString)
  
  common.dotCase(common.toMurderString('a.yeti'))
  local mob = common.dotCase(common.toMurderString(mobString)):lower()
  
  local mobData = probe.getMobData(mobString) or {}
  
  return mobData.canSleep

end
  

probe.castBestSpell = function (mobString) 
  
  probe.lastMob = common.dotCase(common.toMurderString(mobString)):lower()
  
  local mobData = probe.getMobData(probe.lastMob)
  
  if mobData then
  
    local element = probe.getBestElement(mobData)
    
    expandAlias(element)
  	
    send('+cast ' .. player.attack_spell .. ' ' .. probe.lastMob)
    
    if (probe.singleCastSpells[player.attack_spell] ~= true) then 
  	  send('cast ' .. player.attack_spell)
    end
    
  else
    
    -- we need to probe this mob and add it to the db still
    probe.spellSelect(mobString)
    
  end

end


probe.spellSelect = function (mobString, newMob)
  
  local dbName = common.dotCase(common.toMurderString(mobString)):lower()
  
  -- override mobString if we are currently in combat with a mob
  local mobs = table.keys(gmcp.Char.Fighting)
  if(#mobs &gt; 0) then
    dbName = common.cleanGmcpTarget(mobs[1]):lower()
    cecho('\n&lt;yellow&gt;SPELL SELECT: &lt;white&gt;using mobname from gmcp - '..common.cleanGmcpTarget(mobs[1]))
  end
  
  
  local attack = function (mobData)
  
  	local element = probe.getBestElement(mobData)
  	
  	if (player.attack_element ~= element) then
  		cecho('\n&lt;yellow&gt;SPELL SELECT: &lt;white&gt;changing to correct spell: ' .. element .. ' from ' .. player.attack_element)
  		send('+\n')
  		expandAlias(element)
  		send('cast ' .. player.attack_spell .. ' ' .. dbName)
      if (probe.singleCastSpells[player.attack_spell] ~= true) then 
  		  send('cast ' .. player.attack_spell)
      end
  	else
      if (newMob == true or probe.lastMob ~= dbName) then
        cecho('\n&lt;green&gt;SPELL SELECT: &lt;white&gt;already using correct spell for ' .. dbName)
        send('cast ' .. player.attack_spell .. ' ' .. dbName)
        if (probe.singleCastSpells[player.attack_spell] ~= true) then 
          send('cast ' .. player.attack_spell)
        end
      end
  	end
    
    probe.lastMob = dbName
  
  end
  
  
  local mobData = probe.getMobData(dbName)
  
  if (mobData and not probe.probePending) then
  	attack(mobData)
  else
  	if (not probe.probePending) then
      cecho('\n&lt;orange&gt;SPELL SELECT: &lt;white&gt;need to probe this mob... (' .. dbName .. ')')
    	send('+cast probe ' .. dbName)
    	probe.probePending = common.onNextEvent(probe.events.MOB_PROBED, function(evt, newMobData)
    		probe.probePending = nil
    		attack(newMobData)
    	end)
  		common.onNextEvent(tfe.events.ROOM_CHANGED, function (evt, args) 
  			cecho('\n&lt;orange&gt;SPELL SELECT: &lt;white&gt;failed to get probe of this mob... (' .. dbName .. ')')
        
        if (probe.probePending ~= nil) then
          probe.probePending()
          probe.probePending = nil
        end
     
  		end)
  	else
  		cecho('\n&lt;green&gt;SPELL SELECT: &lt;white&gt;waiting for probe of this mob... (' .. dbName .. ')')
  	end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>probe.combat_hit</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

local ignoreSpell = {
  ["sleep - asleep"] = true,
  ["sleep - deeper"] = true,
  ["sleep - Nothing"] = true,
}


probe.combat_hit = function(evt, attackData)
  
  if (attackData.damageType ~= 'proc') then
    -- display(gmcp.Char)
    if ((attackData.damageType == 'spell' and ignoreSpell[attackData.move])) then
      cecho('\n&lt;green&gt;[PROBE]: &lt;white&gt;Ignoring spell: ' .. attackData.move .. '\n')
    else
      -- display(attackData)
      probe.spellSelect(attackData.mob)
    end
    
  end

end</script>
					<eventHandlerList>
						<string>COMMON::combat_attack</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>probe.room_changed</name>
					<packageName></packageName>
					<script>
probe.room_changed = function ()
  
  if (player.sleepTarget ~= nil) then
    
    -- make sure this happens after any other things on room change
    tempTimer(0, function()
      probe.lastMob = player.sleepTarget
    end)
    
  else 
    probe.lastMob = ''
  end

end</script>
					<eventHandlerList>
						<string>tfe mapper: room found</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>njs50-paladin</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>prep / sleep / stand</name>
				<packageName></packageName>
				<script>player = player or {}
paladin = paladin or {}

paladin.count = function ()
  send('gstatus prepped ' .. tostring(healer.getPrepped()) .. ' ' .. healer.spell .. ', ' .. player.mp .. 'e' )
  if (healer.damageSpell) then
    local damPrepped = player.prepped[healer.damageSpell] or 0
    send('gstatus prepped ' .. tostring(damPrepped) .. ' ' .. healer.damageSpell)
  end
end

paladin.selectPrepSpell = function ()
  
end


paladin.prep = function (reserve_mp, callback)
	callback()
end


paladin.prepFull = function (callback)
  
  if (not player.gettingFull) then
  
    player.gettingFull = true
    -- in case we are interrupted and this isn't reset
    common.onNextEvent(tfe.events.ROOM_CHANGED, function()
      player.gettingFull = nil
    end)    
    
    healer.topOff(player.name, function()
    
    	paladin.getFull(function () 
      	player.gettingFull = nil    
    		send('gstat ready (' .. player.name .. ')')
    		paladin.count()
      	if (callback) then callback() end
  		end)
        
    end) -- and of top off
  
  else
    send('gstat already getting full...')
  end

end

paladin.useMedicant = function()
  if (player.mp_max - player.mp &gt; 200 and player.gear.hands.base.item == "medicant gauntlets") then
    send('rub gauntlet')
  end
end


paladin.prepFree = function (callback) 
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep free')
  njs50.respell(player.buffs, {
    target = 'gstat',
    callback = function()
    		send('gstat ready (' .. player.name .. ')')
    		paladin.count()
    		if (callback) then callback() end
    end
  })   
end

paladin.equipSleep = function (post_change_cmd, callback)
  
  send('dismount &amp; stand')
  -- send('gs')
  equipPartial('sleep', function () 
    player.sleepGear = true
    paladin.useMedicant()
    send('sit rug &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench &amp; sit chair &amp; sit mat &amp; sit boulder')
    send(post_change_cmd)
    if (callback) then 
      callback() 
    end
  end)
	
end


paladin.equipStand = function (callback)
  send('stand')  
  resetGear(function()
    player.sleepGear = false
    send('stand &amp; mount &amp; group')
    if (callback) then 
      callback() 
    end
  end)
end


paladin.getFull = function (callback)
  
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep full')
	
	local cb = callback or function() end
  
  local postRespellAttempt = function()

    local targetEn = gmcp.Char.Vitals.maxen
    local targetMv = gmcp.Char.Vitals.maxmv * 0.6
    
    if common.checkResources(gmcp.Char.Vitals.maxhp * 0.95, targetEn * 0.9, targetMv) then
      cecho('\n&lt;green&gt;PREP: &lt;white&gt;full enough already. skipping pfull\n') 
    		cb()
    		return
    	end

    	paladin.equipSleep('sleep', function ()
      
       
    		common.onFullish(gmcp.Char.Vitals.maxhp * 0.8, targetEn, targetMv, function () 
      		paladin.equipStand( function ()
          -- attempt respell again in case not enough mana before or wore off since then
          njs50.respell(player.buffs, {
            target = 'gstat',
            callback = cb,
            failCallback = cb,
          })   
      		end) -- end equip stand gear
    		end) -- end get full mana
    	end) -- end equip sleep gear		

  end
  
  
  njs50.respell(player.buffs, {
    target = 'gstat',
    callback = postRespellAttempt,
    failCallback = postRespellAttempt,
  }) 
  
	
end



paladin.prepStart = function (callback) 

end

paladin.prepEnd = function (callback) 

end

player.prepFull = paladin.prepFull</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>improves</name>
				<packageName></packageName>
				<script>paladin = paladin or {}

paladin.improveThings = {

  ['armor'] = { cmd = '|cast armor %t &amp; order all kill %t &amp; wait 10', level = 10},
  ['bless'] = { cmd = '|cast bless %t &amp; order all kill %t &amp; wait 10', level = 10},
  
  -- nb: these might require mobs to have a certain alignment
  ['holy wrath'] = { cmd = '|cast holy wrath %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},

  ['protection/evil'] = { cmd = '|cast protection/evil %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},
  ['protection/chaos'] = { cmd = '|cast protection/chaos %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},
}
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>njs50-druid</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>augmenting</name>
				<packageName></packageName>
				<script>druid = druid or {}

druid.augRooms = {
  jungle = 5821,
  beach = 5874,
  cave = 5860,
  forest = 5850,
  bamboo = 5837,
  tundra = 5817,
  desert = 5855,
  hills = 5801,
  field = 5802,
  swamp = 5803,
  mountain = 5800
}


druid.augRoom = 170

druid.augment = function(spell, terrain, target, cb, fcb)

  -- spell = ivy or vine (armor), vine = higher level

  local vnum = druid.augRooms[string.lower(terrain)]
  
  local startRoom
  
  if (gmcp.Room.Info.num == druid.augRoom) then
    if (vnum) then
    
      druid.landwalk(function()
        tfe.gotoRoom(vnum, function()
          common.onClear(function()
            
            njs50.cast(spell .. ' armor', {
              target = target,
              callback = function()
                tfe.gotoRoom(druid.augRoom, cb)
              end,
              failCallback = function()
                tfe.gotoRoom(druid.augRoom, fcb)
              end,
            })
            
          end)
        end)
      end)
      
    else
      return fcb('invalid terrain ' .. terrain)
    end
  else
    return fcb('only augmenting from med xroads')
  end


end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>druid junk</name>
				<packageName></packageName>
				<script>druid = druid or {}

druid.skipXerotes = {
  gale = true,
  ["strong gale"] = true,
  storm = true,
  ["violent storm"] = true,
  hurricane = true,
}

druid.landwalk = function(cb)
    
  local landwalkTerrains = {
    ['47'] = "Dark Bamboo",
    ['42'] = "Bamboo Forest",
    ['53'] = "Forest",
    ['56'] = "Jungle",
    ['25'] = "Rainforest",
    ['35'] = "Tundra",
    ['52'] = "Field",
    ['43'] = "Beach",
    ['48'] = "Desert",
    ['45'] = "Cave",
    ['55'] = "Hills",
    ['20'] = "Mountain",
    ['31'] = "Swamp",
    
    -- ffs. random terrains
    ['100'] = "Sandy Cavern",
  }
  
  
  -- start with current room
  local checkRooms = {
    { vnum = gmcp.Room.Info.num, cost = 0, terrain = landwalkTerrains[tostring(getRoomEnv(gmcp.Room.Info.num))] }
  }
  
  local checkedRooms = {}
  checkedRooms[tostring(gmcp.Room.Info.num)] = true
  
  local foundWays = {}
  if (checkRooms[1].terrain) then
    table.insert(foundWays, checkRooms[1])
  end
  
  
  local getAdjacentRooms = function(rooms, checkedRooms, foundWays)
    
    local newRooms = {}
    
    for i,room in pairs(rooms) do
      
      for exitDir, newVnum in pairs(getRoomExits(room.vnum)) do
      
        if (not checkedRooms[tostring(newVnum)]) then
          
          checkedRooms[tostring(newVnum)] = true
          
          -- if this room is locked then we need to ignore it
          if (not roomLocked(newVnum)) then
          
            local thisRoom = {
              vnum = newVnum, 
              cost = room.cost + getRoomWeight(newVnum), 
              terrain = landwalkTerrains[tostring(getRoomEnv(newVnum))],
            }
            table.insert(newRooms, thisRoom)
            if (thisRoom.terrain) then
              table.insert(foundWays, thisRoom)
            end
            
          end
        end
      
      end
      
    end
    
    return newRooms, checkedRooms, foundWays
  
  end
  
  local room_count = 0;
  
  while (#foundWays == 0 and room_count &lt; 100) do
    room_count = room_count + 1
    checkRooms, checkedRooms, foundWays  = getAdjacentRooms(checkRooms, checkedRooms, foundWays)
  end
  -- 
  -- display(checkRooms, checkedRooms, foundWays, room_count)
  -- cecho('\n\n----\n\n')
  
  table.sort(foundWays, function(a,b) return a.cost &lt; b.cost end)
  
  if (#foundWays &gt; 0) then
    
    cecho('\n\n&lt;green&gt;MAPPER:&lt;white&gt; closest landwalk terrain is ' .. tostring(room_count) .. ' rooms away\n')
  
    common.getAffects( function (affects)
    
      local clw = function()
        -- murder.groupDoAck('cast landwalk', function() 
          njs50.cast('landwalk', {
            callback = function()
              -- for some reason the room hasn't updated for a while after the spell is cast
              -- waiting for a room change if we aren't in the ways already
 
              -- wait for the room to change
              njs50.tempTimedNextEventAnyway(10, tfe.events.ROOM_CHANGED, function (evt, args)
                if (cb) then cb() end
              end)              


            end
          })        
        -- end)
      end
      
      local clb = function()
 
         if (not affects["You are able to bind lands together."]) then
          -- murder.groupDoAck('cast landwalk', function() 
            njs50.cast('landbinding', { callback = clw })
          -- end)
        else
          clw()
        end     
      
      end
    
      if (gmcp.Room.Info.num == foundWays[1].vnum) then
        clb()
      else
        tfe.gotoRoom(foundWays[1].vnum, clb)
      end

    end)  
  
  else
    cecho('\n\n&lt;red&gt;MAPPER:&lt;white&gt;; no path found to landwalkable terrain\n')
  end

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>storm-state</name>
				<packageName></packageName>
				<script>farmer.afterCommonLoaded(function ()
  
  player = player or {}
  player.ss = player.ss or {}

  player.ss.events = player.ss.events or {}
  player.ss.events.STORM_ENDED = 'druid: storm ended'

  
  if (player.ss.roomChangeWatch) then
    killAnonymousEventHandler(player.ss.roomChangeWatch)
    player.ss.roomChangeWatch = nil
  end
  
  player.ss.roomChangeWatch = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, function ()
    if player.stormEnabled then
      cecho('\n&lt;green&gt;storm state:&lt;white&gt; room change #' .. tostring(gmcp.Room.Info.num))
      for spell, count in pairs(player.prepped) do
        cecho(', ' .. spell .. ': ' .. tostring(count) .. ' ') 
      end
      
  
      
      player.ss.storm_active = nil
      
      if (player.ss.move_cast) then
        cecho(', storm pre-cast')
        player.ss.casting = true
        player.ss.move_cast  = nil
      else
        player.ss.casting = nil
      end      
      
      cecho('\n')
      
    end
  end)
  
  
  player.ss.onStormDone = function(cb)
    
    if (not player.ss.storm_active and not player.ss.casting) then
      cb()
    else
      common.onNextEvent(player.ss.events.STORM_ENDED, cb)
    end
    
  end

  player.ss.cast = function(clearQueue)
    
    if player.stormEnabled then
    
      local abortTrig, abortedPrep
      
      if (clearQueue) then
            
        abortTrig = tempRegexTrigger([[^You abort preparing (.+)\.$]], function()
          abortedPrep = matches[2]
          cecho(' &lt;green&gt;&lt;--- aborted cast. recast on clear\n')
        end)
      
        player.ss.casting = nil
        player.ss.storm_active = false
        send('+') 
      end
    
    
      if (player.ss.storm_active) then
        cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm already active, not recasting\n')
        return false
      end
      
      if (player.ss.casting) then
        cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm already being cast, not recasting\n')
        return false
      end
    
      player.ss.casting = true
      
      njs50.cast(player.stormSpell, {
        callback = function()
          cecho('\n&lt;green&gt;storm state:&lt;white&gt; cast storm spell\n')
          player.ss.casting = nil
          player.ss.storm_active = true 
          
          if (clearQueue) then
            if (abortTrig) then killTrigger(abortTrig) end
            if (abortedPrep) then
              common.onClear(function()
                send('prepare ' .. abortedPrep)
              end)
            end
          end     
        end,
        failCallback = function()
          cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm spell disrupted\n')
          if (abortTrig) then killTrigger(abortTrig) end
          -- if it was disrupted due to room change don't auto recast
          player.ss.casting = nil     
        end
      })
  
      return true
    end
  
  end
  
  cecho('\n&lt;green&gt;storm state:&lt;white&gt; loaded\n')

end)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>repop check</name>
				<packageName></packageName>
				<script>druid = druid or {}

-- A silver coin lies here, forgotten.
 
druid.waysRepopCheckCoin = function(direction, cb)
  common.checkRepopByDrop(direction, [[^\S+ \w+ coins? lies?]], cb)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>prep etc</name>
				<packageName></packageName>
				<script>druid = druid or {}

druid.reportMana = function ()
	local pdata = group.data[player.name]
  local manaPct = math.ceil((pdata.mp / pdata.mp_max * 100))
  local cmd = 'mana at ' .. tostring(manaPct) .. '%'
  if (player.stormSpell and player.stormSpell ~= '') then
    local ct = player.prepped[player.stormSpell] or 0
    cmd = cmd .. ', ' .. tostring(ct) .. ' ' .. player.stormSpell
  end
  
  if (group.memberCount == 1) then
    cecho('&lt;green&gt;STATUS:&lt;white&gt; ' .. cmd .. '\n')
  else
    send('gstat ' .. cmd)
  end
  
end



druid.prepFree = function(cb)
  
  if (player.gear.nearby and 
      player.gear.nearby.base and 
      player.gear.nearby.base.item == "obstruction of darkflies") then
      common.getManaAndCast(25, 'darkflies', '', true)
  end

      
  njs50.respell(player.buffs, {
    target = 'gstat',
    callback = function()
      
      -- player.prepStormAmount = 6
      -- player.minPreppedStormSpells = 3
      -- 
      -- player.stormSpellReserveAmount = 190      
      local prepped = (player.prepped[player.stormSpell] or 0)
      local available = math.min(prepped + common.getPrepAmount(player.stormSpellReserveAmount, player.reserveMana), player.prepStormAmount)
    
      common.prep(player.stormSpell, available, function()
        if (player.skills.xerotes and player.skills.xerotes &gt;= 10 and not druid.skipXerotes[gmcp.Room.Info.wind]) then
          njs50.cast('xerotes', {
            callback = function ()
              druid.reportMana()
              if (cb) then cb() end
            end
          })        
        else
         	tempTimer(3, function ()
            druid.reportMana()
            if (cb) then cb() end
        		end, 'reporting mana')      
        end

      end)   
    end
  })     

end




druid.getFull = function (callback)

  if (not (player.gettingFull and player.position == 'sleeping')) then 
    player.gettingFull = true
    
    if (player.healSpell and (group.data[player.name].hp_max - group.data[player.name].hp) &gt; 125) then
      send('cast ' .. player.healSpell)
    end

    expandAlias('ef &amp; dw &amp; remove ' .. player.pack)
    
    druid.rest('sleep', function () 
      
      common.onFull( function ()
        druid.stand( function () 
          
          druid.prepFree(function ()
          
            player.gettingFull = nil
            -- expandAlias('gstat ready (' .. player.name .. ')')
            -- druid.reportMana()
            
            if (callback) then callback() end
            
          end)
        
        end)
        
      end)
    
    end)
  
  else	
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
  end
	
end  



druid.rest = function (cmd, callback) 
	
	send('stand &amp; remove ' .. player.pack)
	
	equipPartial('sleep', function ()
    send('hide &amp; sit rug &amp; sit mat &amp; sit chair &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench &amp; sit boulder')
		send(cmd)
		if (callback ~= nil) then callback() end
	end)

end


druid.stand = function (callback)

	send('stand &amp; remove blanket &amp; gs &amp; put blanket ' .. player.pack)
	resetGear(function () 
		-- send('ps')
		if (callback ~= nil) then callback() end
	end)
  	
end





druid.stormStepAction = function(cb, options)
  
  options = options or {}
  
  options.skipHealAmount = options.skipHealAmount or 300
  options.sleepForMana = options.sleepForMana or false
    
  player.postStormCheck(cb, options)
  
end
  
 
player.postStormCheck = function(cb, options)

  player.sscb = player.sscb or {}

  if cb and not table.contains(player.sscb, cb) then
    table.insert(player.sscb, cb)
  end

  local execCallback = function()
    player.sscb = player.sscb or {}
    player.pendingPostStormCheck = nil
    for idx, fn in ipairs(player.sscb) do
      fn()
    end
    player.sscb = nil    
  end

  if (player.pendingPostStormCheck ~= nil) then  
    cecho('\n\n&lt;red&gt;PREP:&lt;white&gt; post storm check is already pending\n') 
    return
  end
  player.pendingPostStormCheck = true
  

  options = options or {}
  
  options.skipHealAmount = options.skipHealAmount or 250
  
  
  options.sleepForMana = options.sleepForMana or false
  
  cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; beginning post storm check\n') 
    
  player.prepped[player.stormSpell] = player.prepped[player.stormSpell] or 0  
    
  druid.makeItRain({ 
    skipAmount = options.skipHealAmount, 
    whileWaiting = function(cb2)
      
      player.prepped[player.stormSpell] = player.prepped[player.stormSpell] or 0

      local prepAmount = math.floor((player.mp - player.reserveMana) / player.stormSpellReserveAmount)
      
      prepAmount = math.min(prepAmount, player.prepStormAmount - player.prepped[player.stormSpell])
      
      if (prepAmount == 0) then 
        cb2()
      else
        common.prep(player.stormSpell, player.prepped[player.stormSpell] + prepAmount, cb2)
      end
      
    
    end,
    callback = function() 

      njs50.respell(player.buffs, {
        target = target, 
        failCallback = function()
          cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; post storm respell failed, trying again in 10\n')
          tempTimer(10, function()
            player.pendingPostStormCheck = nil
            return player.postStormCheck(nil, options)
          end)
        end,
        callback = function()
     

          if ((player.mp &gt; (player.reserveMana + player.stormSpellReserveAmount)) and
            (player.prepped[player.stormSpell] &lt; player.minPreppedStormSpells)
          ) then
            
            player.prepped[player.stormSpell] = player.prepped[player.stormSpell] or 0
          
            -- mana is available to prep, prep 1
            common.prep(player.stormSpell, player.prepped[player.stormSpell] + 1, function()
            
              if player.prepped[player.stormSpell] &lt; player.minPreppedStormSpells then
                
                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; prepping another in 5\n') 
                player.pendingPostStormCheck = nil
                return player.postStormCheck(nil, options)
                
              else  
                
                player.pendingPostStormCheck = nil
                druid.reportMana()
                execCallback()  
                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; ready to roll\n') 
                    
                
              end
      
            end)
          
          else
          
          
          
            if (gmcp.Char.Vitals.maxen &lt; player.reserveMana) then
            
              -- this is not good, but will prob resolve itself as soon as we cast a prepped thing
              cecho('\n\n&lt;orange&gt;PREP:&lt;white&gt; over prepared (not enough reserved) -- ignoring\n') 
              execCallback()    
            
              -- got enough prepped / free          
            elseif (player.mp &gt; player.reserveMana and 
              player.prepped[player.stormSpell] and
              player.prepped[player.stormSpell] &gt;= player.minPreppedStormSpells) then
              
              cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; ready to roll\n') 
              execCallback()    
              
            else
            
              -- need to get some more juice
              
        


              if (options.sleepForMana and (gmcp.Char.Vitals.maxen - gmcp.Char.Vitals.en) &gt; 120 ) then
              
                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; getting full mana (once any storms end)\n')
                player.ss.onStormDone(function()
                  druid.getFull(function()
                    execCallback()
                  end)
                end)
              
              else
              
                -- required mana for min spells
                -- local spellsNeeded = (player.minPreppedStormSpells - (player.prepped[player.stormSpell] or 0))
                -- local reqMana = player.stormSpellCost * spellsNeeded + player.reserveMana
                -- cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; waiting for mana to regen for ' .. tostring(spellsNeeded) .. ' storm spells\n')

                -- if (gmcp.Char.Vitals.en &gt; reqMana) then
                  -- druid.prepFree(cb)
                -- end

                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; waiting for mana to regen (15s)\n')
                tempTimer(15, function()
                  player.pendingPostStormCheck = nil
                  return player.postStormCheck(nil, options)
                end, 'waiting on mana for post-storm-check')
                
              end
            
            end
            
          
          end
          
         
        end
      }) 
      
      
    end
  })
  
  


end



-- these seem to be  refrenced randomly all over the show...
-- player.prepFull = druid.getFull
-- player.getFull = druid.getFull
-- player.prepStorms = player.prepStorms or 'none'
-- player.prepFree = druid.prepFree</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>healing</name>
				<packageName></packageName>
				<script>druid = druid or {}

druid.healState = druid.healState or {}

druid.healState.events = druid.healState.events or {}

druid.healState.events.HEAL_STARTED = 'druid: heal started'
druid.healState.events.HEAL_ENDED = 'druid: heal ended'


druid.onHealEnd = function(cb)

  local rewatch, gwatch
  
  -- watch for the rain/mist to run out
  rewatch = registerAnonymousEventHandler(druid.healState.events.HEAL_ENDED, function ()
    killAnonymousEventHandler(rewatch)
    killAnonymousEventHandler(gwatch)
    cb()
  end, true)
  
  -- watch for the group to be full?
  gwatch = registerAnonymousEventHandler(common.events.PARSED_GMCP_GROUP, function()

    local healingDone = true
    
    for name in pairs(group.members) do 
      -- display(name, group[name].hp_max - group[name].hp)
      -- require at least 60% hp
      if (
        ((group.data[name].hp_max - group.data[name].hp) &gt; 0) 
      ) then
        healingDone = false
        cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; ' .. name .. ' is ' .. tostring(group.data[name].hp) .. ' of ' .. tostring(group.data[name].hp_max) .. 'hp!\n')
      end

    end  
    
    if (healingDone) then
      killAnonymousEventHandler(rewatch)
      killAnonymousEventHandler(gwatch)
      cb()        
    end
    
  end)
  
  
end


druid.castHeal = function(options)
  
  options = options or {}
  
  local resolveCallbacks = function()
  
    local waitingDone = true
    local rainDone = false
    
    if (options.whileWaiting) then
      waitingDone = false
      options.whileWaiting(function()
        waitingDone = true
        if (rainDone and options.callback) then
          options.callback()
        end
      end)
      
    end   
   
    druid.onHealEnd(function()
      cecho('\n&lt;green&gt;DRUID:&lt;white&gt; ' .. player.healSpell .. ' ended!\n\n')
      if (options.callback and waitingDone) then 
        options.callback()
      else
        rainDone = true
      end    
    end)  
    
  end


  -- skip if we already have one queued / in progress
  if (druid.healState.casting or druid.healState.healing) then
    cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; attempted to heal while heal already in progress\n')
    resolveCallbacks()
    return
  end

  local retry = function ()  
    tempTimer(10, function()
      druid.castHeal(options)
    end, 'healing retry')
  end

  if (player.healSpellCost &gt; player.mp) then
    
    cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; not enough mana for ' .. player.healSpell .. ', waiting 10s\n')
    retry()
  
  else
  
    druid.healState.casting = true
    
    njs50.cast(player.healSpell, {
      callback = function()
        resolveCallbacks()
      end,
      failCallback = function(reason)
      -- display(reason, 'wtf')
        if (reason == 'cast failed due to combat') then
          if (options.cancelOnCombat) then
            cecho('\n&lt;green&gt;DRUID:&lt;white&gt; failed to cast ' .. player.healSpell .. ' due to combat, skipping\n')
          else
            cecho('\n&lt;red&gt;DRUID:&lt;white&gt; failed to cast ' .. player.healSpell .. ', trying again after combat\n')
            common.onNextEvent(common.events.COMBAT_ENDED, function()
              druid.castHeal(options)
            end)
          end
       else
          cecho('\n&lt;red&gt;DRUID:&lt;white&gt; failed to cast ' .. player.healSpell .. ', trying again in 5s\n')
          retry()
        end
      end
    
    })
  end
end

druid.healCastStart = function()
  cecho('&lt;green&gt; &lt;-- heal casting\n')
  druid.healState.casting = true
end

druid.healStarted = function()
  cecho('&lt;green&gt; &lt;-- heal started\n')
  druid.healState.casting = nil
  druid.healState.healing = true
  raiseEvent(druid.healState.events.HEAL_STARTED)
  
  -- stop waiting for the end if we change rooms (or if 30 seconds past)
  druid.healState.rcWatch = njs50.tempTimedNextEventAnyway(20, tfe.events.ROOM_CHANGED, function ()
    cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; room changed or 20s passed without healing rain finishing!\n')
    druid.healState.rcWatch = nil
    raiseEvent(druid.healState.events.HEAL_ENDED)
  end)  
  
end

druid.healEnded = function()
  cecho('&lt;green&gt; &lt;-- heal ended\n')
  druid.healState.healing = nil
  raiseEvent(druid.healState.events.HEAL_ENDED)
  
  -- kill the room change (or timeout) watcher if it still exits
  if (druid.healState.rcWatch) then
    druid.healState.rcWatch()
    druid.healState.rcWatch = nil
  end
end

druid.healInterrupted = function()
  cecho('&lt;green&gt; &lt;-- heal interrupted\n')
  druid.healState.casting = nil
end

druid.healCombatFail = function()
  cecho('&lt;green&gt; &lt;-- heal failed (combat)\n')
  druid.healState.casting = nil
end


-- add some event watchers

if (druid.healState.roomChangeWatch) then
  killAnonymousEventHandler(druid.healState.roomChangeWatch)
  druid.healState.roomChangeWatch = nil
end

druid.healState.roomChangeWatch = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, function ()
  druid.healState.casting = nil
  druid.healState.healing = nil
end)


druid.makeItRain = function(options)

  options = options or {}

  if (options.skipAmount) then
    
    local canSkip = true
    
    for name in pairs(group.members) do 
      -- display(name, group[name].hp_max - group[name].hp)
      -- require at least 60% hp
      if (
        ((group.data[name].hp_max - group.data[name].hp) &gt; options.skipAmount) or
        (group.data[name].hp / group.data[name].hp_max &lt; 0.6)
      ) then
        canSkip = false
      end
      cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; ' .. name .. ' is ' .. tostring(group.data[name].hp) .. ' of ' .. tostring(group.data[name].hp_max) .. 'hp!\n')
    end
    
    if (canSkip) then
      cecho('\n&lt;green&gt;DRUID:&lt;white&gt; healthy enough to skip ' .. player.healSpell .. '!\n')
      if (options.callback) then options.callback() end
      return
    end
    
  end
  
  druid.castHeal(options)


end


druid.healGroup = function(options)

  options = options or {}
  
  options.skipAmount = options.skipAmount or 100
  options.callback = options.callback or function() end
  
  canSkip = true
  
  local groupHpMissing = 0

  for name in pairs(group.members) do 
    
    local missingHp = group.data[name].hp_max - group.data[name].hp
  
    groupHpMissing = groupHpMissing + missingHp
  
    if (
      (missingHp &gt; options.skipAmount) or
      (group.data[name].hp / group.data[name].hp_max &lt; 0.6)
    ) then
      canSkip = false
    end
    cecho('&lt;orange&gt;DRUID:&lt;white&gt; ' .. name .. ' is ' .. tostring(group.data[name].hp) .. ' of ' .. tostring(group.data[name].hp_max) .. 'hp!\n')
  end
  
  if groupHpMissing &gt; options.skipAmount then
    canSkip = false
  end
  cecho('&lt;orange&gt;DRUID:&lt;white&gt; group is missing ' .. tostring(groupHpMissing) .. 'hp!\n')

  -- going to keep casting heals til we can skip healing
  if not canSkip then
    druid.castHeal({callback = function()
      druid.healGroup(options)
    end})  
  else
    options.callback()
  end
  -- 


end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>mojune.player.config</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}
player.scripts = player.scripts or {}

-- nb: must match exactly. i.e don't forget the capital letter
player.scripts.DefaultDruid = function ()

  player.bag = 'snatch'
  player.pack = 'ReturnToMojune'
  player.reagentBag = 'ReturnToMojune'
  player.gearSet = 'default'
  player.vessel = 'slick.green.waterskin'
  player.caster = false
  player.hasFoodBasket = true
  
  player.getAttackCommand = function(target)
    return 'kill ' .. target
  end
  
  player.autoAttack = function(target)
    send(player.getAttackCommand(target))
  end 
  

  player.keepInPack = {
    ["a spotted cheetah skin"] = true,
    ["a shadowy rod"] = true,
    ["a feather-tipped rod"] = true,
    ["a pearl"] = true,
    ["a feathered talisman"] = true,
    ["a multicoloured belt of the elements"] = true,
    ["a cottonwood rod of presage"] = true,
    ["a dowsing stick"] = true,
    ["a soft, snow-white bear skin"] = true,
    ["a shadowbox"] = true,
    ["a sloth claw"] = true,
  }

  player.buffs = {
    -- ['embrace of shades'] = 'You are embraced by shadows.',
    -- puissance = 'Your metabolic reactions are quickened.',
    -- quickening = 'Your movements are hastened.',
    -- barrier = 'You feel strong against the elements.',
    -- hardiness = 'You are very hardy.',
    -- barkskin = 'Your flesh is hardened.',
  }   

end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>improves</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>improves</name>
					<packageName></packageName>
					<script>druid = druid or {}

druid.improveNonCombat = function(cb)
  
  cb = cb or function() end
  
  local hpItem = 'serp.ring'
  local bandage = 'a simple bandage'
  
  local improveThings = {
    
    -- this one is a bit shit because you can't keep doing it in the same room
    -- dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant', level = 7},
    
    bandage = { bandage = true, cmd = 'bandage self', reagent = 'a simple bandage', level = 10 },
    compress = { bandage = true, cmd = 'compress self', reagent = 'a clump of herbs', level = 10 },
    poultice = { bandage = true, cmd = 'poultice self', reagent = 'a thick aloe leaf', level = 10 },
    salve = { bandage = true, cmd = 'poultice self', level = 7 },
    ['healing mist'] = { heal = true, cmd = 'cast healing mist', level = 10 },
    ['healing rain'] = { heal = true, cmd = 'cast healing rain', level = 10 },
    
    impede = { cmd = 'cast impede', level = 10},
    
    fireflies = { cmd = 'remove gold.ball &amp; | cast fireflies &amp; | remove fireflies &amp; | wear gold.ball', level = 10},
    
    squall = { cmd = 'prep squall &amp; |cast squall', level = 10},
    storm = { cmd = 'prep storm &amp; |cast storm', level = 10},
    blizzard = { cmd = 'prep blizzard &amp; |cast blizzard', level = 7},
    tornado = { cmd = 'prep tornado &amp; |cast tornado', level = 10},
    tempest = { cmd = 'prep tempest &amp; |cast tempest', level = 10},
    
    anemogenesis = { cmd = 'cast anemogenesis', level = 10},
    xerotes = { cmd = 'cast xerotes', level = 10},
    
    darklight = { cmd = 'remove gold.ball &amp; cast darklight &amp; |remove darklight &amp; |wear gold.ball', level = 7},
    
  }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      
      if (data.bandage) then
  
        common.getReagents(data.reagent, 1, function()
          common.getReagents(bandage, 1, function()
            send('|remove ' .. hpItem .. ' &amp; |wear ' .. hpItem .. ' &amp; |sit')
            send('|' .. data.cmd .. ' &amp; |wait 4 &amp; |stand')
            cb()
          end, function()
            cecho('\n\nOut of ' .. bandage .. '!!!\n\n')
          end)
        end, function()
          cecho('\n\nOut of ' .. data.reagent .. '!!!\n\n')
        end)
  
      elseif (data.heal) then
  
        send('|remove ' .. hpItem .. ' &amp; |wear ' .. hpItem .. ' &amp; |' .. data.cmd)
        cb()
      
      else
        send('|' .. data.cmd)
        cb()
      end
  
      player.lastImproveSkill = thing
      
      
      return
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    druid.improveNonCombat(cb)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    cb()
  end
  
end

druid.improveCombat = function(target)
  
  cb = cb or function() end
  
  druid.improveThings = druid.improveThings or {
    
    -- need to keep moving while doing this. bleh
    dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant &amp; |cast gale', level = 7},
    
    -- darkness
    nocturne = { cmd = 'cast nocturne', level = 7},
    gloom = { cmd = 'cast gloom', level = 10},
    shadowstrike = { cmd = 'cast shadowstrike', level = 7},
    ['veil of darkness'] = { cmd = 'cast veil of darkness', level = 10},
    
    -- for healing
    ['aqueous surge'] = { cmd = 'cast aqueous surge', level = 7},
    ['aqueous spirit'] = { cmd = 'cast aqueous spirit', level = 7},
    
    -- wind
    gust = { cmd = 'cast gust', level = 7},
    ['wind shear'] = { cmd = 'cast wind shear', level = 7},
    gale = { cmd = 'cast gale', level = 10},
    whirlwind = { cmd = 'cast whirlwind', level = 10},
    
    -- storm (optional)
    -- squall = { cmd = 'prep squall &amp; |cast squall &amp; |look', level = 10},
    -- storm = { cmd = 'prep storm &amp; |cast storm &amp; |look', level = 10},
    -- blizzard = { cmd = 'prep blizzard &amp; |cast blizzard &amp; |look', level = 7},
    -- tornado = { cmd = 'prep tornado &amp; |cast tornado &amp; |look', level = 7},
    -- tempest = { cmd = 'prep tempest &amp; |cast tempest &amp; |look', level = 10},
    
    
    -- util
    undergrowth = { cmd = 'cast undergrowth', level = 10},
    
    -- drying (for xerotes)
    dry = { cmd = 'cast dry', level = 10},
    parch = { cmd = 'cast parch', level = 7},
    desiccate = { cmd = 'cast desiccate', level = 7},
    
    -- aoe (optional)
    -- blizzard = { cmd = 'prep blizzard &amp; |cast blizzard &amp; |sigh', level = 7},
    
  }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(druid.improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      player.lastImproveSkill = thing
      
      return data.cmd .. ' ' .. target
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    return druid.improveCombat(target)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    return ''
  end
  
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>defer loading farmer scripts</name>
					<packageName></packageName>
					<script>farmer = farmer or {}

farmer.afterCommonLoaded = function(cb)

  if (not farmer.configure) then
    registerAnonymousEventHandler('njs50SharedLoaded', cb, true)
  else
    cb()
  end
  
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>spell-improve-path</name>
					<packageName></packageName>
					<script>
farmer.afterCommonLoaded(function ()

  
  local targets = {
    ["wild-eyed.goblin"] = true,
    ["small.homonculou"] = true,
    ["large.slug"] = true,
    ["tunnel.worm"] = true,
    ["small.homonculi"] = true,
    ["small.homoncul"] = true,
    ["screech.bat"] = true,
    ["tiny.black.ooze"] = true,
    ["massive.slug"] = true,
    ["giant.black.beetle"] = true
  }
  
  
  local getImproveCommand = function(exit)
    
    if (improves.sawAction) then
      cecho('\n&lt;green&gt;IMPS:&lt;white&gt; waiting for action timer to cool down\n')
      return ''
    end
    
    
    if (exit and exit.firstTarget) then
        return improves.getImproveSpell() .. ' ' .. exit.firstTarget
    else
    	return ''
    end
    
  end
  
  -- set the names of targets to murder
  local steps = { 
  	
  	{ 
  		location = 20041, 
  		action = function (cb) 
        improves.sawAction = false
        -- send('alias *k ' .. improves.getImproveSpell())
        cb()
  		end 
  	},
  	
  	{ 
  		targets = targets,
    getKillCommand = getImproveCommand,  
  		waypoints = {20053, 20056, 37504, 37611, 37613, 37597, 37591, 37596, 37504, 20041}, --   at start to lengthen
      stepAction = function(cb)
        
        cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;step action!!! \n')
        
        if (improves.sawAction) then
          cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;recovering from exciting action!!!!\n')
          -- send('alias *k ' .. improves.getImproveSpell())
          tempTimer(3, function()
            expandAlias('sl')
          end, 'sleeping')
          
          tempTimer(44, function ()
            expandAlias('st')
            cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;recovered. moving!!!!\n')
            improves.sawAction = false
            -- send('alias *k ' .. improves.getImproveSpell())
            send('scan')
            tempTimer(3, cb, 'improving')
          
          end, 'action recovery')
        else
          cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;no action on this step :-[\n')
          tempTimer(0.25, function()
            cb()
          end)
        end
        
      end,
      action = function(cb)
        -- don't go to town until after any squalls etc have stopped...
        tempTimer(5, cb)
      end
  	},
    { 
      location = "20062",
      action = "buy all.tobacco"
    },
    { 
      location = "20027",
      action = "dep all.tobacco"
    },
    { 
      location = "20082",
      action = "drink soup &amp; drink soup &amp; drink soup &amp; drink soup"
    },
    { 
      location = "20001",
      action = "fill empty.slick"
    },
    { 
  		location = "20041", 
      action = player.getFull
    },
    
  }
  
  	
  local completeCallback = function ()
  	echo('spell imps is done...')
  	-- farmer.restart()
    tempTimer(10, farmer.restart)
  end
  		
  farmer.configure('spell.imps', steps, completeCallback, dropJunk)
  

end)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>trog.imps</name>
					<packageName></packageName>
					<script>farmer.afterCommonLoaded(function ()


local getImproveCommand = function(exit)
  
  if (improves.sawAction) then
  
    cecho('\n&lt;green&gt;IMPS:&lt;white&gt; waiting for action timer to cool down\n')
    
    if (gmcp.Char.Status.position ~= 'sleeping') then
      send('sleep')
      murder.hold()
      
      tempTimer(math.max(improves.releaseAt - getEpoch(), 0), function()
        send('stand')
        murder.unhold()
      end, 'mana regen')
    end
    
    return ''
  end
  
  
  if (exit and exit.firstTarget) then
      return improves.improveCombat(druid.improveThings, exit.firstTarget)
  else
  	 return ''
  end
  
end

local options = {

  longName = 'trog.imps',

  targets = {
    ["small.brown.troglodyte"] = 1,
    ["small.brown.troglodyt"] = 1,
    ["sallow-skinned.troglodyte"] = 1,
    ["sallow-skinned.troglodyt"] = 1,
  },

  onStopByTrigger = function ()
    send('stop was commanded - begin self destruct sequence')
  end,
  
  getKillCommand = getImproveCommand,  

}




local steps = {

  {
    waypoints = {19348}, -- repop
    action = function (cb)
      send('group -l ' .. player.name)
      improves.sawAction = false
      njs50bot.sleepUntilFull(function ()
        common.checkRepopByDrop(49250, [[^\S+ \w+ coins? lies?]], cb, 5)
      end)
    end,
  },
  
  {
    waypoints = {49250}, -- repop check room
    action = "drop silver.coin"
  },
  
  { 
    waypoints = {49296},
    
    action = "drink &amp; drink &amp; drink",
  },

  {
    waypoints = {49295, 49267, 49272, 49278, 49279, 49287, 49288, 49284, 49281, 49282, 49291, 49290, 49285}, -- path
  },

  {
    waypoints = {19348}, -- repop
  },


}

local completeCallback = function ()
  send('gstat trog.imps is done...')
  farmer.restart()
end

farmer.configure('trog.imps', steps, completeCallback, options)

end)


</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>beach.imps</name>
					<packageName></packageName>
					<script>farmer.afterCommonLoaded(function ()


local getImproveCommand = function(exit)
  
  if (improves.sawAction) then
  
    cecho('\n&lt;green&gt;IMPS:&lt;white&gt; waiting for action timer to cool down\n')
    
    if (gmcp.Char.Status.position ~= 'sleeping') then
      send('sleep')
      murder.hold()
      
      tempTimer(math.max(improves.releaseAt - getEpoch(), 0), function()
        send('stand')
        murder.unhold()
      end, 'mana regen')
    end
    
    return ''
  end
  
  
  if (exit and exit.firstTarget) then
      return improves.improveCombat(druid.improveThings, exit.firstTarget)
  else
  	 return ''
  end
  
end

local options = {

  longName = 'beach.imps',

  targets = {
    ["sea.gull"] = 1,
    ["small.green.crab"] = 1,
    ["large.fish"] = 1,
    ["lobster"] = 1,
    ["pelican"] = 1,
  },

  getKillCommand = getImproveCommand,

  onStopByTrigger = function ()
    send('stop was commanded - begin self destruct sequence')
  end,

}

local steps = {

  {
    waypoints = {21039}, -- repop
    action = function (cb)

      njs50bot.sleepUntilFull(function()
        improves.sawAction = nil
        common.checkRepopByDrop(22000, [[^\S+ \w+ coins? lies?]], cb, 5)
      end)
      
    end,
  },
  { 
    waypoints = { 22000 },
    action = "drop silver.coin"
  },
  {
    waypoints = {22040, 22009, 22030, 22033, 22002, 22000, 22031}
  },

  {
    waypoints = {21039}, -- repop
  },

}

local completeCallback = function ()
  send('gstat beach.imps is done...')
  expandAlias('sort beach.imps junk')
  tempTimer(5, function ()
    farmer.restart()
  end)
end

farmer.configure('beach.imps', steps, completeCallback, options)

end)</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>druid commands / auto_assist</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>druid commands</name>
					<packageName></packageName>
					<script>druid = druid or {}


druid.getSpells = function()

  local offensiveSpells = {
    undergrowth = true,  
    ['veil of darkness'] = true,
  }
  offensiveSpells[player.ddSpell] = true
  offensiveSpells[player.stormSpell] = true

  return offensiveSpells

end

druid.helpShort = function(chan)
  
  chan = chan or 'gstat'
  
  send(chan .. ' druidbot v0.1')
  send(chan .. ' ..................................')
  send(chan .. ' If using group tell or group status to issue commands prefix')
  send(chan .. ' all commands with the first 2+ letters of my name')
  send(chan .. ' i.e. "gstat ' .. rex.gsub(player.name, [[^(\w\w).*]], '%1'):lower() .. ' help" to get the help file')     
  send(chan .. ' ..................................')

  
  druid.showConfig(chan)  
end

druid.help = function(chan)
  
  if (gmcp.Room.Info.num == druid.augRoom) then
    send(chan .. ' I am currently in the augmenting room')
    return
  end

  chan = chan or 'gstat'

  local spells = {}
  for spell in pairs(druid.getSpells()) do
    if (player.skills[spell] and player.skills[spell] &gt; 0) then
      table.insert(spells, spell)
    end
  end
  
  send(chan .. ' druidbot v0.1')
  send(chan .. ' ..................................')
  send(chan .. ' If using group tell or group status to issue commands prefix')
  send(chan .. ' all commands with the first 2+ letters of my name')
  send(chan .. ' i.e. "gstat ' .. rex.gsub(player.name, [[^(\w\w).*]], '%1'):lower() .. ' help" to get this help') 
  send(chan .. ' ..................................')
  
  send(chan .. ' . help                                 - see this help file')
  send(chan .. ' . config                               - reports current config')
  send(chan .. ' . prep &lt;amount&gt;                        - set how many ' .. player.stormSpell .. 's to keep prepped')    
  send(chan .. ' ..................................')
  
  send(chan .. ' . assist &lt;spell&gt;[,&lt;spell&gt;,&lt;spell&gt;...]')
  send(chan .. ' .  - set assist spell and follow up spells')
  send(chan .. ' . e.g. assist undergrowth, ' .. player.stormSpell .. ', ' .. player.ddSpell .. ', ' .. player.ddSpell)
 
  send(chan .. ' ..................................')
  
  send(chan .. ' . adds &lt;spell&gt;[,&lt;spell&gt;,&lt;spell&gt;...]')
  send(chan .. ' .   - set spells to cast on adds that walk in during combat')      
  send(chan .. ' . e.g. adds undergrowth, ' .. player.stormSpell)
  send(chan .. ' ..................................')
  
      
  send(chan .. ' . mode &lt;mode&gt;')
  send(chan .. ' .   - sets assist mode (non standard modes require tank to provide next room data)')    
  send(chan .. ' . valid modes are: ' .. table.concat(table.keys(druid.assist.validModes), ', ') )     
  send(chan .. ' ..................................')
    
       
  send(chan .. ' . add-mode &lt;mode&gt;')
  send(chan .. ' .   - sets mode for adds that walk in')    
  send(chan .. ' . valid modes are: ' .. table.concat(table.keys(druid.assist.validAddModes), ', ') )     
  send(chan .. ' ..................................')
     
    
    
  if (druid.assist.mode ~= 'standard') then  
    send(chan .. ' . aoe &lt;spell&gt;[,&lt;spell&gt;,&lt;spell&gt;...]')
    send(chan .. ' .   - set spells to cast when tank species aoe for the next room')      
    send(chan .. ' . e.g. aoe ' .. player.stormSpell)
    send(chan .. ' ..................................')
  
    send(chan .. ' . nasty &lt;spell&gt;[,&lt;spell&gt;,&lt;spell&gt;...]')
    send(chan .. ' .   - set spells to cast when tank speciesa nasty target in the next room')      
    send(chan .. ' . e.g. nasty undergrowth, ' .. player.stormSpell .. ', ' .. player.ddSpell .. ', ' .. player.ddSpell)
    send(chan .. ' ..................................')
      
    send(chan .. ' . aoe-threshold &lt;amount&gt;')
    send(chan .. ' .   - amount of mobs to be in next room before aoe is used')      
    send(chan .. ' ..................................')
  end
  
  send(chan .. ' available spells: none, '.. common.tableToString(spells))
    
  send(chan .. ' ..................................')
  
  send(chan .. ' .')
  send(chan .. ' .')
  
  druid.showConfig(chan)
  
end

druid.showConfig = function(chan)
  chan = chan or 'gstat'
  
  send(chan .. ' . Current Settings:')
  
  send(chan .. ' . assist mode set to: ' .. druid.assist.mode) 
  send(chan .. ' . add mode set to: ' .. druid.assist.addMode) 
  
  send(chan .. ' . storm spell: '.. player.stormSpell .. ', prepping '.. tostring(player.prepStormAmount))
  
  send(chan .. ' . assist spells: '.. table.concat(druid.assist.spells, ', '))
  send(chan .. ' . add spells: '.. table.concat(druid.assist.addSpells, ', '))
  
  
  if (druid.assist.mode ~= 'standard') then
    send(chan .. ' . aoe spells set to: ' .. table.concat(druid.assist.aoeSpells, ', '))
    send(chan .. ' . nasty target spells set to: ' .. table.concat(druid.assist.nastySpells, ', '))  
    
    send(chan .. ' . aoe threshold set to: ' .. tostring(druid.assist.aoeThreshold))
  end

end

druid.setStormMinPrepped = function(amount, chan)
  
  chan = chan or 'gstat'
  
  if not rex.match(amount, [[^\d+$]]) then
    send(chan .. ' invalid minimum amount of ' .. player.stormSpell .. ' to keep preppred: ' .. tostring(amount))
    return
  end
  
  amount = tonumber(amount)
  

  player.minPreppedStormSpells = amount

  send(chan .. ' will now keep ' .. tostring(amount) .. ' casts of ' .. player.stormSpell .. ' prepped')  

end

druid.setStormPrep = function(amount, chan)
  
  -- player.stormEnabled = true
  -- player.prepStormAmount = 4
  
  chan = chan or 'gstat'
  
  if not rex.match(amount, [[^\d+$]]) then
    send(chan .. ' invalid amount of ' .. player.stormSpell .. ' to prep: ' .. tostring(amount))
    return
  end
  
  amount = tonumber(amount)
  
  if (player.prepped and player.prepped[player.stormSpell] and player.prepped[player.stormSpell] + 1 &gt; amount) then
    
    local clearAmt = amount - player.prepped[player.stormSpell]
    for i = 1, clearAmt do
      send('cast ' .. player.stormSpell)
    end
    
  end
  
  player.prepStormAmount = amount
  player.minPreppedStormSpells = amount
  
  if (amount &gt; 0) then
    player.stormEnabled = true
    send(chan .. ' will now prep ' .. tostring(amount) .. ' casts of ' .. player.stormSpell) 
  else
    player.stormEnabled = false
    send(chan .. ' no longer prepping ' .. player.stormSpell) 
  end
  
  
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>assist</name>
					<packageName></packageName>
					<script>druid = druid or {}
druid.assist = druid.assist or {}

druid.assist.spells = druid.assist.spells or { 'none' }
druid.assist.addSpells = druid.assist.addSpells or { 'none' }
druid.assist.aoeSpells = druid.assist.aoeSpells or { 'none' }
druid.assist.nastySpells = druid.assist.nastySpells or { 'none' }
druid.assist.aoeThreshold = druid.assist.aoeThreshold or 0
druid.assist.mode = druid.assist.mode or 'standard'
druid.assist.addMode = druid.assist.addMode or 'defensive'
druid.assist.mobs = druid.assist.mobs or {
  standard = {},
  nasty = {},
  ignore = {},
  all = {},
}

  
druid.assist.validModes = {
  standard = true,
  ["next-room"] = true,
  ["next-room-cc"] = true,
}

druid.assist.validAddModes = {
  aggressive = true,
  defensive = true,
}
    

druid.assist.reset = function()
  druid.assist.set(player.ddSpell .. ', ' .. player.ddSpell, 'assist')
  druid.assist.set(player.ddSpell .. ', ' .. player.ddSpell, 'adds')
  druid.assist.mode = 'standard'
  druid.assist.addMode = 'defensive'
  druid.assist.mobs = {
    standard = {},
    nasty = {},
    ignore = {},
    all = {},
  }
end


druid.assist.setAddMode = function(mode, chan)

  chan = chan or 'gstat'
  
  if not druid.assist.validAddModes[mode] then
    send(chan .. ' invalid add mode: ' .. tostring(mode))
    send(chan .. ' valid add modes are: ' .. table.concat(table.keys(druid.assist.validAddModes), ', '))
    return
  end
  
  druid.assist.addMode = mode

  send(chan .. ' add mode set to: ' .. mode) 
  
end


druid.assist.getMobType = function(mob)
  
  druid.assist.mobs[gmcp.Room.Info.area] = druid.assist.mobs[gmcp.Room.Info.area] or {
    standard = {},
    nasty = {},
    ignore = {},
    all = {},    
  } 
  
  if druid.assist.mobs[gmcp.Room.Info.area].standard[mob] then
    return 'standard'
  elseif druid.assist.mobs[gmcp.Room.Info.area].nasty[mob] then
    return 'nasty'
  elseif druid.assist.mobs[gmcp.Room.Info.area].ignore[mob] then
    return 'ignore'
  end
  
  return nil
  
end


druid.assist.setMobType = function(mob, mobType)

  local existingType = druid.assist.getMobType(mob)
  
  if mobType == existingType then
    return
  end
  
  -- remove mob from its existing type (or add it to the list of all mobs)
  if existingType then
    druid.assist.mobs[gmcp.Room.Info.area][existingType][mob] = nil
  else
    druid.assist.mobs[gmcp.Room.Info.area].all[mob] = true
  end

  -- assign new type
  druid.assist.mobs[gmcp.Room.Info.area][mobType][mob] = true
  
end

druid.assist.mobJoinedFight = function(evt, mob)

  local mobType = druid.assist.getMobType(mob)
   
  if not mobType then
  
    cecho('\n&lt;green&gt;DRUID ASSIST:&lt;white&gt; new mob joined fight, ' .. mob .. '\n')    
    druid.assist.setMobType(mob, 'standard')
    
  end

end


druid.assist.setAoeThreshold = function(amount, chan)
  
  -- player.stormEnabled = true
  -- player.prepStormAmount = 4
  
  chan = chan or 'gstat'
  
  if not rex.match(amount, [[^\d+$]]) then
    send(chan .. ' invalid aoe threshold: ' .. tostring(amount))
    return
  end
  
  druid.assist.aoeThreshold = tonumber(amount)
  
  if (druid.assist.aoeThreshold &gt; 0) then
    send(chan .. ' will now use aoe if at least ' .. tostring(amount) .. ' targets are in the next room') 
  else
    send(chan .. ' will no longer use aoe spells') 
  end
  
  
end

druid.assist.setMode = function(mode, chan)

  chan = chan or 'gstat'
  
  if not druid.assist.validModes[mode] then
    send(chan .. ' invalid assist mode: ' .. tostring(mode))
    send(chan .. ' valid assist modes are: ' .. table.concat(table.keys(druid.assist.validModes), ', '))
    return
  end
  
  druid.assist.mode = mode

  if (druid.assist.mode == 'standard') then
    send(' assist -a ' .. druid.assist.spells[1])
  else
    send(' assist -a none')
  end

  send(chan .. ' assist mode set to: ' .. mode) 
  
end



druid.assist.set = function (spells, assistType, chan)
  
  chan = chan or 'gstat'
  spells = spells or 'none'
  
  if (spells == '') then spells = 'none' end

  spells = rex.gsub(spells, [[\s*,\s*]], ','):split(',')
   
  for idx, spell in ipairs(spells) do
    if not (spell == 'none' or (player.skills[spell] and player.skills[spell] &gt; 0)) then
      send(chan .. ' invalid ' .. assistType .. ' spell: ' .. spell)
      return
    end 
  end 

  if (assistType == 'assist') then  
    druid.assist.spells = spells
    if (druid.assist.mode == 'standard') then
      send(' assist -a ' .. druid.assist.spells[1])
    else
      send(' assist -a none')
    end
    send(chan .. ' assist spells set to: ' .. table.concat(druid.assist.spells, ', '))
  elseif (assistType == 'adds') then  
    druid.assist.addSpells = spells
    send(chan .. ' add spells set to: ' .. table.concat(druid.assist.addSpells, ', '))
  elseif (assistType == 'aoe') then  
    druid.assist.aoeSpells = spells
    send(chan .. ' aoe spells set to: ' .. table.concat(druid.assist.aoeSpells, ', '))
  elseif (assistType == 'nasty') then  
    druid.assist.nastySpells = spells
    send(chan .. ' nasty target spells set to: ' .. table.concat(druid.assist.nastySpells, ', '))
  end
  
end

  

-- You begin casting gale.
-- A female kobold is DEAD!!
-- You begin casting gale.


-- druid.getAttackCmd = function(target)
  -- 
  -- local spell == druid.assist.spells[1]
  -- 
  -- if (spell == player.stormSpell) then
    -- expandAlias('storm')
  -- elseif (druid.assist.useAlias[spell]) then
    -- expandAlias(spell)
  -- else
    -- send('cast ' .. spell)
  -- end 
-- 
-- 
-- end


druid.assist.castStarted = function(evt, spell) 
  -- display('cast start event:', evt, spell)
  
  if (druid.assist.mode == 'standard' and not druid.assist.assistCommandsSent) then
  
    if (spell == druid.assist.spells[1]) then
      -- cecho(' &lt;-- &lt;green&gt;DRUID:&lt;white&gt; autoassist started')
      -- display('fighting data:', gmcp.Char.Fighting)
      
      for idx = 2, #druid.assist.spells do
        
        local spell = druid.assist.spells[idx]
        
        if (spell == player.stormSpell) then
          expandAlias('storm')
        elseif (druid.assist.useAlias[spell]) then
          expandAlias(spell)
        else
          send('cast ' .. spell)
        end 
        
      end
      
      -- target other mobs in room if we know who we are fighting
      -- if combat.mobCount &gt; 0 then
        -- display('mobs in combat during initial assist cast:', combat.mobs)
        -- 
        -- -- if we don't know who we are targeting yet wait til gmcp is updated
        -- -- only need one instance of this running. not one per add
        -- local currentTarget = njs50.gmcp.previous.target
        -- if (currentTarget == '') then              
          -- display('waiting for new target to be aquired')
          -- njs50.tempTimedNextEvent(4, common.events.FIGHTING_TARGET_UPDATE, function(evt, newTarget)
            -- display('new target is:', newTarget)
          -- end)
        -- end
                -- 
      -- end
      
      
      druid.assist.assistCommandsSent = true
    end
  
  end
  
end

druid.assist.useAlias = {
  xerotes = true,
  tranquility = true,
  storm = true,
}

druid.assist.mobDied = function(evt, mob)
  -- display('mob died event:', evt, mob)
  if (druid.assist.mode == 'standard' and druid.assist.assistCommandsSent) then
    cecho(' &lt;-- &lt;green&gt;DRUID:&lt;white&gt; autoassist finished')
    druid.assist.assistCommandsSent = nil
  end
end

druid.assist.roomChanged = function(evt)

  tempTimer(0, function()
    
    -- display(' &lt;-- room changed (druid assist)')
    
    -- clear any old player.nextRoom instructions (in case we moved before deciding room was clear)
    if (player.nextRoom and player.nextRoom.processed) then
      player.nextRoom = nil
    end
    
    if (druid.assist.mode == 'standard' and druid.assist.assistCommandsSent) then
      cecho(' &lt;-- &lt;green&gt;DRUID:&lt;white&gt; autoassist finished')
      druid.assist.assistCommandsSent = nil
    end
    
    if (druid.assist.mode ~= 'standard' and player.nextRoom) then
    
      local nr = player.nextRoom
  
      local cmd = ''
  -- druid.assist.spells = druid.assist.spells or { 'none' }
  -- druid.assist.addSpells = druid.assist.addSpells or { 'none' }
  -- druid.assist.aoeSpells = druid.assist.aoeSpells or { 'none' }
  -- druid.assist.nastySpells = druid.assist.nastySpells or { 'none' }
  -- druid.assist.aoeThreshold = druid.assist.aoeThreshold or 0
  -- druid.assist.mode = druid.assist.mode or 'standard'      
      
      -- if we should do our aoe moves, do these first
      if (nr.aoe and druid.assist.aoeThreshold &gt; 0 and player.nextRoom.targetCount &gt;= druid.assist.aoeThreshold) then
        for idx = 1, #druid.assist.aoeSpells do
          local spell = druid.assist.aoeSpells[idx]
          if (spell == player.stormSpell) then
            expandAlias('storm')
          elseif (druid.assist.useAlias[spell]) then
            expandAlias(spell)
          else
            send('cast ' .. spell)
          end 
        end
      end
    
      -- target moves either regular or nasty mob specials
      local mobs = nr.ccMobs:split(',')
      
      local start = #mobs
      local fin = 1
      local incr = -1  
      
      -- reverse order we hit mobs if we are in cc mode
      if (druid.assist.mode == 'next-room-cc') then
        start = 1
        fin = #mobs
        incr = 1
      end
    
      local spellList = druid.assist.spells
      
      if (nr.nasty and #druid.assist.nastySpells &gt; 0 and druid.assist.nastySpells[1] ~= 'none') then
        spellList = druid.assist.nastySpells
      end
      
      -- in next-room-cc mode cast one spell on each mob then go to the next spell + repeat
      if (druid.assist.mode == 'next-room-cc') then      
          
        for sidx = 1, #spellList do
          
          for midx = start, fin, incr do
          
            local target = mobs[midx]
  
            local spell = spellList[sidx]
            if (spell == player.stormSpell) then
              expandAlias('storm')
            elseif (druid.assist.useAlias[spell]) then
              expandAlias(spell)
            else
              send('|cast ' .. spell .. ' ' ..  target)
            end 
            
          end 
        end
          
      else
        
          for idx = start, fin, incr do
          
            local target = mobs[idx]
      
            for idx = 1, #spellList do
              local spell = spellList[idx]
              if (spell == player.stormSpell) then
                expandAlias('storm')
              elseif (druid.assist.useAlias[spell]) then
                expandAlias(spell)  
              else
                send('|cast ' .. spell .. ' ' ..  target)
              end 
            
            end       
          end
      
      end
      
      player.nextRoom.processed = true
      
    end
    
  end, 'temp timer to make sure all other room change events process first')  
  
end


druid.assist.assistSet = function(evt, assistSpell) 

  if (druid.assist.mode == 'standard' and assistSpell ~= druid.assist.spells[1]) then
    
    -- if it's actually their storm spell then this is okay...
    if (druid.assist.spells[1] == storm and assistSpell == player.stormSpell) then
      return
    end
    
    cecho('\n\n&lt;orange&gt;DRUID:&lt;white&gt; assist manually set, reconfiguring auto assist\n\n')
    druid.assist.set(assistSpell, 'assist')
  end

end



druid.assist.mobArrived = function(evt, mob)  
  
  local mobType = druid.assist.getMobType(mob)
  
  local existing = combat.mobs[mob] or 0
  local pending = combat.pendingMobs[mob] or 0
  
  local mob = tostring(existing + pending) .. '.' .. mob
  -- 
  cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; mob arrived: ' .. mob .. 
    -- '\n ' .. tostring(existing) .. ' in fight already' ..
    -- '\n ' .. tostring(pending) .. ' about to join fight' .. 
    '\n\n')


  if mobType then
  
    if (combat.active or druid.assist.addMode == 'aggressive') then
      cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; mob (' .. mobType .. ') arrived: ' .. mob .. '\n')
      druid.assist.killAdd(mob, mobType)
    else
      cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; mob arrived: ' .. mob .. ' but we are not in combat\n')
    end
  else
    cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; unknown mob arrived: ' .. mob .. '\n')
  end

end

druid.assist.killAdd = function(mob)
  cecho(' &lt;-- &lt;green&gt;DRUID:&lt;white&gt; autocast on add started: ' .. mob)
  for idx = 1, #druid.assist.addSpells do
    local spell = druid.assist.addSpells[idx]
    
    if (spell == player.stormSpell) then
      expandAlias('storm')
    elseif (druid.assist.useAlias[spell]) then
      expandAlias(spell)
    else
      send('cast ' .. spell .. ' ' .. mob)
    end   
  end
end


druid.assist.roomClear = function()
  cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; room clear\n')
  if (player.nextRoom and player.nextRoom.processed) then
    player.nextRoom = nil
  end  
end

druid.assist.combatStart = function()
  cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; combat started\n')
  -- display('fighty data:', gmcp.Char.Fighting)
  if ((gmcp.Group.leader == gmcp.Char.Score.name or druid.assist.mode ~= 'standard') and not player.nextRoom and not druid.assist.killCommandAttack) then
    cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; unexpected combat\n')
    -- display(combat.mobs)
    
    for mob, count in pairs(combat.mobs) do
      -- display(mob, count)
      for idx = 1, count do
        druid.assist.killAdd( tostring(idx) .. '.' .. mob )
      end
    end
    
  end
end

druid.assist.combatEnd = function()
  cecho('&lt;green&gt;DRUID ASSIST:&lt;white&gt; combat ended\n')
  if (player.nextRoom and player.nextRoom.processed) then
    player.nextRoom = nil
  end  
  -- display('fighty data:', gmcp.Char.Fighting)
end

druid.assist.delayedAttack = function(at)
  
  local options = player.delayedAttackOptions or {}
  
  local reduceDelayAmount = options.reduceDelayAmount or 0  
  
  local delay = tonumber(at) - getEpoch()
  
  delay = delay - reduceDelayAmount

  if (delay &lt; 0) then 
    delay = 0  
  end
  
  if (options.runInstantly) then
    options.runInstantly()
  end   
      
  cecho('\n&lt;green&gt;MURDER:&lt;white&gt; delayed attack in ' .. tostring(delay) .. ' seconds\n')
  
  tempTimer(delay, function() 
    cecho('\n&lt;green&gt;MURDER:&lt;white&gt; delayed attack executing\n')
    -- prevent unexpected combat being triggered on next combat start
    druid.assist.killCommandAttack = true
    common.onNextEvent(common.events.COMBAT_STARTED, function()
      tempTimer(0, function()
        druid.assist.killCommandAttack = nil
      end)
    end)
        
    druid.assist.roomChanged()
  end, 'delayed attack')      
      
  
end


-- 
-- druid.assist.getKillCommand = function(exit, exits, direction)
  -- 
  -- local killTarg 
  -- 
  -- local spells = druid.assist.spells
-- 
  -- if exit.nastyTarget then
    -- spells = druid.assist.nastySpells
  -- end
  -- 
  -- killTarg = function(spell, target)
    -- -- expanding aliases needs to wait until after move command is sent
    -- 
    -- local spellIdx = table.index_of(spells, spell)
    -- 
    -- if (spell == player.stormSpell) then
      -- tempTimer(0, function()
        -- expandAlias('storm')
      -- end)
      -- 
      -- if spellIdx &lt; #druid.assist.spells then
        -- killTarg(spells[spellIdx + 1], target)
      -- end
      -- 
    -- elseif (druid.assist.useAlias[spell]) then
      -- tempTimer(0, function()
        -- expandAlias(spell)
      -- end)
      -- 
      -- if spellIdx &lt; #druid.assist.spells then
        -- killTarg(spells[spellIdx + 1], target)
      -- end      
      -- 
    -- else
      -- tempTimer(0, function()
        -- send('cast ' .. spell .. ' ' .. target)
      -- end)
    -- end 
  -- end
-- 
  -- if (exit and exit.firstTarget) then
  -- 
    -- murder.setLocalNextRoom(exit)
    -- 
    -- local spell = spells[1]
    -- 
    -- killTarg(spell, exit.firstTarget)
 -- 
  -- end
  -- 
  -- return ''
-- 
-- end

druid.assist.mobBlockedExit = function(evt, mob, direction)
  -- display('mbe:', evt, mob, direction, murder.exits)
  if (murder.exits and murder.exits.here) then
    expandAlias(druid.assist.getKillCommand(murder.exits.here, murder.exits, 'here'))
  else
    druid.assist.mobArrived(evt, mob)
  end
end


druid.assist.getKillCommand = function(exit, exits, direction)

  if (druid.assist.ignoreNextScanHere) then
    druid.assist.ignoreNextScanHere = nil  
    if (direction == 'here') then
      cecho(' &lt;-- &lt;green&gt;DRUID:&lt;white&gt; skipping kill command for here')    
      return ''
    end
  end  
  
  -- 
    
  local cmd = {}

  if (exit) then
  
    cecho(' &lt;-- &lt;green&gt;DRUID:&lt;white&gt; get kill command for: ' .. direction)
  
  
  -- {
    -- allTargets = { "1.tavernkeeper", "1.servant.girl", "1.blonde.wench" },
    -- distinctTargets = 3,
    -- firstTarget = "tavernkeeper",
    -- nastyTarget = false,
    -- nonHostileTargetCount = 0,
    -- nonTargetCount = 0,
    -- targetCount = 3
  -- }    
 
    -- if we should do our aoe moves, do these first
    if (exit.nonTargetCount == 0 and druid.assist.aoeThreshold &gt; 0 and exit.targetCount &gt;= druid.assist.aoeThreshold) then
      for idx = 1, #druid.assist.aoeSpells do
        local spell = druid.assist.aoeSpells[idx]
        if (spell == player.stormSpell) then
          table.insert(cmd, 'storm')
        elseif (druid.assist.useAlias[spell]) then
          table.insert(cmd, spell)
        else
          table.insert(cmd, 'cast ' .. spell)
        end 
      end
    end
  
    -- target moves either regular or nasty mob specials
    local mobs = exit.allTargets
  
    local spellList = druid.assist.spells
    
    if (exit.nastyTarget and #druid.assist.nastySpells &gt; 0 and druid.assist.nastySpells[1] ~= 'none') then
      spellList = druid.assist.nastySpells
    end
    
    local xi = table.index_of(spellList, 'xerotes')    
    -- if xerotes is in the list, do it before we move
    if (direction ~= 'here' and xi) then
      expandAlias('xerotes')
      table.remove(spellList, xi)
    end   
     
  
    for idx = 1, #mobs do
    
      local target = mobs[idx]

      for idx = 1, #spellList do
        local spell = spellList[idx]
        if (spell == player.stormSpell) then
          table.insert(cmd, 'storm')
        elseif (druid.assist.useAlias[spell]) then
          table.insert(cmd, spell)
        else
          table.insert(cmd, 'cast ' .. spell .. ' ' ..  target)
        end
      
      end    
         
    end
   
  end
  
  
  if #cmd &gt; 0 then
  
    -- prevent next kill command with scan when entering next room
    if (direction ~= 'here') then
      druid.assist.ignoreNextScanHere = true
    end
  
    -- prevent unexpected combat being triggered on next combat start
    druid.assist.killCommandAttack = true
    common.onNextEvent(common.events.COMBAT_STARTED, function()
      tempTimer(0, function()
        druid.assist.killCommandAttack = nil
      end)
    end)
  end
  
  return table.concat(cmd, ' &amp; ')

end



druid.assist.setNextRoom = function(exit, exits, direction)
  
  if (exit) then
  
    if (exit and exit.firstTarget) then  
      murder.setLocalNextRoom(exit)  
    end

  end
  
  return ''

end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.castStarted</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON:spell_cast_started</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.mobDied</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON:trigger_fighting_mob_left</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.assistSet</name>
					<packageName></packageName>
					<script>-- You will auto.assist with gale.
-- Your auto.assist skill has been set to none.</script>
					<eventHandlerList>
						<string>COMMON:assist_set</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.roomChanged</name>
					<packageName></packageName>
					<script>-- tfe.events.ROOM_CHANGED</script>
					<eventHandlerList>
						<string>tfe mapper: room found</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.mobArrived</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON:trigger_mob_entered_room</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.combatStart</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON::combat_started</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.combatEnd</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON::combat_ended</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.mobJoinedFight</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON:trigger_fighting_mob_added</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.roomClear</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON::current_room_is_clear</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.tests</name>
					<packageName></packageName>
					<script>druid.assist.test = {}

druid.assist.test.setup = function()
  
  druid.assist.reset()
  
  send('gstat mo mode next-room')
  send('gstat mo aoe-threshold 3')
  send('gstat mo assist undergrowth, wind shear')
  send('gstat mo nasty undergrowth, gale, gale')
  send('gstat mo adds gust, gust, gust')
  send('gstat mo aoe tornado, impede')
  send('gstat mo add-mode defensive')
  
  raiseEvent(tfe.events.ROOM_CHANGED)

end


local ft = function(s)
  s = string.gsub(s, "%$", "\n")
  feedTriggers("\n" .. s .. "\n")
  echo("\n")
end


druid.assist.test.addDefensive = function()
  
  druid.assist.test.setup()
  
  druid.assist.setMobType('a.fat.cat', 'standard')
  druid.assist.setMobType('a.fat.chicken', 'standard')
  
  tempTimer(3, function()
    ft('A fat cat minces in from the north.')
  end)  
  
  tempTimer(5, function()
    combat.active = true
    ft('A fat chicken minces in from the north.')
  end)  

end


druid.assist.test.addAggressive = function()
  
  druid.assist.test.setup()
  
  druid.assist.setMobType('a.fat.chicken', 'standard')
  
  tempTimer(1, function()
    send('gstat mo add-mode aggressive')
  end)  
 
   tempTimer(3, function()
    combat.active = true
    ft('A fat cat minces in from the north.')
  end)  
  
  tempTimer(5, function()
    ft('A fat chicken minces in from the north.')
  end)  

end

-- next room
druid.assist.test.standard = function()
  
  druid.assist.test.setup()
  
  tempTimer(4, function()
    send('gstat mo config')
    send('gstat testing standard fight')
  end)
  
  tempTimer(7, function()
    ft('You report group status: "next room has 1 target, aoe-safe, attack: timberwolf, cc-order: 1.timberwolf"')
    raiseEvent(tfe.events.ROOM_CHANGED)
  end)

end

-- next room
druid.assist.test.delayed = function()
  
  druid.assist.test.setup()
  
  tempTimer(2, function()
    send('gstat mo config')
    send('gstat testing delayed fight')
  end)
  
  tempTimer(4, function()
    ft('You report group status: "next room has 1 target, aoe-safe, destroy: minotaur.cartographer, cc-order: 1.minotaur.cartographer"')
    ft('You report group status: "attack at ' .. tostring(getEpoch() + 2) .. '"')
  end)

end

-- next room (aoe)
druid.assist.test.aoe = function()
  
  druid.assist.test.setup()
  
  tempTimer(4, function()
    send('gstat mo config')
    send('gstat testing standard fight')
  end)
  
  tempTimer(7, function()
    ft('You report group status: "next room has 3 targets, aoe-safe, attack: red.fox, cc-order: 1.chipmunk,1.grizzly.bear,1.red.fox"')
    raiseEvent(tfe.events.ROOM_CHANGED)
  end)


end



-- next room (unexpected attack without changing rooms)
druid.assist.test.unexpected = function()
  
  druid.assist.test.setup()
  
  tempTimer(4, function()
    send('gstat mo config')
    send('gstat testing standard fight')
  end)
  
  tempTimer(7, function()
    ft('A fat cat leaps to attack you!')
  end)


end


-- standard. should only cast one undergrowth
druid.assist.test.single_cast = function()
  
  druid.assist.test.setup()
  
  tempTimer(4, function()
    send('gstat mo config')
    send('gstat mo assist undergrowth')
    send('gstat testing standard fight')
  end)
  
  tempTimer(7, function()
    ft('You report group status: "next room has 1 target, aoe-safe, attack: bridge.troll, cc-order: 1.bridge.troll"')
    raiseEvent(tfe.events.ROOM_CHANGED)
  end)

  tempTimer(8.5, function()
    ft('You begin casting undergrowth.')
    ft('Holding your palms downward, you reach into the ground and find a pocket of vital energy underneath a bridge troll.')
    ft('You stop hiding.')
    ft('+++ You cast undergrowth +++')
    ft('Thick vines grow up around a bridge troll.')  
  end)

  tempTimer(10, function()
    ft('Your uppercut injures [5] a bridge troll\'s body.  [ slightly scratched ]')
    ft('A bridge troll counterattacks you!')
  end)

  tempTimer(12, function()
    ft('A bridge troll\'s attack misses you.')
    ft('A bridge troll\'s left claw hits [4] your leg.')
    ft('Your lash devastates [22] a bridge troll\'s waist.  [ some cuts ]')
  end)

  tempTimer(14, function()
    ft('A bridge troll\'s attack misses you.')
    ft('A bridge troll\'s left claw hits [4] your leg.')
    ft('Your lash devastates [22] a bridge troll\'s waist.  [ some cuts ]')
  end)

  tempTimer(15, function()
    ft('        A bridge troll is DEAD!!')
  end)

end


-- Darion reports group status: "next room has 1 target, aoe-safe, destroy: minotaur.cartographer, cc-order: 1.minotaur.cartographer"
-- Darion reports group status: "attack at 1640911393.543"



-- You begin casting undergrowth.
-- Holding your palms downward, you reach into the ground and find a pocket of vital energy underneath a rabbit.
-- You stop hiding.
-- +++ You cast undergrowth +++
-- Thick vines grow up around a rabbit.

-- Your uppercut injures [5] a bridge troll's body.  [ slightly scratched ]
-- A bridge troll counterattacks you! 
-- A bridge troll's attack misses you.
-- A bridge troll's left claw hits [4] your leg.
-- Your lash devastates [22] a bridge troll's waist.  [ some cuts ]
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>druid.assist.mobBlockedExit</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>COMMON:trigger_mob_blocked_exit</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>njs50-cleric</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>prep / sleep / stand</name>
				<packageName></packageName>
				<script>player = player or {}
cleric = cleric or {}

cleric.setDamageSpell = function (spell, cost, count)
  healer.damageSpell = spell
  healer.damageSpellCost = cost
  healer.damageSpellPrepAmount = count
end

cleric.count = function ()
  send('gstatus prepped ' .. tostring(healer.getPrepped()) .. ' ' .. healer.spell .. ', ' .. player.mp .. 'e' )
  if (healer.damageSpell) then
    local damPrepped = player.prepped[healer.damageSpell] or 0
    send('gstatus prepped ' .. tostring(damPrepped) .. ' ' .. healer.damageSpell)
  end
end


cleric.prep = function (reserve_mp, callback)

  local prepped = healer.getPrepped() or 0
  local amount = common.getPrepAmount(healer.spell_cost, reserve_mp or player.reserve_mp)
  
  if (amount &gt; 0) then
  	cecho('\n&lt;green&gt;PREP: &lt;white&gt;prepping cleric things with free mana')
    common.prep(healer.spell, prepped + amount, callback)
  else
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;prep not required')
    callback()
  end

end

cleric.prepFull = function (callback)
  
  if (not player.gettingFull) then
  
    player.gettingFull = true
    
    healer.topOff(player.name, function()
    
    	cleric.getFull(function () 
      	player.gettingFull = nil    
    		send('gstat ready (' .. player.name .. ')')
    		cleric.count()
      	if (callback) then callback() end
  		end)
        
    end) -- and of top off
  
  else
  	send('gstat already getting full...')
  end

end

cleric.useMedicant = function()
  if (gmcp.Char.Vitals.maxen - gmcp.Char.Vitals.en &gt; 200 and player.gear.hands.base.item == "medicant gauntlets") then
    send('rub gauntlet')
  end
end


cleric.getReady = function(callback)

  cleric.prepAvailable(function()
  
    local prepped = healer.getPrepped() or 0
  
    if ( prepped &lt; healer.minPrepped) then
    
      -- try to prep again when we have the min amount of mana required
      local manaRequired = (healer.minPrepped - prepped) * healer.spell_cost
      send('gstat waiting for ' .. tostring(manaRequired) .. 'e to prep ' .. tostring(healer.minPrepped) .. ' ' .. healer.spell)
      
      if (manaRequired &gt; 50) then
      
        equipPartial('sleep', function () 
          common.onManaReady(manaRequired, function ()
            resetGear(function()
              cleric.getReady(callback)
            end)
          end)
        end)
        
      else
        common.onManaReady(manaRequired, function ()
          cleric.getReady(callback)
        end)      
      end
    
    else
  		send('gstat ready (' .. player.name .. ')')
  		cleric.count()
  		if (callback) then callback() end          
    end
  
  end)

end

cleric.prepAvailable = function(callback)
  
  local amount = common.getPrepAmount(healer.spell_cost, player.reserve_mp)
  
  if (amount &gt; 0) then
    
  	cleric.prepStart(function ()
      cleric.useMedicant()
    	cleric.prep(player.reserve_mp, function ()  
        -- prep anything that regenerated while prepping
        cleric.useMedicant()
        cleric.prep(player.reserve_mp, function ()   
    		  cleric.prepEnd(callback)
        end)
      end)
    end)
  
  else
    -- not enough juice to prep anything no need to change gear etc
    callback()
  end
  
end


cleric.prepFree = function (callback) 
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep free')

	cleric.prepAvailable( function () 			
		send('gstat ready (' .. player.name .. ')')
		cleric.count()
		if (callback) then callback() end
	end)

end

cleric.equipSleep = function (post_change_cmd, callback)
  
  send('dismount &amp; stand')
	-- send('gs')
  equipPartial('sleep', function () 
  	player.sleepGear = true
    send('sit rug &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench &amp; sit chair &amp; sit mat &amp; sit boulder')
  	send(post_change_cmd)
		if (callback) then callback() end
  end)
	
end


cleric.equipStand = function (callback)

  send('stand')  

	-- send('gs')
  resetGear(function()
		player.sleepGear = false
    -- send('ps')
  	send('stand &amp; mount &amp; group')
		if (callback) then callback() end
  end)
  
end


cleric.getFull = function (callback)
  
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep full')
	
	local cb = callback

	-- maybe we're already prepped?
	if (
			(gmcp.Char.Vitals.maxen &lt; healer.spell_cost) and 
			(gmcp.Char.Vitals.hp &gt; gmcp.Char.Vitals.maxhp * 0.9) and
			(gmcp.Char.Vitals.mv &gt; gmcp.Char.Vitals.maxmv * 0.9)
	) then
		cecho('\n&lt;green&gt;PREP: &lt;white&gt;Already have ' .. tostring(player.mp_max) .. ' mana left to prep. skipping...') 
		if (cb) then cb() end
		return
	end
	
  cleric.useMedicant()
  
	cleric.equipSleep('sleep', function () 
  	
		common.onFull( function () 

			cleric.prepStart(function ()
      	cleric.prep(player.reserve_mp, function ()     
      		cleric.prepEnd( function () 	
        		cleric.equipStand( function ()
    					if (cb) then cb() end
        		end) -- end equip stand gear
        	end)
        end)
      end)
		
		end) -- end get full mana
		
	end) -- end equip sleep gear		
	
	
end



cleric.prepStart = function (callback) 
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start invoked...\n')

	player.prepping = true

	send('stand')
	
	equipPartial('prep', function () 
    	-- start prepping here... 
		cecho('\n&lt;green&gt;PREP: &lt;white&gt;gear changed, start prepping now...\n')
		if (callback) then
			callback()
		end	
	end, true)


end

cleric.prepEnd = function (callback) 

	cecho('\n&lt;green&gt;PREP: &lt;white&gt;... end invoked\n')
	
	player.prepping = nil
		
  resetGear(function () 
	   -- start prepping here... 
		send('stand')
		cecho('\n&lt;green&gt;PREP: &lt;white&gt;gear reset, end prepping now...\n')
		if (callback) then
			callback()
		end
	end)

end

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>improves</name>
				<packageName></packageName>
				<script>cleric = cleric or {}

cleric.improveThings = {

  ['armor'] = { cmd = '|cast armor %t &amp; order bimgore kill %t &amp; wait 10', level = 10},
  ['bless'] = { cmd = '|cast bless %t &amp; order bimgore kill %t &amp; wait 10', level = 10},
  
  -- nb: these might require mobs to have a certain alignment
  ['holy wrath'] = { cmd = '|cast holy wrath %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},
  
  ['aura shield'] = { cmd = '|cast aura shield %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},
  ['insight'] = { cmd = '|cast insight %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},

  ['protection/evil'] = { cmd = '|cast protection/evil %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},
  ['protection/chaos'] = { cmd = '|cast protection/chaos %t &amp; |order bimgore kill %t &amp; wait 10', level = 10},
}
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>cleric.mob_arrived</name>
				<packageName></packageName>
				<script>-- common.events.MOB_ENTERED_ROOM

cleric.mob_arrived = function()
  
  if (gmcp.Char.Status.position == 'resting') then
    send('+remove orb.supplication &amp; |stand')
  end
  
  njs50.timedTempTrigger(5, 1, [[^You abort preparing (.*)\.$]], function()
    
    local spell = matches[2]
    
    tempTimer(10, function()
      send('|prepare ' .. spell)
    end, 'delayed restart of prepare')
    
  end)
  
end</script>
				<eventHandlerList>
					<string>COMMON:trigger_mob_entered_room</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>njs50-warrior</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>prep / sleep / stand</name>
				<packageName></packageName>
				<script>player = player or {}
generic = generic or {}



generic.prepFull = function (callback)
  
  if (not player.gettingFull) then
  
    player.gettingFull = true
    -- in case we are interrupted and this isn't reset
    common.onNextEvent(tfe.events.ROOM_CHANGED, function()
      player.gettingFull = nil
    end)    

    	generic.getFull(function () 
      	player.gettingFull = nil    
    		send('gstat ready (' .. player.name .. ')')
      	if (callback) then callback() end
  		end)

  else
    send('gstat already getting full...')
  end

end



generic.prepFree = function (callback) 
	send('gstat ready (' .. player.name .. ')')
	if (callback) then callback() end
end

generic.equipSleep = function (post_change_cmd, callback)
  
  send('dismount &amp; stand')
  -- send('gs')
  equipPartial('sleep', function () 
    player.sleepGear = true
    send('sit rug &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench &amp; sit chair &amp; sit mat &amp; sit boulder')
    send(post_change_cmd)
    if (callback) then 
      callback() 
    end
  end)
	
end


generic.equipStand = function (callback)
  send('stand')  
  resetGear(function()
    player.sleepGear = false
    send('stand &amp; mount &amp; group')
    if (callback) then 
      callback() 
    end
  end)
end


generic.getFull = function (callback)
  
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep full')
	
	local cb = callback or function() end


  local targetEn = gmcp.Char.Vitals.maxen * 0.6
  local targetMv = gmcp.Char.Vitals.maxmv * 0.6
  local targetHp = gmcp.Char.Vitals.maxhp * 0.90
  
  if common.checkResources(targetHp, targetEn, targetMv) then
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;full enough already. skipping pfull\n') 
  		cb()
  		return
  	end

  	generic.equipSleep('sleep', function ()
    
  		common.onFullish(gmcp.Char.Vitals.maxhp * 0.9, targetEn, targetMv, function () 
    		
      generic.equipStand( cb ) -- end equip stand gear
		
    end) -- end get full mana
      
  	end) -- end equip sleep gear		

	
end


player.prepFull = generic.prepFull</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>gmcp</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>generic.exit_blocked_by_mob</name>
					<packageName></packageName>
					<script>generic = generic or {}
generic.exit_blocked_by_mob = function(evt, mob)
  send(player.getAttackCommand(mob))
end</script>
					<eventHandlerList>
						<string>COMMON:trigger_mob_blocked_exit</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>njs50-reaver</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>prep / sleep / stand</name>
				<packageName></packageName>
				<script>player = player or {}
reaver = reaver or {}


reaver.safeRoomAction = function(options)

  -- need purify  
  if (generic.hasAffect('confuse') or generic.hasAffect('curse')) then
    
    send('gstat ' .. options.healer .. ' can you cast purify ' .. player.name)
    tempTimer(10, function()
      reaver.safeRoomAction(options)
    end, 'delay for purify')
    return
  
  end


  farmer.time.namedStart('step_heal_time')
  
  local prepType = 'full'

  generic.groupHeal(options.healer, function()
    
    common.groupPrepIfUnder({ 
      mana = 70,
      heals = 1200,
      storms = 4,
      prepType = prepType,
      callback = function()
        farmer.time.namedStop('step_heal_time')
        options.callback()
      end,
    })   
       
  end)
  
  send('gstat time to drop ' .. farmer.options.shortName .. ' junk')
  send('gstat time to sort ' .. farmer.options.shortName .. ' junk')
  
  expandAlias('check weapons')
    

end
-- 
-- local safeAction = function(cb)
  -- reaver.safeRoomAction({ callback = function() cb() end, healer = groupHealer })
-- end

reaver.stepAction = function(options)

  njs50.search()
  

  -- need purify  
  if (generic.hasAffect('confuse') or generic.hasAffect('curse')) then
    
    send('gstat ' .. options.healer .. ' can you cast purify ' .. player.name)
    tempTimer(10, function()
      reaver.stepAction(options)
    end, 'delay for purify')
    return
  
  end
    
  
  if (not murder.sawAction) then
    cecho('\n&lt;green&gt;MURDER:&lt;white&gt; no action, no prep check\n')
    return options.callback()
  end
  
  farmer.time.namedStart('step_heal_time')
  
  local prepType = 'standing'
  
  if (options.allowSleep) then 
    prepType = 'full'
  end
  
  generic.groupHeal(options.healer, function()
    
    common.groupPrepIfUnder({ 
      mana = 25,
      heals = 1500,
      storms = 2,
      prepType = prepType,
      callback = function()
        farmer.time.namedStop('step_heal_time')
        options.callback()
      end,
    })   
       
  end)  
  
  send('gstat time to drop ' .. farmer.options.shortName .. ' junk')
  expandAlias('check weapons')
    

end

-- only checks self w/no healing step
reaver.lessSafeStepAction = function(options)


  njs50.search()
  

  -- need purify  
  if (generic.hasAffect('confuse') or generic.hasAffect('curse')) then
    
    send('gstat ' .. options.healer .. ' can you cast purify ' .. player.name)
    tempTimer(10, function()
      reaver.lessSafeStepAction(options)
    end, 'delay for purify')
    return
  
  end
  

  local targetEn = gmcp.Char.Vitals.maxen * 0.5
  local targetMv = gmcp.Char.Vitals.maxmv * 0.5
  local targetHp = gmcp.Char.Vitals.maxhp * 0.8
  
  if common.checkResources(targetHp, targetEn, targetMv) then
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;ready enough already. skipping step action\n')
    options.callback()
  else
    reaver.stepAction(options)
  end

end


reaver.prepFull = function (callback)
  

  if (player.skills['rite of delumination'] and player.skills['rite of delumination'] &gt; 0) then
    send('perform rite of delumination')
  else
    send('perform rite of illumination')
  end
  
  expandAlias('rotate weapons')    
  
  if (not player.gettingFull) then
  
    player.gettingFull = true
    -- in case we are interrupted and this isn't reset
    common.onNextEvent(tfe.events.ROOM_CHANGED, function()
      player.gettingFull = nil
    end)    

    	reaver.getFull(function () 
      	player.gettingFull = nil    
      expandAlias('check weapons') 
    		send('|gstat ready (' .. player.name .. ')')
      	if (callback) then callback() end
  		end)

  else
    send('gstat already getting full...')
  end

end



reaver.prepFree = function (callback) 

  expandAlias('check weapons')

  njs50.respell(player.buffs, {
    target = 'gstat',
    callback = function()
      	send('gstat ready (' .. player.name .. ')')
      	if (callback) then callback() end
    end,
  })
  
end

reaver.equipSleep = function (post_change_cmd, callback)
  
  send('dismount &amp; stand')
  -- send('gs')
  equipPartial('sleep', function () 
    player.sleepGear = true
    send('sit rug &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench &amp; sit chair &amp; sit mat &amp; sit boulder')
    send(post_change_cmd)
    if (callback) then 
      callback() 
    end
  end)
	
end


reaver.equipStand = function (callback)
  send('stand')  
  resetGear(function()
    player.sleepGear = false
    send('stand &amp; mount &amp; group')
    if (callback) then 
      callback() 
    end
  end)
end


reaver.getReady = function(cb)

	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start get ready')

  local targetEn = gmcp.Char.Vitals.maxen * 0.5
  local targetMv = gmcp.Char.Vitals.maxmv * 0.5
  local targetHp = gmcp.Char.Vitals.maxhp * 0.8
  
  if common.checkResources(targetHp, targetEn, targetMv) then
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;ready enough already. skipping pfull\n') 
    expandAlias('check weapons')
    njs50.respell(player.buffs, {
      target = 'gstat', 
      callback = function()
        send('|gstat ready (' .. player.name .. ')')
        if (cb) then cb() end
      end,
      failCallback = function()
        send('gstat unable to full respell')
        -- if (cb) then cb() end
        -- send('gstat ready (' .. player.name .. ')')
      end, 
    })
  		return
  	end
  
  common.onFullish(targetHp, targetEn, targetMv, function () 
  
    expandAlias('check weapons')
    njs50.respell(player.buffs, {
      target = 'gstat', 
      callback = function()
        send('|gstat ready (' .. player.name .. ')')
        if (cb) then cb() end
      end,
      failCallback = function()
        send('gstat unable to full respell')
        -- send('gstat ready (' .. player.name .. ')')
        -- if (cb) then cb() end
      end, 
    })
    
  end) -- end get full mana
      
end

reaver.getFull = function(callback)
  
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep full')
	
	local cb = callback or function() end


  local targetEn = gmcp.Char.Vitals.maxen * 0.90
  local targetMv = gmcp.Char.Vitals.maxmv * 0.6
  local targetHp = gmcp.Char.Vitals.maxhp * 0.90
  
  if player.getFullMoves == true then
    targetMv = gmcp.Char.Vitals.maxmv
  end
  
  if common.checkResources(targetHp, targetEn, targetMv) then
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;full enough already. skipping pfull\n') 
    njs50.respell(player.buffs, {
      target = 'gstat',
      callback = function()  
  		    cb()
      end,
    })
  		return
  	end

  	reaver.equipSleep('sleep', function ()
    
  		common.onFullish(gmcp.Char.Vitals.maxhp * 0.9, targetEn, targetMv, function () 
  		  reaver.equipStand(function()
        njs50.respell(player.buffs, {
          target = 'gstat',
          callback = function()  
            cb() -- end equip stand gear
          end,
        })
      end)		
    end) -- end get full mana
      
  	end) -- end equip sleep gear		

	
end


player.prepFull = reaver.prepFull</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>gmcp</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>generic.exit_blocked_by_mob</name>
					<packageName></packageName>
					<script>generic = generic or {}
generic.exit_blocked_by_mob = function(evt, mob)
  send(player.getAttackCommand(mob))
end</script>
					<eventHandlerList>
						<string>COMMON:trigger_mob_blocked_exit</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="no" isFolder="yes">
			<name>njs50-legate</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>prep / sleep / stand</name>
				<packageName></packageName>
				<script>player = player or {}
legate = reaver or {}


legate.prepFull = function (callback)
  
  send('perf rite of delumination')
  
  expandAlias('rotate weapons')    
  
  if (not player.gettingFull) then
  
    player.gettingFull = true
    -- in case we are interrupted and this isn't reset
    common.onNextEvent(tfe.events.ROOM_CHANGED, function()
      player.gettingFull = nil
    end)    

    	reaver.getFull(function () 
      	player.gettingFull = nil    
      expandAlias('check weapons') 
    		send('|gstat ready (' .. player.name .. ')')
      	if (callback) then callback() end
  		end)

  else
    send('gstat already getting full...')
  end

end



legate.prepFree = function (callback) 

  expandAlias('check weapons')

  njs50.respell(player.buffs, {
    target = 'gstat',
    callback = function()
      	send('gstat ready (' .. player.name .. ')')
      	if (callback) then callback() end
    end,
  })
  
end

legate.equipSleep = function (post_change_cmd, callback)
  
  send('dismount &amp; stand')
  -- send('gs')
  equipPartial('sleep', function () 
    player.sleepGear = true
    send('sit rug &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench &amp; sit chair &amp; sit mat &amp; sit boulder')
    send(post_change_cmd)
    if (callback) then 
      callback() 
    end
  end)
	
end


legate.equipStand = function (callback)
  send('stand')  
  resetGear(function()
    player.sleepGear = false
    send('stand &amp; mount &amp; group')
    if (callback) then 
      callback() 
    end
  end)
end


legate.getReady = function(cb)

	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start get ready')

  local targetEn = gmcp.Char.Vitals.maxen * 0.5
  local targetMv = gmcp.Char.Vitals.maxmv * 0.5
  local targetHp = gmcp.Char.Vitals.maxhp * 0.8
  
  if common.checkResources(targetHp, targetEn, targetMv) then
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;ready enough already. skipping pfull\n') 
    expandAlias('check weapons')
    njs50.respell(player.buffs, {
      target = 'gstat', 
      callback = function()
        send('|gstat ready (' .. player.name .. ')')
        if (cb) then cb() end
      end,
      failCallback = function()
        send('gstat unable to full respell')
        -- if (cb) then cb() end
        -- send('gstat ready (' .. player.name .. ')')
      end, 
    })
  		return
  	end
  
  common.onFullish(targetHp, targetEn, targetMv, function () 
  
    expandAlias('check weapons')
    njs50.respell(player.buffs, {
      target = 'gstat', 
      callback = function()
        send('|gstat ready (' .. player.name .. ')')
        if (cb) then cb() end
      end,
      failCallback = function()
        send('gstat unable to full respell')
        -- send('gstat ready (' .. player.name .. ')')
        -- if (cb) then cb() end
      end, 
    })
    
  end) -- end get full mana
      
end

legate.getFull = function(callback)
  
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;start prep full')
	
	local cb = callback or function() end


  local targetEn = gmcp.Char.Vitals.maxen * 0.6
  local targetMv = gmcp.Char.Vitals.maxmv * 0.6
  local targetHp = gmcp.Char.Vitals.maxhp * 0.90
  
  if common.checkResources(targetHp, targetEn, targetMv) then
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;full enough already. skipping pfull\n') 
    njs50.respell(player.buffs, {
      target = 'gstat',
      callback = function()  
  		    cb()
      end,
    })
  		return
  	end

  	reaver.equipSleep('sleep', function ()
    
  		common.onFullish(gmcp.Char.Vitals.maxhp * 0.9, targetEn, targetMv, function () 
  		  reaver.equipStand(function()
        njs50.respell(player.buffs, {
          target = 'gstat',
          callback = function()  
            cb() -- end equip stand gear
          end,
        })
      end)		
    end) -- end get full mana
      
  	end) -- end equip sleep gear		

	
end


player.prepFull = legate.prepFull</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>gmcp</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>generic.exit_blocked_by_mob</name>
					<packageName></packageName>
					<script>generic = generic or {}
generic.exit_blocked_by_mob = function(evt, mob)
  send(player.getAttackCommand(mob))
end</script>
					<eventHandlerList>
						<string>COMMON:trigger_mob_blocked_exit</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>last script (to trigger dependencies!)</name>
			<packageName></packageName>
			<script>raiseEvent('njs50PlevLoaded')
raiseEvent('njs50SharedLoaded')</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
